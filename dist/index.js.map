{"version":3,"sources":["../src/durable-objects/ConvexDatabase.ts","../src/durable-objects/ConvexSubscription.ts","../src/durable-objects/ConvexScheduler.ts","../src/durable-objects/ConvexStorage.ts","../src/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * ConvexDatabase Durable Object\n *\n * Core persistence layer using SQLite storage.\n * Provides ACID-compliant document storage with indexes.\n */\n\nimport type { Env } from '../env'\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\ninterface Document {\n  _id: string\n  _creationTime: number\n  [key: string]: unknown\n}\n\ninterface QueryFilter {\n  field: string\n  operator: 'eq' | 'neq' | 'lt' | 'lte' | 'gt' | 'gte'\n  value: unknown\n}\n\ninterface QueryOptions {\n  order?: {\n    field: string\n    direction: 'asc' | 'desc'\n  }\n  limit?: number\n  cursor?: string\n}\n\n// Exported types for schema management\nexport interface FieldDefinition {\n  type: string\n  optional: boolean\n  table?: string  // For ID references\n  element?: FieldDefinition  // For arrays\n  fields?: Record<string, FieldDefinition>  // For objects\n  variants?: FieldDefinition[]  // For unions\n  value?: unknown  // For literals\n}\n\nexport interface IndexDefinition {\n  name: string\n  fields: string[]\n  unique: boolean\n}\n\nexport interface TableSchema {\n  name: string\n  fields: Record<string, FieldDefinition>\n  indexes: IndexDefinition[]\n}\n\nexport interface SchemaDefinition {\n  tables: Record<string, TableSchema>\n}\n\nexport interface MigrationOperation {\n  type: 'addColumn' | 'dropColumn' | 'createTable' | 'dropTable' | 'createIndex' | 'dropIndex'\n  table: string\n  column?: string\n  definition?: FieldDefinition\n  index?: IndexDefinition\n}\n\nexport interface MigrationPlan {\n  fromVersion: number\n  toVersion: number\n  operations: MigrationOperation[]\n  expectedSchemaHash?: string\n}\n\nexport type SQLiteColumnType = 'TEXT' | 'REAL' | 'INTEGER' | 'BLOB'\n\n// Reserved system table names\nconst RESERVED_TABLES = new Set(['_documents', '_schema_versions', '_metadata'])\n\nexport class ConvexDatabase implements DurableObject {\n  private state: DurableObjectState\n  protected env: Env\n  private sql: SqlStorage\n  private initialized = false\n  private tables: Set<string> = new Set()\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.state = state\n    this.env = env\n    this.sql = state.storage.sql\n  }\n\n  /**\n   * Initialize the database schema\n   */\n  async ensureInitialized(): Promise<void> {\n    if (this.initialized) return\n\n    await this.state.blockConcurrencyWhile(async () => {\n      if (this.initialized) return\n\n      // Set SQLite pragmas for performance\n      this.sql.exec('PRAGMA journal_mode=WAL')\n      this.sql.exec('PRAGMA foreign_keys=ON')\n\n      // Create metadata table for tracking tables\n      this.sql.exec(`\n        CREATE TABLE IF NOT EXISTS _metadata (\n          key TEXT PRIMARY KEY,\n          value TEXT NOT NULL\n        )\n      `)\n\n      // Create _documents system table for tracking all documents\n      this.sql.exec(`\n        CREATE TABLE IF NOT EXISTS _documents (\n          _id TEXT PRIMARY KEY,\n          _table TEXT NOT NULL,\n          _creationTime INTEGER NOT NULL\n        )\n      `)\n\n      // Create _schema_versions system table for migration tracking\n      this.sql.exec(`\n        CREATE TABLE IF NOT EXISTS _schema_versions (\n          version INTEGER PRIMARY KEY,\n          applied_at INTEGER NOT NULL,\n          schema_hash TEXT NOT NULL\n        )\n      `)\n\n      // Load existing tables\n      const tablesResult = this.sql.exec(\n        `SELECT value FROM _metadata WHERE key = 'tables'`\n      ).toArray()\n\n      if (tablesResult.length > 0 && tablesResult[0]) {\n        const tables = JSON.parse(tablesResult[0].value as string) as string[]\n        tables.forEach(t => this.tables.add(t))\n      }\n\n      this.initialized = true\n    })\n  }\n\n  /**\n   * Check if initialized\n   */\n  isInitialized(): boolean {\n    return this.initialized\n  }\n\n  /**\n   * Ensure a table exists, creating it if necessary\n   */\n  private ensureTable(tableName: string): void {\n    if (this.tables.has(tableName)) return\n\n    // Create the table with JSON storage\n    this.sql.exec(`\n      CREATE TABLE IF NOT EXISTS \"${tableName}\" (\n        _id TEXT PRIMARY KEY,\n        _creationTime INTEGER NOT NULL,\n        data TEXT NOT NULL\n      )\n    `)\n\n    // Create index on creation time\n    this.sql.exec(`\n      CREATE INDEX IF NOT EXISTS \"${tableName}_creation_time\"\n      ON \"${tableName}\" (_creationTime)\n    `)\n\n    this.tables.add(tableName)\n\n    // Update metadata\n    this.sql.exec(\n      `INSERT OR REPLACE INTO _metadata (key, value) VALUES ('tables', ?)`,\n      JSON.stringify([...this.tables])\n    )\n  }\n\n  /**\n   * Generate a unique document ID\n   */\n  private generateId(): string {\n    // Generate a URL-safe base64 ID similar to Convex\n    const bytes = new Uint8Array(16)\n    crypto.getRandomValues(bytes)\n    return btoa(String.fromCharCode(...bytes))\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=/g, '')\n  }\n\n  /**\n   * Validate a document value for Convex compatibility\n   */\n  private validateValue(value: unknown, path: string = ''): void {\n    if (value === undefined) {\n      throw new Error(`Invalid value at ${path || 'root'}: undefined is not allowed (use null instead)`)\n    }\n    if (typeof value === 'function') {\n      throw new Error(`Invalid value at ${path || 'root'}: functions are not serializable`)\n    }\n    if (typeof value === 'symbol') {\n      throw new Error(`Invalid value at ${path || 'root'}: symbols are not serializable`)\n    }\n    if (typeof value === 'number') {\n      if (Number.isNaN(value)) {\n        throw new Error(`Invalid value at ${path || 'root'}: NaN is not a valid number`)\n      }\n      if (!Number.isFinite(value)) {\n        throw new Error(`Invalid value at ${path || 'root'}: Infinity is not a valid number`)\n      }\n    }\n    // BigInt is valid for int64 fields\n    if (typeof value === 'bigint') {\n      // BigInt is allowed - it will be serialized specially\n      return\n    }\n    if (Array.isArray(value)) {\n      value.forEach((item, index) => this.validateValue(item, `${path}[${index}]`))\n    } else if (value !== null && typeof value === 'object' && !(value instanceof ArrayBuffer)) {\n      // Check for circular references by trying to stringify\n      try {\n        JSON.stringify(value)\n      } catch (e) {\n        if ((e as Error).message.includes('circular')) {\n          throw new Error(`Invalid value at ${path || 'root'}: circular references are not allowed`)\n        }\n      }\n      // Recursively validate object properties\n      for (const [key, val] of Object.entries(value)) {\n        this.validateValue(val, path ? `${path}.${key}` : key)\n      }\n    }\n  }\n\n  /**\n   * Validate document for insert/update\n   */\n  private validateDocument(doc: Record<string, unknown>): void {\n    // Check for system field tampering\n    if ('_id' in doc) {\n      throw new Error('Cannot specify _id on insert - it is auto-generated')\n    }\n    if ('_creationTime' in doc) {\n      throw new Error('Cannot specify _creationTime on insert - it is auto-generated')\n    }\n\n    // Validate all values\n    this.validateValue(doc)\n  }\n\n  /**\n   * Serialize a document for storage\n   * Handles BigInt and ArrayBuffer special cases\n   */\n  private serializeDocument(doc: Record<string, unknown>): string {\n    return JSON.stringify(doc, (_key, value) => {\n      if (typeof value === 'bigint') {\n        return { __type: 'bigint', value: value.toString() }\n      }\n      if (value instanceof ArrayBuffer) {\n        return { __type: 'arraybuffer', value: Array.from(new Uint8Array(value)) }\n      }\n      return value\n    })\n  }\n\n  /**\n   * Deserialize a document from storage\n   * Handles BigInt and ArrayBuffer special cases\n   */\n  private deserializeDocument(data: string): Record<string, unknown> {\n    return JSON.parse(data, (_key, value) => {\n      if (value && typeof value === 'object' && value.__type === 'bigint') {\n        return BigInt(value.value)\n      }\n      if (value && typeof value === 'object' && value.__type === 'arraybuffer') {\n        return new Uint8Array(value.value).buffer\n      }\n      return value\n    })\n  }\n\n  /**\n   * Insert a new document\n   */\n  async insert(tableName: string, doc: Omit<Document, '_id' | '_creationTime'>): Promise<string> {\n    await this.ensureInitialized()\n\n    // Validate document\n    this.validateDocument(doc as Record<string, unknown>)\n\n    this.ensureTable(tableName)\n\n    const id = this.generateId()\n    const creationTime = Date.now()\n\n    this.sql.exec(\n      `INSERT INTO \"${tableName}\" (_id, _creationTime, data) VALUES (?, ?, ?)`,\n      id,\n      creationTime,\n      this.serializeDocument(doc as Record<string, unknown>)\n    )\n\n    // Also track in _documents\n    this.sql.exec(\n      `INSERT INTO _documents (_id, _table, _creationTime) VALUES (?, ?, ?)`,\n      id,\n      tableName,\n      creationTime\n    )\n\n    return id\n  }\n\n  /**\n   * Get a document by ID\n   */\n  async get(tableName: string, id: string): Promise<Document | null> {\n    await this.ensureInitialized()\n\n    if (!this.tables.has(tableName)) {\n      return null\n    }\n\n    const results = this.sql.exec(\n      `SELECT _id, _creationTime, data FROM \"${tableName}\" WHERE _id = ?`,\n      id\n    ).toArray()\n\n    if (results.length === 0 || !results[0]) {\n      return null\n    }\n\n    const row = results[0]\n    return {\n      _id: row._id as string,\n      _creationTime: row._creationTime as number,\n      ...this.deserializeDocument(row.data as string),\n    }\n  }\n\n  /**\n   * Validate fields for patch/update\n   */\n  private validatePatchFields(fields: Record<string, unknown>): void {\n    // Check for system field tampering\n    if ('_id' in fields) {\n      throw new Error('Cannot patch _id field - it is immutable')\n    }\n    if ('_creationTime' in fields) {\n      throw new Error('Cannot patch _creationTime field - it is immutable')\n    }\n\n    // Validate all values\n    this.validateValue(fields)\n  }\n\n  /**\n   * Patch (partial update) a document\n   */\n  async patch(tableName: string, id: string, fields: Record<string, unknown>): Promise<void> {\n    await this.ensureInitialized()\n\n    // Validate fields\n    this.validatePatchFields(fields)\n\n    if (!this.tables.has(tableName)) {\n      throw new Error(`Table \"${tableName}\" does not exist`)\n    }\n\n    const existing = await this.get(tableName, id)\n    if (!existing) {\n      throw new Error(`Document \"${id}\" not found in table \"${tableName}\"`)\n    }\n\n    const { _id, _creationTime, ...existingData } = existing\n    const newData = { ...existingData, ...fields }\n\n    this.sql.exec(\n      `UPDATE \"${tableName}\" SET data = ? WHERE _id = ?`,\n      JSON.stringify(newData),\n      id\n    )\n  }\n\n  /**\n   * Replace a document entirely\n   */\n  async replace(tableName: string, id: string, doc: Omit<Document, '_id' | '_creationTime'>): Promise<void> {\n    await this.ensureInitialized()\n\n    // Validate doc (no system fields allowed)\n    this.validateValue(doc)\n\n    if (!this.tables.has(tableName)) {\n      throw new Error(`Table \"${tableName}\" does not exist`)\n    }\n\n    const result = this.sql.exec(\n      `UPDATE \"${tableName}\" SET data = ? WHERE _id = ?`,\n      JSON.stringify(doc),\n      id\n    )\n\n    if (result.rowsWritten === 0) {\n      throw new Error(`Document \"${id}\" not found in table \"${tableName}\"`)\n    }\n  }\n\n  /**\n   * Delete a document\n   */\n  async delete(tableName: string, id: string): Promise<void> {\n    await this.ensureInitialized()\n\n    if (!this.tables.has(tableName)) {\n      return // Nothing to delete\n    }\n\n    this.sql.exec(`DELETE FROM \"${tableName}\" WHERE _id = ?`, id)\n\n    // Also remove from _documents\n    this.sql.exec(`DELETE FROM _documents WHERE _id = ?`, id)\n  }\n\n  /**\n   * Query documents with filters\n   */\n  async query(\n    tableName: string,\n    filters: QueryFilter[] = [],\n    options: QueryOptions = {}\n  ): Promise<Document[]> {\n    await this.ensureInitialized()\n\n    if (!this.tables.has(tableName)) {\n      return []\n    }\n\n    let sql = `SELECT _id, _creationTime, data FROM \"${tableName}\"`\n    const params: unknown[] = []\n\n    // Build WHERE clause from filters\n    if (filters.length > 0) {\n      const whereClauses = filters.map((filter) => {\n        const op = this.translateOperator(filter.operator)\n        params.push(JSON.stringify(filter.value))\n        // Use json_extract for nested field access\n        return `json_extract(data, '$.${filter.field}') ${op} ?`\n      })\n      sql += ` WHERE ${whereClauses.join(' AND ')}`\n    }\n\n    // Add ORDER BY\n    if (options.order) {\n      const direction = options.order.direction === 'desc' ? 'DESC' : 'ASC'\n      if (options.order.field === '_creationTime') {\n        sql += ` ORDER BY _creationTime ${direction}`\n      } else {\n        sql += ` ORDER BY json_extract(data, '$.${options.order.field}') ${direction}`\n      }\n    } else {\n      sql += ` ORDER BY _creationTime ASC`\n    }\n\n    // Add LIMIT\n    if (options.limit) {\n      sql += ` LIMIT ${options.limit}`\n    }\n\n    const results = this.sql.exec(sql, ...params).toArray()\n\n    return results.map(row => ({\n      _id: row._id as string,\n      _creationTime: row._creationTime as number,\n      ...this.deserializeDocument(row.data as string),\n    }))\n  }\n\n  /**\n   * Translate filter operator to SQL\n   */\n  private translateOperator(op: QueryFilter['operator']): string {\n    switch (op) {\n      case 'eq': return '='\n      case 'neq': return '!='\n      case 'lt': return '<'\n      case 'lte': return '<='\n      case 'gt': return '>'\n      case 'gte': return '>='\n      default: throw new Error(`Unknown operator: ${op}`)\n    }\n  }\n\n  /**\n   * Run a transaction\n   */\n  async runTransaction<T>(fn: () => Promise<T>): Promise<T> {\n    await this.ensureInitialized()\n\n    this.sql.exec('BEGIN TRANSACTION')\n    try {\n      const result = await fn()\n      this.sql.exec('COMMIT')\n      return result\n    } catch (error) {\n      this.sql.exec('ROLLBACK')\n      throw error\n    }\n  }\n\n  // ============================================================================\n  // Type Conversion Methods\n  // ============================================================================\n\n  /**\n   * Convert a JavaScript value to SQLite-compatible format\n   */\n  toSQLiteValue(value: unknown, fieldConfig: { type: string; optional: boolean }): unknown {\n    if (value === undefined || value === null) {\n      if (!fieldConfig.optional) {\n        throw new Error('Cannot set undefined/null for required field')\n      }\n      return null\n    }\n\n    // Convert based on type\n    if (fieldConfig.type === 'boolean') {\n      return value ? 1 : 0\n    }\n    if (fieldConfig.type === 'object' || fieldConfig.type === 'array') {\n      return JSON.stringify(value)\n    }\n    return value\n  }\n\n  /**\n   * Convert a SQLite value back to JavaScript format\n   */\n  fromSQLiteValue(value: unknown, fieldConfig: { type: string; optional: boolean }): unknown {\n    if (value === null) {\n      return fieldConfig.optional ? undefined : null\n    }\n\n    // Convert based on type\n    if (fieldConfig.type === 'boolean') {\n      return value === 1\n    }\n    if (fieldConfig.type === 'object' || fieldConfig.type === 'array') {\n      return typeof value === 'string' ? JSON.parse(value) : value\n    }\n    return value\n  }\n\n  // ============================================================================\n  // Type Mapping Methods\n  // ============================================================================\n\n  /**\n   * Convert a Convex field type to SQLite column type\n   */\n  convexTypeToSQLite(fieldDef: FieldDefinition): string {\n    const { type, optional } = fieldDef\n    const nullSuffix = optional ? '' : ' NOT NULL'\n\n    switch (type) {\n      case 'string':\n        return `TEXT${nullSuffix}`\n      case 'number':\n      case 'float64':\n        return `REAL${nullSuffix}`\n      case 'boolean':\n        return `INTEGER${nullSuffix}`\n      case 'int64':\n        return `INTEGER${nullSuffix}`\n      case 'bytes':\n        return `BLOB${nullSuffix}`\n      case 'id':\n        return `TEXT${nullSuffix}`\n      case 'array':\n      case 'object':\n      case 'union':\n        return `TEXT${nullSuffix}`  // JSON stored as TEXT\n      case 'null':\n        return 'TEXT DEFAULT NULL'\n      case 'literal':\n        // Determine type from literal value\n        if (typeof fieldDef.value === 'string') return `TEXT${nullSuffix}`\n        if (typeof fieldDef.value === 'number') return `REAL${nullSuffix}`\n        if (typeof fieldDef.value === 'boolean') return `INTEGER${nullSuffix}`\n        return `TEXT${nullSuffix}`\n      default:\n        throw new Error(`Unsupported type: ${type}`)\n    }\n  }\n\n  // ============================================================================\n  // Schema Management Methods\n  // ============================================================================\n\n  /**\n   * Validate table name\n   */\n  private validateTableName(name: string): void {\n    if (!name || name.trim() === '') {\n      throw new Error('Invalid table name: name cannot be empty')\n    }\n    if (RESERVED_TABLES.has(name)) {\n      throw new Error(`Reserved table name: ${name}`)\n    }\n    // Check for SQL injection attempts\n    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {\n      throw new Error(`Invalid table name: ${name}`)\n    }\n  }\n\n  /**\n   * Validate field name\n   */\n  private validateFieldName(name: string): void {\n    if (name.startsWith('_')) {\n      throw new Error(`Invalid field name: ${name} (underscore prefix reserved for system fields)`)\n    }\n  }\n\n  /**\n   * Generate CREATE TABLE SQL from schema\n   */\n  generateCreateTableSQL(schema: TableSchema): string {\n    this.validateTableName(schema.name)\n\n    const columns: string[] = [\n      '\"_id\" TEXT PRIMARY KEY',\n      '\"_creationTime\" INTEGER NOT NULL',\n    ]\n\n    for (const [fieldName, fieldDef] of Object.entries(schema.fields)) {\n      this.validateFieldName(fieldName)\n\n      // Validate ID fields have table reference\n      if (fieldDef.type === 'id' && !fieldDef.table) {\n        throw new Error(`ID field \"${fieldName}\" missing table reference`)\n      }\n\n      const sqlType = this.convexTypeToSQLite(fieldDef)\n      columns.push(`\"${fieldName}\" ${sqlType}`)\n\n      // Add CHECK constraint for ID fields\n      if (fieldDef.type === 'id') {\n        columns.push(`CHECK(typeof(\"${fieldName}\") = 'text' OR \"${fieldName}\" IS NULL)`)\n      }\n    }\n\n    return `CREATE TABLE \"${schema.name}\" (${columns.join(', ')})`\n  }\n\n  /**\n   * Generate CREATE INDEX SQL\n   */\n  generateCreateIndexSQL(tableName: string, indexDef: IndexDefinition): string {\n    const uniqueKeyword = indexDef.unique ? 'UNIQUE ' : ''\n    const indexName = `${tableName}_${indexDef.name}`\n    const fields = indexDef.fields.map(f => `\"${f}\"`).join(', ')\n\n    return `CREATE ${uniqueKeyword}INDEX \"${indexName}\" ON \"${tableName}\" (${fields})`\n  }\n\n  /**\n   * Create a table from schema definition\n   */\n  async createTable(schema: TableSchema): Promise<void> {\n    await this.ensureInitialized()\n\n    // Validate table name\n    this.validateTableName(schema.name)\n\n    // Validate all field names\n    for (const fieldName of Object.keys(schema.fields)) {\n      this.validateFieldName(fieldName)\n    }\n\n    // Validate ID fields have table reference\n    for (const [fieldName, fieldDef] of Object.entries(schema.fields)) {\n      if (fieldDef.type === 'id' && !fieldDef.table) {\n        throw new Error(`ID field \"${fieldName}\" missing table reference`)\n      }\n    }\n\n    // Validate indexes reference existing fields\n    for (const index of schema.indexes) {\n      for (const field of index.fields) {\n        if (!schema.fields[field] && field !== '_id' && field !== '_creationTime') {\n          throw new Error(`Index \"${index.name}\" references field \"${field}\" which does not exist`)\n        }\n      }\n    }\n\n    // Generate and execute CREATE TABLE\n    const createTableSQL = this.generateCreateTableSQL(schema)\n    this.sql.exec(createTableSQL)\n\n    // Create indexes\n    for (const index of schema.indexes) {\n      const createIndexSQL = this.generateCreateIndexSQL(schema.name, index)\n      this.sql.exec(createIndexSQL)\n    }\n\n    this.tables.add(schema.name)\n\n    // Update metadata\n    this.sql.exec(\n      `INSERT OR REPLACE INTO _metadata (key, value) VALUES ('tables', ?)`,\n      JSON.stringify([...this.tables])\n    )\n  }\n\n  /**\n   * Get current schema version\n   */\n  async getCurrentSchemaVersion(): Promise<number> {\n    await this.ensureInitialized()\n\n    const result = this.sql.exec(\n      'SELECT MAX(version) as version FROM _schema_versions'\n    ).toArray()\n\n    const firstRow = result[0]\n    if (result.length === 0 || firstRow === undefined || firstRow.version === null) {\n      return 0\n    }\n\n    return firstRow.version as number\n  }\n\n  /**\n   * Compute a hash for a schema definition\n   */\n  private computeSchemaHash(schema: SchemaDefinition): string {\n    const str = JSON.stringify(schema)\n    // Simple hash function\n    let hash = 0\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i)\n      hash = ((hash << 5) - hash) + char\n      hash = hash & hash\n    }\n    return hash.toString(16)\n  }\n\n  /**\n   * Apply a migration plan\n   */\n  async applyMigration(migration: MigrationPlan): Promise<void> {\n    await this.ensureInitialized()\n\n    // Check current version\n    const currentVersion = await this.getCurrentSchemaVersion()\n\n    if (migration.fromVersion !== currentVersion) {\n      throw new Error(`Version conflict: expected version ${migration.fromVersion}, current version is ${currentVersion}`)\n    }\n\n    // Check schema hash if provided\n    if (migration.expectedSchemaHash) {\n      const result = this.sql.exec(\n        'SELECT schema_hash FROM _schema_versions WHERE version = ?',\n        migration.fromVersion\n      ).toArray()\n\n      if (result.length > 0 && result[0]?.schema_hash !== migration.expectedSchemaHash) {\n        throw new Error(`Schema hash mismatch: expected ${migration.expectedSchemaHash}`)\n      }\n    }\n\n    // Begin transaction\n    this.sql.exec('BEGIN TRANSACTION')\n\n    try {\n      // Apply each operation\n      for (const op of migration.operations) {\n        switch (op.type) {\n          case 'addColumn':\n            const colType = op.definition ? this.convexTypeToSQLite(op.definition) : 'TEXT'\n            this.sql.exec(`ALTER TABLE \"${op.table}\" ADD COLUMN \"${op.column}\" ${colType}`)\n            break\n          case 'dropColumn':\n            this.sql.exec(`ALTER TABLE \"${op.table}\" DROP COLUMN \"${op.column}\"`)\n            break\n          case 'createTable':\n            // Would need full table schema here\n            break\n          case 'dropTable':\n            this.sql.exec(`DROP TABLE IF EXISTS \"${op.table}\"`)\n            break\n          case 'createIndex':\n            if (op.index) {\n              const indexSQL = this.generateCreateIndexSQL(op.table, op.index)\n              this.sql.exec(indexSQL)\n            }\n            break\n          case 'dropIndex':\n            if (op.index) {\n              this.sql.exec(`DROP INDEX IF EXISTS \"${op.table}_${op.index.name}\"`)\n            }\n            break\n        }\n      }\n\n      // Record the new version\n      this.sql.exec(\n        'INSERT INTO _schema_versions (version, applied_at, schema_hash) VALUES (?, ?, ?)',\n        migration.toVersion,\n        Date.now(),\n        'migrated'\n      )\n\n      this.sql.exec('COMMIT')\n    } catch (error) {\n      this.sql.exec('ROLLBACK')\n      throw error\n    }\n  }\n\n  /**\n   * Apply a full schema definition\n   */\n  async applySchema(schema: SchemaDefinition): Promise<void> {\n    await this.ensureInitialized()\n\n    const schemaHash = this.computeSchemaHash(schema)\n    const currentVersion = await this.getCurrentSchemaVersion()\n    const newVersion = currentVersion + 1\n\n    // Create all tables\n    for (const tableSchema of Object.values(schema.tables)) {\n      await this.createTable(tableSchema)\n    }\n\n    // Record version\n    this.sql.exec(\n      'INSERT INTO _schema_versions (version, applied_at, schema_hash) VALUES (?, ?, ?)',\n      newVersion,\n      Date.now(),\n      schemaHash\n    )\n  }\n\n  // ============================================================================\n  // System Table Methods\n  // ============================================================================\n\n  /**\n   * List all document IDs in a table\n   */\n  async listDocumentIds(tableName: string): Promise<string[]> {\n    await this.ensureInitialized()\n\n    const result = this.sql.exec(\n      'SELECT _id FROM _documents WHERE _table = ?',\n      tableName\n    ).toArray()\n\n    return result.map(row => row._id as string)\n  }\n\n  /**\n   * Get document count for a table\n   */\n  async getDocumentCount(tableName: string): Promise<number> {\n    await this.ensureInitialized()\n\n    const result = this.sql.exec(\n      'SELECT COUNT(*) as count FROM _documents WHERE _table = ?',\n      tableName\n    ).toArray()\n\n    return (result[0]?.count as number) ?? 0\n  }\n\n  /**\n   * Handle HTTP requests to this Durable Object\n   */\n  async fetch(request: Request): Promise<Response> {\n    new URL(request.url)  // validate URL\n\n    try {\n      await this.ensureInitialized()\n\n      if (request.method === 'POST') {\n        const body = await request.json() as {\n          operation: string\n          table?: string\n          id?: string\n          doc?: Record<string, unknown>\n          fields?: Record<string, unknown>\n          filters?: QueryFilter[]\n          options?: QueryOptions\n        }\n\n        switch (body.operation) {\n          case 'insert':\n            const insertId = await this.insert(body.table!, body.doc!)\n            return Response.json({ id: insertId })\n\n          case 'get':\n            const doc = await this.get(body.table!, body.id!)\n            return Response.json({ document: doc })\n\n          case 'patch':\n            await this.patch(body.table!, body.id!, body.fields!)\n            return Response.json({ success: true })\n\n          case 'replace':\n            await this.replace(body.table!, body.id!, body.doc!)\n            return Response.json({ success: true })\n\n          case 'delete':\n            await this.delete(body.table!, body.id!)\n            return Response.json({ success: true })\n\n          case 'query':\n            const results = await this.query(body.table!, body.filters, body.options)\n            return Response.json({ documents: results })\n\n          default:\n            return Response.json({ error: 'Unknown operation' }, { status: 400 })\n        }\n      }\n\n      return Response.json({ error: 'Method not allowed' }, { status: 405 })\n    } catch (error) {\n      return Response.json(\n        { error: (error as Error).message },\n        { status: 500 }\n      )\n    }\n  }\n}\n","/**\n * ConvexSubscription Durable Object\n *\n * Manages real-time subscriptions and WebSocket connections.\n * Handles subscription tracking and change notifications.\n */\n\nimport type { Env } from '../env'\n\ninterface Subscription {\n  clientId: string\n  queryPath: string\n  args: unknown\n  lastResult: unknown\n  lastTimestamp: number\n}\n\ninterface WebSocketMessage {\n  type: 'subscribe' | 'unsubscribe' | 'authenticate' | 'ping'\n  subscriptionId?: string\n  queryPath?: string\n  args?: unknown\n  token?: string\n}\n\nexport class ConvexSubscription implements DurableObject {\n  private state: DurableObjectState\n  protected env: Env\n  private subscriptions: Map<string, Subscription> = new Map()\n  private clientSubscriptions: Map<string, Set<string>> = new Map()\n  private authenticatedClients: Map<string, string> = new Map() // clientId -> token\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.state = state\n    this.env = env\n\n    // Restore subscriptions from storage on startup\n    this.state.blockConcurrencyWhile(async () => {\n      const stored = await this.state.storage.get<Map<string, Subscription>>('subscriptions')\n      if (stored) {\n        this.subscriptions = stored\n        // Rebuild client subscriptions index\n        for (const [subId, sub] of this.subscriptions) {\n          if (!this.clientSubscriptions.has(sub.clientId)) {\n            this.clientSubscriptions.set(sub.clientId, new Set())\n          }\n          this.clientSubscriptions.get(sub.clientId)!.add(subId)\n        }\n      }\n    })\n  }\n\n  /**\n   * Generate a subscription ID\n   */\n  private generateSubscriptionId(clientId: string, queryPath: string, args: unknown): string {\n    const argsHash = this.hashArgs(args)\n    return `${clientId}:${queryPath}:${argsHash}`\n  }\n\n  /**\n   * Hash args for subscription deduplication\n   */\n  private hashArgs(args: unknown): string {\n    const str = JSON.stringify(args)\n    let hash = 0\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i)\n      hash = ((hash << 5) - hash) + char\n      hash = hash & hash // Convert to 32bit integer\n    }\n    return hash.toString(36)\n  }\n\n  /**\n   * Subscribe to a query\n   */\n  async subscribe(\n    clientId: string,\n    queryPath: string,\n    args: unknown\n  ): Promise<string> {\n    const subscriptionId = this.generateSubscriptionId(clientId, queryPath, args)\n\n    const subscription: Subscription = {\n      clientId,\n      queryPath,\n      args,\n      lastResult: null,\n      lastTimestamp: 0,\n    }\n\n    this.subscriptions.set(subscriptionId, subscription)\n\n    // Track by client\n    if (!this.clientSubscriptions.has(clientId)) {\n      this.clientSubscriptions.set(clientId, new Set())\n    }\n    this.clientSubscriptions.get(clientId)!.add(subscriptionId)\n\n    // Persist\n    await this.state.storage.put('subscriptions', this.subscriptions)\n\n    return subscriptionId\n  }\n\n  /**\n   * Unsubscribe from a query\n   */\n  async unsubscribe(subscriptionId: string): Promise<void> {\n    const subscription = this.subscriptions.get(subscriptionId)\n    if (!subscription) return\n\n    this.subscriptions.delete(subscriptionId)\n\n    // Remove from client index\n    const clientSubs = this.clientSubscriptions.get(subscription.clientId)\n    if (clientSubs) {\n      clientSubs.delete(subscriptionId)\n      if (clientSubs.size === 0) {\n        this.clientSubscriptions.delete(subscription.clientId)\n      }\n    }\n\n    // Persist\n    await this.state.storage.put('subscriptions', this.subscriptions)\n  }\n\n  /**\n   * Unsubscribe all subscriptions for a client\n   */\n  async unsubscribeClient(clientId: string): Promise<void> {\n    const clientSubs = this.clientSubscriptions.get(clientId)\n    if (!clientSubs) return\n\n    for (const subId of clientSubs) {\n      this.subscriptions.delete(subId)\n    }\n\n    this.clientSubscriptions.delete(clientId)\n\n    // Persist\n    await this.state.storage.put('subscriptions', this.subscriptions)\n  }\n\n  /**\n   * Update the result of a subscription (after query re-execution)\n   */\n  async updateSubscriptionResult(\n    subscriptionId: string,\n    result: unknown\n  ): Promise<boolean> {\n    const subscription = this.subscriptions.get(subscriptionId)\n    if (!subscription) return false\n\n    const resultStr = JSON.stringify(result)\n    const lastResultStr = JSON.stringify(subscription.lastResult)\n\n    // Check if result changed\n    if (resultStr !== lastResultStr) {\n      subscription.lastResult = result\n      subscription.lastTimestamp = Date.now()\n      await this.state.storage.put('subscriptions', this.subscriptions)\n      return true // Changed\n    }\n\n    return false // No change\n  }\n\n  /**\n   * Get subscriptions that might be affected by a table change\n   */\n  getAffectedSubscriptions(tableName: string): Subscription[] {\n    const affected: Subscription[] = []\n\n    for (const subscription of this.subscriptions.values()) {\n      // Simple heuristic: check if query path references the table\n      // In a full implementation, we'd parse the query to determine affected tables\n      if (this.queryMightTouchTable(subscription.queryPath, tableName)) {\n        affected.push(subscription)\n      }\n    }\n\n    return affected\n  }\n\n  /**\n   * Check if a query might touch a specific table\n   */\n  private queryMightTouchTable(queryPath: string, tableName: string): boolean {\n    // Simple heuristic: query path like \"messages:list\" touches \"messages\" table\n    // In practice, we'd need more sophisticated analysis\n    const parts = queryPath.split(':')\n    return parts[0] === tableName || queryPath.includes(tableName)\n  }\n\n  /**\n   * Handle WebSocket connections\n   */\n  async fetch(request: Request): Promise<Response> {\n    new URL(request.url)  // validate URL\n\n    // WebSocket upgrade\n    if (request.headers.get('Upgrade') === 'websocket') {\n      const pair = new WebSocketPair()\n      const [client, server] = [pair[0], pair[1]]\n\n      // Accept the WebSocket\n      this.state.acceptWebSocket(server)\n\n      return new Response(null, {\n        status: 101,\n        webSocket: client,\n      })\n    }\n\n    // HTTP API for subscription management\n    if (request.method === 'POST') {\n      const body = await request.json() as {\n        operation: string\n        clientId?: string\n        subscriptionId?: string\n        queryPath?: string\n        args?: unknown\n        result?: unknown\n        tableName?: string\n      }\n\n      switch (body.operation) {\n        case 'subscribe':\n          const subId = await this.subscribe(\n            body.clientId!,\n            body.queryPath!,\n            body.args\n          )\n          return Response.json({ subscriptionId: subId })\n\n        case 'unsubscribe':\n          await this.unsubscribe(body.subscriptionId!)\n          return Response.json({ success: true })\n\n        case 'unsubscribeClient':\n          await this.unsubscribeClient(body.clientId!)\n          return Response.json({ success: true })\n\n        case 'updateResult':\n          const changed = await this.updateSubscriptionResult(\n            body.subscriptionId!,\n            body.result\n          )\n          return Response.json({ changed })\n\n        case 'getAffected':\n          const affected = this.getAffectedSubscriptions(body.tableName!)\n          return Response.json({ subscriptions: affected })\n\n        default:\n          return Response.json({ error: 'Unknown operation' }, { status: 400 })\n      }\n    }\n\n    return Response.json({ error: 'Method not allowed' }, { status: 405 })\n  }\n\n  /**\n   * Handle incoming WebSocket messages\n   */\n  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): Promise<void> {\n    if (typeof message !== 'string') {\n      ws.send(JSON.stringify({ error: 'Binary messages not supported' }))\n      return\n    }\n\n    try {\n      const msg = JSON.parse(message) as WebSocketMessage\n\n      switch (msg.type) {\n        case 'subscribe':\n          const subId = await this.subscribe(\n            this.getClientId(ws),\n            msg.queryPath!,\n            msg.args\n          )\n          ws.send(JSON.stringify({\n            type: 'subscribed',\n            subscriptionId: subId,\n          }))\n          break\n\n        case 'unsubscribe':\n          await this.unsubscribe(msg.subscriptionId!)\n          ws.send(JSON.stringify({\n            type: 'unsubscribed',\n            subscriptionId: msg.subscriptionId,\n          }))\n          break\n\n        case 'authenticate':\n          this.authenticatedClients.set(this.getClientId(ws), msg.token!)\n          ws.send(JSON.stringify({ type: 'authenticated' }))\n          break\n\n        case 'ping':\n          ws.send(JSON.stringify({ type: 'pong' }))\n          break\n\n        default:\n          ws.send(JSON.stringify({ error: `Unknown message type: ${msg.type}` }))\n      }\n    } catch (error) {\n      ws.send(JSON.stringify({ error: (error as Error).message }))\n    }\n  }\n\n  /**\n   * Handle WebSocket close\n   */\n  async webSocketClose(ws: WebSocket, _code: number, _reason: string): Promise<void> {\n    const clientId = this.getClientId(ws)\n    await this.unsubscribeClient(clientId)\n    this.authenticatedClients.delete(clientId)\n  }\n\n  /**\n   * Get client ID for a WebSocket\n   */\n  private getClientId(ws: WebSocket): string {\n    // Use WebSocket's attachment to store client ID\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const state = this.state as any\n    const attachment = state.getWebSocketAttachment?.(ws) as { clientId?: string } | undefined\n    if (attachment?.clientId) {\n      return attachment.clientId\n    }\n\n    // Generate new client ID\n    const clientId = crypto.randomUUID()\n    state.setWebSocketAttachment?.(ws, { clientId })\n    return clientId\n  }\n\n  /**\n   * Broadcast update to subscribed clients\n   */\n  async broadcastUpdate(subscriptionId: string, data: unknown): Promise<void> {\n    const subscription = this.subscriptions.get(subscriptionId)\n    if (!subscription) return\n\n    const message = JSON.stringify({\n      type: 'update',\n      subscriptionId,\n      data,\n    })\n\n    // Send to all WebSockets for this client\n    for (const ws of this.state.getWebSockets()) {\n      const clientId = this.getClientId(ws)\n      if (clientId === subscription.clientId) {\n        try {\n          ws.send(message)\n        } catch {\n          // WebSocket might be closed\n        }\n      }\n    }\n  }\n}\n","/**\n * ConvexScheduler Durable Object\n *\n * Handles scheduled function execution using Durable Object alarms.\n */\n\nimport type { Env } from '../env'\n\ninterface ScheduledFunction {\n  id: string\n  functionPath: string\n  args: unknown\n  runAt: number\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'canceled'\n  createdAt: number\n  completedAt?: number\n  error?: string\n  retries: number\n  maxRetries: number\n}\n\nexport class ConvexScheduler implements DurableObject {\n  private state: DurableObjectState\n  protected env: Env\n  private sql: SqlStorage\n  private initialized = false\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.state = state\n    this.env = env\n    this.sql = state.storage.sql\n  }\n\n  /**\n   * Initialize the scheduler tables\n   */\n  private async ensureInitialized(): Promise<void> {\n    if (this.initialized) return\n\n    await this.state.blockConcurrencyWhile(async () => {\n      if (this.initialized) return\n\n      this.sql.exec(`\n        CREATE TABLE IF NOT EXISTS scheduled_functions (\n          id TEXT PRIMARY KEY,\n          function_path TEXT NOT NULL,\n          args TEXT NOT NULL,\n          run_at INTEGER NOT NULL,\n          status TEXT NOT NULL DEFAULT 'pending',\n          created_at INTEGER NOT NULL,\n          completed_at INTEGER,\n          error TEXT,\n          retries INTEGER DEFAULT 0,\n          max_retries INTEGER DEFAULT 3\n        )\n      `)\n\n      this.sql.exec(`\n        CREATE INDEX IF NOT EXISTS idx_scheduled_run_at\n        ON scheduled_functions (run_at)\n        WHERE status = 'pending'\n      `)\n\n      this.initialized = true\n    })\n  }\n\n  /**\n   * Generate a unique scheduled function ID\n   */\n  private generateId(): string {\n    const bytes = new Uint8Array(16)\n    crypto.getRandomValues(bytes)\n    return btoa(String.fromCharCode(...bytes))\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=/g, '')\n  }\n\n  /**\n   * Schedule a function to run after a delay\n   */\n  async runAfter(\n    delayMs: number,\n    functionPath: string,\n    args: unknown\n  ): Promise<string> {\n    await this.ensureInitialized()\n\n    const id = this.generateId()\n    const runAt = Date.now() + delayMs\n    const createdAt = Date.now()\n\n    this.sql.exec(\n      `INSERT INTO scheduled_functions (id, function_path, args, run_at, status, created_at)\n       VALUES (?, ?, ?, ?, 'pending', ?)`,\n      id,\n      functionPath,\n      JSON.stringify(args),\n      runAt,\n      createdAt\n    )\n\n    // Set alarm for execution\n    await this.scheduleNextAlarm()\n\n    return id\n  }\n\n  /**\n   * Schedule a function to run at a specific time\n   */\n  async runAt(\n    timestamp: number,\n    functionPath: string,\n    args: unknown\n  ): Promise<string> {\n    const delayMs = Math.max(0, timestamp - Date.now())\n    return this.runAfter(delayMs, functionPath, args)\n  }\n\n  /**\n   * Cancel a scheduled function\n   */\n  async cancel(scheduledId: string): Promise<boolean> {\n    await this.ensureInitialized()\n\n    const result = this.sql.exec(\n      `UPDATE scheduled_functions\n       SET status = 'canceled', completed_at = ?\n       WHERE id = ? AND status = 'pending'`,\n      Date.now(),\n      scheduledId\n    )\n\n    return result.rowsWritten > 0\n  }\n\n  /**\n   * Get a scheduled function by ID\n   */\n  async get(scheduledId: string): Promise<ScheduledFunction | null> {\n    await this.ensureInitialized()\n\n    const results = this.sql.exec(\n      `SELECT * FROM scheduled_functions WHERE id = ?`,\n      scheduledId\n    ).toArray()\n\n    if (results.length === 0 || !results[0]) {\n      return null\n    }\n\n    const row = results[0]\n    return {\n      id: row.id as string,\n      functionPath: row.function_path as string,\n      args: JSON.parse(row.args as string) as unknown,\n      runAt: row.run_at as number,\n      status: row.status as ScheduledFunction['status'],\n      createdAt: row.created_at as number,\n      ...(row.completed_at !== null && { completedAt: row.completed_at as number }),\n      ...(row.error !== null && { error: row.error as string }),\n      retries: row.retries as number,\n      maxRetries: row.max_retries as number,\n    }\n  }\n\n  /**\n   * List scheduled functions\n   */\n  async list(\n    status?: ScheduledFunction['status'],\n    limit = 100\n  ): Promise<ScheduledFunction[]> {\n    await this.ensureInitialized()\n\n    let sql = `SELECT * FROM scheduled_functions`\n    const params: unknown[] = []\n\n    if (status) {\n      sql += ` WHERE status = ?`\n      params.push(status)\n    }\n\n    sql += ` ORDER BY run_at ASC LIMIT ?`\n    params.push(limit)\n\n    const results = this.sql.exec(sql, ...params).toArray()\n\n    return results.map(row => ({\n      id: row.id as string,\n      functionPath: row.function_path as string,\n      args: JSON.parse(row.args as string) as unknown,\n      runAt: row.run_at as number,\n      status: row.status as ScheduledFunction['status'],\n      createdAt: row.created_at as number,\n      ...(row.completed_at !== null && { completedAt: row.completed_at as number }),\n      ...(row.error !== null && { error: row.error as string }),\n      retries: row.retries as number,\n      maxRetries: row.max_retries as number,\n    }))\n  }\n\n  /**\n   * Schedule the next alarm for pending functions\n   */\n  private async scheduleNextAlarm(): Promise<void> {\n    const results = this.sql.exec(\n      `SELECT MIN(run_at) as next_run FROM scheduled_functions WHERE status = 'pending'`\n    ).toArray()\n\n    if (results.length > 0 && results[0]?.next_run) {\n      const nextRun = results[0].next_run as number\n      await this.state.storage.setAlarm(nextRun)\n    }\n  }\n\n  /**\n   * Handle alarm - execute due scheduled functions\n   */\n  async alarm(): Promise<void> {\n    await this.ensureInitialized()\n\n    const now = Date.now()\n\n    // Get all pending functions that are due\n    const due = this.sql.exec(\n      `SELECT * FROM scheduled_functions\n       WHERE status = 'pending' AND run_at <= ?\n       ORDER BY run_at ASC`,\n      now\n    ).toArray()\n\n    for (const row of due) {\n      const func: ScheduledFunction = {\n        id: row.id as string,\n        functionPath: row.function_path as string,\n        args: JSON.parse(row.args as string) as unknown,\n        runAt: row.run_at as number,\n        status: 'running',\n        createdAt: row.created_at as number,\n        retries: row.retries as number,\n        maxRetries: row.max_retries as number,\n      }\n\n      // Mark as running\n      this.sql.exec(\n        `UPDATE scheduled_functions SET status = 'running' WHERE id = ?`,\n        func.id\n      )\n\n      try {\n        // Execute the function\n        await this.executeFunction(func)\n\n        // Mark as completed\n        this.sql.exec(\n          `UPDATE scheduled_functions SET status = 'completed', completed_at = ? WHERE id = ?`,\n          Date.now(),\n          func.id\n        )\n      } catch (error) {\n        const errorMessage = (error as Error).message\n\n        if (func.retries < func.maxRetries) {\n          // Retry with exponential backoff\n          const backoffMs = Math.pow(2, func.retries) * 1000\n          const newRunAt = Date.now() + backoffMs\n\n          this.sql.exec(\n            `UPDATE scheduled_functions\n             SET status = 'pending', run_at = ?, retries = retries + 1, error = ?\n             WHERE id = ?`,\n            newRunAt,\n            errorMessage,\n            func.id\n          )\n        } else {\n          // Mark as failed\n          this.sql.exec(\n            `UPDATE scheduled_functions\n             SET status = 'failed', completed_at = ?, error = ?\n             WHERE id = ?`,\n            Date.now(),\n            errorMessage,\n            func.id\n          )\n        }\n      }\n    }\n\n    // Schedule next alarm\n    await this.scheduleNextAlarm()\n  }\n\n  /**\n   * Execute a scheduled function\n   */\n  private async executeFunction(func: ScheduledFunction): Promise<void> {\n    // TODO: Actually execute the function via the database/runtime\n    // For now, this is a stub that would call the function executor\n    console.log(`Executing scheduled function: ${func.functionPath}`, func.args)\n\n    // In the real implementation, we would:\n    // 1. Look up the function definition\n    // 2. Create the appropriate context\n    // 3. Execute the function\n    // 4. Handle the result\n  }\n\n  /**\n   * Handle HTTP requests\n   */\n  async fetch(request: Request): Promise<Response> {\n    try {\n      await this.ensureInitialized()\n\n      if (request.method === 'POST') {\n        const body = await request.json() as {\n          operation: string\n          functionPath?: string\n          args?: unknown\n          delayMs?: number\n          timestamp?: number\n          scheduledId?: string\n          status?: ScheduledFunction['status']\n          limit?: number\n        }\n\n        switch (body.operation) {\n          case 'runAfter':\n            const afterId = await this.runAfter(\n              body.delayMs!,\n              body.functionPath!,\n              body.args\n            )\n            return Response.json({ scheduledId: afterId })\n\n          case 'runAt':\n            const atId = await this.runAt(\n              body.timestamp!,\n              body.functionPath!,\n              body.args\n            )\n            return Response.json({ scheduledId: atId })\n\n          case 'cancel':\n            const canceled = await this.cancel(body.scheduledId!)\n            return Response.json({ canceled })\n\n          case 'get':\n            const func = await this.get(body.scheduledId!)\n            return Response.json({ scheduledFunction: func })\n\n          case 'list':\n            const functions = await this.list(body.status, body.limit)\n            return Response.json({ scheduledFunctions: functions })\n\n          default:\n            return Response.json({ error: 'Unknown operation' }, { status: 400 })\n        }\n      }\n\n      return Response.json({ error: 'Method not allowed' }, { status: 405 })\n    } catch (error) {\n      return Response.json(\n        { error: (error as Error).message },\n        { status: 500 }\n      )\n    }\n  }\n}\n","/**\n * ConvexStorage Durable Object\n *\n * Handles file storage using R2 as the backend.\n */\n\nimport type { Env } from '../env'\n\ninterface StoredFile {\n  storageId: string\n  sha256: string\n  size: number\n  contentType: string | null\n  uploadedAt: number\n  metadata: Record<string, string>\n}\n\ninterface UploadUrl {\n  uploadUrl: string\n  storageId: string\n  expiresAt: number\n}\n\nexport class ConvexStorage implements DurableObject {\n  private state: DurableObjectState\n  private env: Env\n  private files: Map<string, StoredFile> = new Map()\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.state = state\n    this.env = env\n\n    // Load file metadata from storage\n    this.state.blockConcurrencyWhile(async () => {\n      const stored = await this.state.storage.get<Map<string, StoredFile>>('files')\n      if (stored) {\n        this.files = stored\n      }\n    })\n  }\n\n  /**\n   * Generate a storage ID\n   */\n  private generateStorageId(): string {\n    const bytes = new Uint8Array(16)\n    crypto.getRandomValues(bytes)\n    return 'kg' + btoa(String.fromCharCode(...bytes))\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=/g, '')\n  }\n\n  /**\n   * Generate an upload URL for direct client upload\n   */\n  async generateUploadUrl(): Promise<UploadUrl> {\n    const storageId = this.generateStorageId()\n    const expiresAt = Date.now() + 60 * 60 * 1000 // 1 hour\n\n    // Store pending upload info\n    await this.state.storage.put(`pending:${storageId}`, {\n      storageId,\n      expiresAt,\n    })\n\n    // The upload URL would be to this worker\n    const uploadUrl = `/storage/upload/${storageId}`\n\n    return {\n      uploadUrl,\n      storageId,\n      expiresAt,\n    }\n  }\n\n  /**\n   * Store a file\n   */\n  async store(\n    storageId: string,\n    data: ArrayBuffer,\n    contentType: string | null,\n    metadata: Record<string, string> = {}\n  ): Promise<StoredFile> {\n    // Calculate SHA256\n    const hashBuffer = await crypto.subtle.digest('SHA-256', data)\n    const hashArray = new Uint8Array(hashBuffer)\n    const sha256 = Array.from(hashArray)\n      .map(b => b.toString(16).padStart(2, '0'))\n      .join('')\n\n    // Store in R2\n    await this.env.STORAGE_BUCKET.put(storageId, data, {\n      httpMetadata: {\n        contentType: contentType || 'application/octet-stream',\n      },\n      customMetadata: metadata,\n    })\n\n    const file: StoredFile = {\n      storageId,\n      sha256,\n      size: data.byteLength,\n      contentType,\n      uploadedAt: Date.now(),\n      metadata,\n    }\n\n    // Store metadata\n    this.files.set(storageId, file)\n    await this.state.storage.put('files', this.files)\n\n    // Clean up pending upload\n    await this.state.storage.delete(`pending:${storageId}`)\n\n    return file\n  }\n\n  /**\n   * Get file metadata\n   */\n  async getMetadata(storageId: string): Promise<StoredFile | null> {\n    return this.files.get(storageId) || null\n  }\n\n  /**\n   * Get a file URL for downloading\n   */\n  async getUrl(storageId: string): Promise<string | null> {\n    const file = this.files.get(storageId)\n    if (!file) return null\n\n    // Return a URL to fetch through this worker\n    return `/storage/download/${storageId}`\n  }\n\n  /**\n   * Get file data\n   */\n  async getData(storageId: string): Promise<ArrayBuffer | null> {\n    const object = await this.env.STORAGE_BUCKET.get(storageId)\n    if (!object) return null\n    return object.arrayBuffer()\n  }\n\n  /**\n   * Delete a file\n   */\n  async delete(storageId: string): Promise<boolean> {\n    const existed = this.files.has(storageId)\n\n    if (existed) {\n      // Delete from R2\n      await this.env.STORAGE_BUCKET.delete(storageId)\n\n      // Delete metadata\n      this.files.delete(storageId)\n      await this.state.storage.put('files', this.files)\n    }\n\n    return existed\n  }\n\n  /**\n   * List files with optional prefix\n   */\n  async list(\n    options: { limit?: number; cursor?: string } = {}\n  ): Promise<{ files: StoredFile[]; cursor?: string }> {\n    const limit = options.limit || 100\n    const files = Array.from(this.files.values())\n      .sort((a, b) => b.uploadedAt - a.uploadedAt)\n      .slice(0, limit)\n\n    return { files }\n  }\n\n  /**\n   * Handle HTTP requests\n   */\n  async fetch(request: Request): Promise<Response> {\n    const url = new URL(request.url)\n    const path = url.pathname\n\n    try {\n      // Handle upload\n      if (request.method === 'POST' && path.startsWith('/storage/upload/')) {\n        const storageId = path.replace('/storage/upload/', '')\n\n        // Verify pending upload exists\n        const pending = await this.state.storage.get(`pending:${storageId}`)\n        if (!pending) {\n          return Response.json(\n            { error: 'Invalid or expired upload URL' },\n            { status: 400 }\n          )\n        }\n\n        const data = await request.arrayBuffer()\n        const contentType = request.headers.get('Content-Type')\n\n        const file = await this.store(storageId, data, contentType)\n        return Response.json({ file })\n      }\n\n      // Handle download\n      if (request.method === 'GET' && path.startsWith('/storage/download/')) {\n        const storageId = path.replace('/storage/download/', '')\n\n        const file = this.files.get(storageId)\n        if (!file) {\n          return Response.json({ error: 'File not found' }, { status: 404 })\n        }\n\n        const data = await this.getData(storageId)\n        if (!data) {\n          return Response.json({ error: 'File data not found' }, { status: 404 })\n        }\n\n        return new Response(data, {\n          headers: {\n            'Content-Type': file.contentType || 'application/octet-stream',\n            'Content-Length': file.size.toString(),\n            'ETag': `\"${file.sha256}\"`,\n          },\n        })\n      }\n\n      // Handle API operations\n      if (request.method === 'POST') {\n        const body = await request.json() as {\n          operation: string\n          storageId?: string\n          limit?: number\n          cursor?: string\n        }\n\n        switch (body.operation) {\n          case 'generateUploadUrl':\n            const uploadUrl = await this.generateUploadUrl()\n            return Response.json(uploadUrl)\n\n          case 'getMetadata':\n            const metadata = await this.getMetadata(body.storageId!)\n            return Response.json({ file: metadata })\n\n          case 'getUrl':\n            const fileUrl = await this.getUrl(body.storageId!)\n            return Response.json({ url: fileUrl })\n\n          case 'delete':\n            const deleted = await this.delete(body.storageId!)\n            return Response.json({ deleted })\n\n          case 'list':\n            const result = await this.list({\n              ...(body.limit !== undefined && { limit: body.limit }),\n              ...(body.cursor !== undefined && { cursor: body.cursor }),\n            })\n            return Response.json(result)\n\n          default:\n            return Response.json({ error: 'Unknown operation' }, { status: 400 })\n        }\n      }\n\n      return Response.json({ error: 'Method not allowed' }, { status: 405 })\n    } catch (error) {\n      return Response.json(\n        { error: (error as Error).message },\n        { status: 500 }\n      )\n    }\n  }\n}\n","/**\n * convex.do - 100% Convex API Compatible Package on Cloudflare Workers\n *\n * Main entrypoint for the Cloudflare Worker\n */\n\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\n\n// Types\nexport type { Env } from './env'\n\n// Create Hono app\nconst app = new Hono<{ Bindings: Env }>()\n\n// CORS middleware\napp.use('/*', cors({\n  origin: '*',\n  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowHeaders: ['Content-Type', 'Authorization', 'Convex-Client'],\n}))\n\n// Health check\napp.get('/', (c) => {\n  return c.json({\n    name: 'convex.do',\n    version: '0.0.1',\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n  })\n})\n\n// Query endpoint\napp.post('/api/query', async (c) => {\n  const { path, args, format: _format } = await c.req.json<{\n    path: string\n    args: unknown\n    format?: 'json' | 'convex'\n  }>()\n\n  // TODO: Implement query execution\n  return c.json({\n    status: 'not_implemented',\n    path,\n    args,\n  })\n})\n\n// Mutation endpoint\napp.post('/api/mutation', async (c) => {\n  const { path, args, format: _format } = await c.req.json<{\n    path: string\n    args: unknown\n    format?: 'json' | 'convex'\n  }>()\n\n  // TODO: Implement mutation execution\n  return c.json({\n    status: 'not_implemented',\n    path,\n    args,\n  })\n})\n\n// Action endpoint\napp.post('/api/action', async (c) => {\n  const { path, args, format: _format } = await c.req.json<{\n    path: string\n    args: unknown\n    format?: 'json' | 'convex'\n  }>()\n\n  // TODO: Implement action execution\n  return c.json({\n    status: 'not_implemented',\n    path,\n    args,\n  })\n})\n\n// WebSocket sync endpoint\napp.get('/sync', async (c) => {\n  const upgradeHeader = c.req.header('Upgrade')\n  if (upgradeHeader !== 'websocket') {\n    return c.text('Expected WebSocket', 426)\n  }\n\n  // TODO: Implement WebSocket handling via Durable Object\n  return c.text('WebSocket not yet implemented', 501)\n})\n\n// Export the app\nexport default app\n\n// Durable Object exports (will be implemented)\nexport { ConvexDatabase } from './durable-objects/ConvexDatabase'\nexport { ConvexSubscription } from './durable-objects/ConvexSubscription'\nexport { ConvexScheduler } from './durable-objects/ConvexScheduler'\nexport { ConvexStorage } from './durable-objects/ConvexStorage'\n\n// Type for environment bindings\ninterface Env {\n  CONVEX_DATABASE: DurableObjectNamespace\n  CONVEX_SUBSCRIPTION: DurableObjectNamespace\n  CONVEX_SCHEDULER: DurableObjectNamespace\n  CONVEX_STORAGE: DurableObjectNamespace\n  STORAGE_BUCKET: R2Bucket\n  ENVIRONMENT: string\n}\n"]}