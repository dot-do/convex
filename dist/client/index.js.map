{"version":3,"sources":["../../src/client/ConvexClient.ts","../../src/client/ConvexHttpClient.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * ConvexClient - WebSocket-based reactive client\n *\n * Provides real-time subscriptions and optimistic updates.\n */\n\nimport type { FunctionReference } from '../types'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Options for creating a ConvexClient.\n */\nexport interface ClientOptions {\n  /** Custom fetch implementation */\n  fetch?: typeof fetch\n  /** Custom WebSocket implementation */\n  WebSocket?: typeof WebSocket\n  /** Whether to automatically reconnect on disconnect */\n  autoReconnect?: boolean\n  /** Reconnection delay in milliseconds */\n  reconnectDelay?: number\n  /** Maximum reconnection attempts */\n  maxReconnectAttempts?: number\n}\n\n/**\n * Options for subscribing to a query.\n */\nexport interface SubscriptionOptions {\n  /** Called when the subscription is first established */\n  onConnect?: () => void\n  /** Called when the subscription is lost */\n  onDisconnect?: () => void\n  /** Called when an error occurs */\n  onError?: (error: Error) => void\n}\n\n/**\n * Callback for subscription updates.\n */\nexport type SubscriptionCallback<T> = (result: T) => void\n\n/**\n * Handle for managing a subscription.\n */\nexport interface SubscriptionHandle {\n  /** Unsubscribe from the query */\n  unsubscribe: () => void\n}\n\n/**\n * Internal subscription state.\n */\ninterface SubscriptionState {\n  id: string\n  queryPath: string\n  args: unknown\n  callback: SubscriptionCallback<unknown>\n  options?: SubscriptionOptions\n  lastResult?: unknown\n}\n\n/**\n * WebSocket message types.\n */\ntype WSMessage =\n  | { type: 'subscribe'; subscriptionId: string; queryPath: string; args: unknown }\n  | { type: 'unsubscribe'; subscriptionId: string }\n  | { type: 'authenticate'; token: string }\n  | { type: 'ping' }\n  | { type: 'subscribed'; subscriptionId: string }\n  | { type: 'update'; subscriptionId: string; data: unknown }\n  | { type: 'error'; subscriptionId?: string; message: string }\n  | { type: 'pong' }\n  | { type: 'authenticated' }\n\n// ============================================================================\n// ConvexClient Implementation\n// ============================================================================\n\n/**\n * WebSocket-based client for convex.do with real-time subscriptions.\n *\n * @example\n * ```typescript\n * import { ConvexClient } from \"convex.do/client\";\n *\n * const client = new ConvexClient(\"https://your-worker.workers.dev\");\n *\n * // Subscribe to a query\n * const unsubscribe = client.onUpdate(api.messages.list, { channel }, (messages) => {\n *   console.log(\"Messages:\", messages);\n * });\n *\n * // Run a mutation\n * await client.mutation(api.messages.send, { channel, body: \"Hello!\" });\n *\n * // Clean up\n * unsubscribe();\n * client.close();\n * ```\n */\nexport class ConvexClient {\n  private url: string\n  private wsUrl: string\n  private options: Required<ClientOptions>\n  private ws: WebSocket | null = null\n  private subscriptions: Map<string, SubscriptionState> = new Map()\n  private pendingSubscriptions: Map<string, SubscriptionState> = new Map()\n  private authToken: string | null = null\n  private isConnected = false\n  private reconnectAttempts = 0\n  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null\n  private pingInterval: ReturnType<typeof setInterval> | null = null\n  private idCounter = 0\n\n  constructor(url: string, options: ClientOptions = {}) {\n    this.url = url.replace(/\\/$/, '')\n    this.wsUrl = this.url.replace(/^http/, 'ws') + '/sync'\n\n    this.options = {\n      fetch: options.fetch ?? globalThis.fetch.bind(globalThis),\n      WebSocket: options.WebSocket ?? globalThis.WebSocket,\n      autoReconnect: options.autoReconnect ?? true,\n      reconnectDelay: options.reconnectDelay ?? 1000,\n      maxReconnectAttempts: options.maxReconnectAttempts ?? 10,\n    }\n\n    this.connect()\n  }\n\n  /**\n   * Set the authentication token.\n   */\n  setAuth(token: string): void {\n    this.authToken = token\n    if (this.ws && this.isConnected) {\n      this.send({ type: 'authenticate', token })\n    }\n  }\n\n  /**\n   * Clear the authentication token.\n   */\n  clearAuth(): void {\n    this.authToken = null\n  }\n\n  /**\n   * Subscribe to a query with real-time updates.\n   */\n  onUpdate<T>(\n    query: FunctionReference<'query', unknown, T>,\n    args: unknown,\n    callback: SubscriptionCallback<T>,\n    options?: SubscriptionOptions\n  ): () => void {\n    const id = this.generateId()\n    const state: SubscriptionState = {\n      id,\n      queryPath: query._path,\n      args,\n      callback: callback as SubscriptionCallback<unknown>,\n      ...(options !== undefined && { options }),\n    }\n\n    if (this.isConnected) {\n      this.subscriptions.set(id, state)\n      this.send({\n        type: 'subscribe',\n        subscriptionId: id,\n        queryPath: query._path,\n        args,\n      })\n    } else {\n      this.pendingSubscriptions.set(id, state)\n    }\n\n    return () => this.unsubscribe(id)\n  }\n\n  /**\n   * Run a query (one-time, non-reactive).\n   */\n  async query<T>(\n    query: FunctionReference<'query', unknown, T>,\n    args: unknown\n  ): Promise<T> {\n    const response = await this.options.fetch(`${this.url}/api/query`, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: JSON.stringify({\n        path: query._path,\n        args,\n        format: 'json',\n      }),\n    })\n\n    if (!response.ok) {\n      const error = await response.json() as { error?: string }\n      throw new Error(error.error || 'Query failed')\n    }\n\n    return response.json() as Promise<T>\n  }\n\n  /**\n   * Run a mutation.\n   */\n  async mutation<T>(\n    mutation: FunctionReference<'mutation', unknown, T>,\n    args: unknown\n  ): Promise<T> {\n    const response = await this.options.fetch(`${this.url}/api/mutation`, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: JSON.stringify({\n        path: mutation._path,\n        args,\n        format: 'json',\n      }),\n    })\n\n    if (!response.ok) {\n      const error = await response.json() as { error?: string }\n      throw new Error(error.error || 'Mutation failed')\n    }\n\n    return response.json() as Promise<T>\n  }\n\n  /**\n   * Run an action.\n   */\n  async action<T>(\n    action: FunctionReference<'action', unknown, T>,\n    args: unknown\n  ): Promise<T> {\n    const response = await this.options.fetch(`${this.url}/api/action`, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: JSON.stringify({\n        path: action._path,\n        args,\n        format: 'json',\n      }),\n    })\n\n    if (!response.ok) {\n      const error = await response.json() as { error?: string }\n      throw new Error(error.error || 'Action failed')\n    }\n\n    return response.json() as Promise<T>\n  }\n\n  /**\n   * Close the client connection.\n   */\n  close(): void {\n    this.options.autoReconnect = false\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout)\n      this.reconnectTimeout = null\n    }\n\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval)\n      this.pingInterval = null\n    }\n\n    if (this.ws) {\n      this.ws.close()\n      this.ws = null\n    }\n\n    this.subscriptions.clear()\n    this.pendingSubscriptions.clear()\n    this.isConnected = false\n  }\n\n  // ============================================================================\n  // Private Methods\n  // ============================================================================\n\n  private connect(): void {\n    try {\n      this.ws = new this.options.WebSocket(this.wsUrl)\n\n      this.ws.addEventListener('open', () => {\n        this.isConnected = true\n        this.reconnectAttempts = 0\n\n        // Authenticate if we have a token\n        if (this.authToken) {\n          this.send({ type: 'authenticate', token: this.authToken })\n        }\n\n        // Resubscribe to all subscriptions\n        for (const state of this.subscriptions.values()) {\n          this.send({\n            type: 'subscribe',\n            subscriptionId: state.id,\n            queryPath: state.queryPath,\n            args: state.args,\n          })\n          state.options?.onConnect?.()\n        }\n\n        // Subscribe pending subscriptions\n        for (const [id, state] of this.pendingSubscriptions) {\n          this.subscriptions.set(id, state)\n          this.send({\n            type: 'subscribe',\n            subscriptionId: state.id,\n            queryPath: state.queryPath,\n            args: state.args,\n          })\n          state.options?.onConnect?.()\n        }\n        this.pendingSubscriptions.clear()\n\n        // Start ping interval\n        this.pingInterval = setInterval(() => {\n          if (this.isConnected) {\n            this.send({ type: 'ping' })\n          }\n        }, 30000)\n      })\n\n      this.ws.addEventListener('message', (event: MessageEvent) => {\n        this.handleMessage(event.data as string)\n      })\n\n      this.ws.addEventListener('close', () => {\n        this.isConnected = false\n\n        if (this.pingInterval) {\n          clearInterval(this.pingInterval)\n          this.pingInterval = null\n        }\n\n        // Notify subscriptions of disconnect\n        for (const state of this.subscriptions.values()) {\n          state.options?.onDisconnect?.()\n        }\n\n        // Attempt reconnection\n        if (this.options.autoReconnect && this.reconnectAttempts < this.options.maxReconnectAttempts) {\n          this.reconnectAttempts++\n          const delay = this.options.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1)\n          this.reconnectTimeout = setTimeout(() => this.connect(), delay)\n        }\n      })\n\n      this.ws.addEventListener('error', (event: Event) => {\n        console.error('WebSocket error:', event)\n      })\n    } catch (error) {\n      console.error('Failed to connect:', error)\n      if (this.options.autoReconnect && this.reconnectAttempts < this.options.maxReconnectAttempts) {\n        this.reconnectAttempts++\n        const delay = this.options.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1)\n        this.reconnectTimeout = setTimeout(() => this.connect(), delay)\n      }\n    }\n  }\n\n  private handleMessage(data: string): void {\n    try {\n      const message = JSON.parse(data) as WSMessage\n\n      switch (message.type) {\n        case 'update': {\n          const state = this.subscriptions.get(message.subscriptionId)\n          if (state) {\n            state.lastResult = message.data\n            state.callback(message.data)\n          }\n          break\n        }\n\n        case 'error': {\n          if (message.subscriptionId) {\n            const state = this.subscriptions.get(message.subscriptionId)\n            if (state) {\n              state.options?.onError?.(new Error(message.message))\n            }\n          } else {\n            console.error('Server error:', message.message)\n          }\n          break\n        }\n\n        case 'subscribed':\n        case 'authenticated':\n        case 'pong':\n          // Acknowledgment messages\n          break\n\n        default:\n          console.warn('Unknown message type:', message)\n      }\n    } catch (error) {\n      console.error('Failed to parse message:', error)\n    }\n  }\n\n  private send(message: WSMessage): void {\n    if (this.ws && this.isConnected) {\n      this.ws.send(JSON.stringify(message))\n    }\n  }\n\n  private unsubscribe(id: string): void {\n    const state = this.subscriptions.get(id)\n    if (state) {\n      this.subscriptions.delete(id)\n      if (this.isConnected) {\n        this.send({ type: 'unsubscribe', subscriptionId: id })\n      }\n    }\n\n    this.pendingSubscriptions.delete(id)\n  }\n\n  private generateId(): string {\n    return `sub_${++this.idCounter}_${Date.now()}`\n  }\n\n  private getHeaders(): Record<string, string> {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    }\n\n    if (this.authToken) {\n      headers['Authorization'] = `Bearer ${this.authToken}`\n    }\n\n    return headers\n  }\n}\n","/**\n * ConvexHttpClient - HTTP-only client\n *\n * For server-side or environments where WebSocket is not available.\n */\n\nimport type { FunctionReference } from '../types'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Options for creating a ConvexHttpClient.\n */\nexport interface HttpClientOptions {\n  /** Custom fetch implementation */\n  fetch?: typeof fetch\n  /** Default timeout for requests in milliseconds */\n  timeout?: number\n}\n\n// ============================================================================\n// ConvexHttpClient Implementation\n// ============================================================================\n\n/**\n * HTTP-only client for convex.do.\n *\n * Use this client when:\n * - Running on the server (Node.js, Edge functions)\n * - WebSocket is not available\n * - You don't need real-time subscriptions\n *\n * @example\n * ```typescript\n * import { ConvexHttpClient } from \"convex.do/client\";\n *\n * const client = new ConvexHttpClient(\"https://your-worker.workers.dev\");\n *\n * // Run a query\n * const messages = await client.query(api.messages.list, { channel });\n *\n * // Run a mutation\n * await client.mutation(api.messages.send, { channel, body: \"Hello!\" });\n *\n * // Run an action\n * const result = await client.action(api.ai.generate, { prompt: \"...\" });\n * ```\n */\nexport class ConvexHttpClient {\n  private url: string\n  private options: Required<HttpClientOptions>\n  private authToken: string | null = null\n\n  constructor(url: string, options: HttpClientOptions = {}) {\n    this.url = url.replace(/\\/$/, '')\n\n    this.options = {\n      fetch: options.fetch ?? globalThis.fetch.bind(globalThis),\n      timeout: options.timeout ?? 30000,\n    }\n  }\n\n  /**\n   * Set the authentication token.\n   */\n  setAuth(token: string): void {\n    this.authToken = token\n  }\n\n  /**\n   * Clear the authentication token.\n   */\n  clearAuth(): void {\n    this.authToken = null\n  }\n\n  /**\n   * Run a query.\n   */\n  async query<T>(\n    query: FunctionReference<'query', unknown, T>,\n    args: unknown\n  ): Promise<T> {\n    return this.request<T>('/api/query', query._path, args)\n  }\n\n  /**\n   * Run a mutation.\n   */\n  async mutation<T>(\n    mutation: FunctionReference<'mutation', unknown, T>,\n    args: unknown\n  ): Promise<T> {\n    return this.request<T>('/api/mutation', mutation._path, args)\n  }\n\n  /**\n   * Run an action.\n   */\n  async action<T>(\n    action: FunctionReference<'action', unknown, T>,\n    args: unknown\n  ): Promise<T> {\n    return this.request<T>('/api/action', action._path, args)\n  }\n\n  // ============================================================================\n  // Private Methods\n  // ============================================================================\n\n  private async request<T>(\n    endpoint: string,\n    path: string,\n    args: unknown\n  ): Promise<T> {\n    const controller = new AbortController()\n    const timeoutId = setTimeout(() => controller.abort(), this.options.timeout)\n\n    try {\n      const response = await this.options.fetch(`${this.url}${endpoint}`, {\n        method: 'POST',\n        headers: this.getHeaders(),\n        body: JSON.stringify({\n          path,\n          args,\n          format: 'json',\n        }),\n        signal: controller.signal,\n      })\n\n      if (!response.ok) {\n        const error = await response.json() as { error?: string; message?: string }\n        throw new Error(error.error || error.message || `Request failed: ${response.status}`)\n      }\n\n      return response.json() as Promise<T>\n    } finally {\n      clearTimeout(timeoutId)\n    }\n  }\n\n  private getHeaders(): Record<string, string> {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    }\n\n    if (this.authToken) {\n      headers['Authorization'] = `Bearer ${this.authToken}`\n    }\n\n    return headers\n  }\n}\n"]}