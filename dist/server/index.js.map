{"version":3,"sources":["../../src/values/index.ts","../../src/server/query.ts","../../src/server/mutation.ts","../../src/server/action.ts","../../src/server/httpRouter.ts","../../src/server/schema.ts","../../src/server/database/QueryBuilder.ts","../../src/server/queryBuilder.ts","../../src/server/database/DatabaseReader.ts","../../src/server/database/DatabaseWriter.ts","../../src/server/context/QueryCtx.ts","../../src/server/context/MutationCtx.ts","../../src/server/context/ActionCtx.ts","../../src/server/functions/registered.ts","../../src/server/functions/registry.ts","../../src/server/functions/api.ts"],"names":["v","QueryBuilderImpl","IndexRangeBuilderImpl","FilterBuilderImpl","query","VALID_ID_PATTERN","MAX_ID_LENGTH","validateAuth","validateScheduler"],"mappings":";AAqCA,IAAM,oBAAN,MAAwB;AAAA,EACd,OAA4B,EAAC;AAAA,EAErC,KAAK,OAAA,EAAgC;AACnC,IAAA,IAAA,CAAK,IAAA,CAAK,KAAK,OAAO,CAAA;AAAA,EACxB;AAAA,EAEA,GAAA,GAAY;AACV,IAAA,IAAA,CAAK,KAAK,GAAA,EAAI;AAAA,EAChB;AAAA,EAEA,OAAA,GAA+B;AAC7B,IAAA,OAAO,CAAC,GAAG,IAAA,CAAK,IAAI,CAAA;AAAA,EACtB;AAAA,EAEA,UAAA,GAAqB;AACnB,IAAA,OAAO,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,GAAG,CAAA;AAAA,EAC3B;AACF,CAAA;AAGA,IAAI,cAAA,GAA2C,IAAA;AAE/C,SAAS,YAAe,EAAA,EAAgB;AACtC,EAAA,MAAM,aAAa,cAAA,KAAmB,IAAA;AACtC,EAAA,IAAI,CAAC,UAAA,EAAY;AACf,IAAA,cAAA,GAAiB,IAAI,iBAAA,EAAkB;AAAA,EACzC;AACA,EAAA,IAAI;AACF,IAAA,OAAO,EAAA,EAAG;AAAA,EACZ,CAAA,SAAE;AACA,IAAA,IAAI,CAAC,UAAA,EAAY;AACf,MAAA,cAAA,GAAiB,IAAA;AAAA,IACnB;AAAA,EACF;AACF;AAEA,SAAS,SAAS,OAAA,EAAgC;AAChD,EAAA,cAAA,EAAgB,KAAK,OAAO,CAAA;AAC9B;AAEA,SAAS,OAAA,GAAgB;AACvB,EAAA,cAAA,EAAgB,GAAA,EAAI;AACtB;AAEA,SAAS,aAAA,GAAwB;AAC/B,EAAA,OAAO,cAAA,EAAgB,YAAW,IAAK,EAAA;AACzC;AAMA,IAAe,gBAAf,MAAwG;AAAA,EAE7F,UAAA,GAAyB,KAAA;AAAA,EAKlC,QAAQ,KAAA,EAA4B;AAClC,IAAA,IAAI;AACF,MAAA,IAAA,CAAK,MAAM,KAAK,CAAA;AAChB,MAAA,OAAO,IAAA;AAAA,IACT,CAAA,CAAA,MAAQ;AACN,MAAA,OAAO,KAAA;AAAA,IACT;AAAA,EACF;AAAA,EAEA,QAAA,GAAiC;AAC/B,IAAA,OAAO,IAAI,kBAAkB,IAAI,CAAA;AAAA,EACnC;AACF,CAAA;AASA,SAAS,YAAY,KAAA,EAAwB;AAC3C,EAAA,IAAI,KAAA,KAAU,MAAM,OAAO,MAAA;AAC3B,EAAA,IAAI,KAAA,KAAU,QAAW,OAAO,WAAA;AAChC,EAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG,OAAO,OAAA;AACjC,EAAA,IAAI,KAAA,YAAiB,aAAa,OAAO,aAAA;AACzC,EAAA,IAAI,YAAY,MAAA,CAAO,KAAK,CAAA,EAAG,OAAO,MAAM,WAAA,CAAY,IAAA;AACxD,EAAA,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,OAAO,KAAA,CAAM,KAAK,GAAG,OAAO,KAAA;AAC7D,EAAA,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,KAAA,KAAU,IAAA,EAAM;AAE/C,IAAA,IAAI,KAAA,YAAiB,QAAQ,OAAO,eAAA;AACpC,IAAA,IAAI,KAAA,YAAiB,QAAQ,OAAO,eAAA;AACpC,IAAA,IAAI,KAAA,YAAiB,SAAS,OAAO,gBAAA;AACrC,IAAA,OAAO,QAAA;AAAA,EACT;AACA,EAAA,OAAO,OAAO,KAAA;AAChB;AAEA,IAAM,eAAA,GAAN,cAA8B,aAAA,CAAsB;AAAA,EACzC,KAAA;AAAA,EAET,MAAM,KAAA,EAAwB;AAE5B,IAAA,IAAI,iBAAiB,MAAA,EAAQ;AAC3B,MAAA,MAAM,IAAI,MAAM,CAAA,kCAAA,CAAoC,CAAA;AAAA,IACtD;AACA,IAAA,IAAI,OAAO,UAAU,QAAA,EAAU;AAC7B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,qBAAA,EAAwB,WAAA,CAAY,KAAK,CAAC,CAAA,CAAE,CAAA;AAAA,IAC9D;AACA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,QAAA;AAAA,EACT;AACF,CAAA;AAEA,IAAM,eAAA,GAAN,cAA8B,aAAA,CAAsB;AAAA,EACzC,KAAA;AAAA,EAET,MAAM,KAAA,EAAwB;AAE5B,IAAA,IAAI,iBAAiB,MAAA,EAAQ;AAC3B,MAAA,MAAM,IAAI,MAAM,CAAA,kCAAA,CAAoC,CAAA;AAAA,IACtD;AACA,IAAA,IAAI,OAAO,UAAU,QAAA,EAAU;AAC7B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,qBAAA,EAAwB,WAAA,CAAY,KAAK,CAAC,CAAA,CAAE,CAAA;AAAA,IAC9D;AAEA,IAAA,IAAI,MAAA,CAAO,KAAA,CAAM,KAAK,CAAA,EAAG;AACvB,MAAA,MAAM,IAAI,MAAM,CAAA,wBAAA,CAA0B,CAAA;AAAA,IAC5C;AAEA,IAAA,IAAI,CAAC,MAAA,CAAO,QAAA,CAAS,KAAK,CAAA,EAAG;AAC3B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,qBAAA,EAAwB,QAAQ,CAAA,GAAI,UAAA,GAAa,WAAW,CAAA,CAAE,CAAA;AAAA,IAChF;AACA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,QAAA;AAAA,EACT;AACF,CAAA;AAEA,IAAM,gBAAA,GAAN,cAA+B,aAAA,CAAuB;AAAA,EAC3C,KAAA;AAAA,EAET,MAAM,KAAA,EAAyB;AAE7B,IAAA,IAAI,iBAAiB,OAAA,EAAS;AAC5B,MAAA,MAAM,IAAI,MAAM,CAAA,oCAAA,CAAsC,CAAA;AAAA,IACxD;AACA,IAAA,IAAI,OAAO,UAAU,SAAA,EAAW;AAC9B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,sBAAA,EAAyB,WAAA,CAAY,KAAK,CAAC,CAAA,CAAE,CAAA;AAAA,IAC/D;AACA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,SAAA;AAAA,EACT;AACF,CAAA;AAEA,IAAM,aAAA,GAAN,cAA4B,aAAA,CAAoB;AAAA,EACrC,KAAA;AAAA,EAET,MAAM,KAAA,EAAsB;AAC1B,IAAA,IAAI,UAAU,IAAA,EAAM;AAElB,MAAA,IAAI,UAAU,MAAA,EAAW;AACvB,QAAA,MAAM,IAAI,MAAM,CAAA,qBAAA,CAAuB,CAAA;AAAA,MACzC;AACA,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,mBAAA,EAAsB,WAAA,CAAY,KAAK,CAAC,CAAA,CAAE,CAAA;AAAA,IAC5D;AACA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,MAAA;AAAA,EACT;AACF,CAAA;AAEA,IAAM,SAAA,GAAY,OAAO,qBAAqB,CAAA;AAC9C,IAAM,SAAA,GAAY,OAAO,sBAAsB,CAAA;AAE/C,IAAM,cAAA,GAAN,cAA6B,aAAA,CAAsB;AAAA,EACxC,KAAA;AAAA,EAET,MAAM,KAAA,EAAwB;AAC5B,IAAA,IAAI,MAAA;AAEJ,IAAA,IAAI,OAAO,UAAU,QAAA,EAAU;AAC7B,MAAA,MAAA,GAAS,KAAA;AAAA,IACX,CAAA,MAAA,IAAW,OAAO,KAAA,KAAU,QAAA,EAAU;AAEpC,MAAA,IAAI,MAAA,CAAO,KAAA,CAAM,KAAK,CAAA,EAAG;AACvB,QAAA,MAAM,IAAI,MAAM,CAAA,8BAAA,CAAgC,CAAA;AAAA,MAClD;AACA,MAAA,IAAI,CAAC,MAAA,CAAO,QAAA,CAAS,KAAK,CAAA,EAAG;AAC3B,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,2BAAA,EAA8B,QAAQ,CAAA,GAAI,UAAA,GAAa,WAAW,CAAA,CAAE,CAAA;AAAA,MACtF;AAEA,MAAA,IAAI,CAAC,MAAA,CAAO,SAAA,CAAU,KAAK,CAAA,EAAG;AAC5B,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,kCAAA,EAAqC,KAAK,CAAA,CAAA,CAAG,CAAA;AAAA,MAC/D;AACA,MAAA,MAAA,GAAS,OAAO,KAAK,CAAA;AAAA,IACvB,CAAA,MAAA,IAAW,OAAO,KAAA,KAAU,QAAA,EAAU;AAEpC,MAAA,IAAI,UAAU,EAAA,EAAI;AAChB,QAAA,MAAM,IAAI,MAAM,CAAA,oCAAA,CAAsC,CAAA;AAAA,MACxD;AAEA,MAAA,IAAI,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA,EAAG;AACvB,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,0CAAA,EAA6C,KAAK,CAAA,EAAA,CAAI,CAAA;AAAA,MACxE;AACA,MAAA,IAAI;AACF,QAAA,MAAA,GAAS,OAAO,KAAK,CAAA;AAAA,MACvB,CAAA,CAAA,MAAQ;AACN,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,gBAAA,EAAmB,KAAK,CAAA,UAAA,CAAY,CAAA;AAAA,MACtD;AAAA,IACF,CAAA,MAAO;AACL,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,2BAAA,EAA8B,WAAA,CAAY,KAAK,CAAC,CAAA,CAAE,CAAA;AAAA,IACpE;AAGA,IAAA,IAAI,SAAS,SAAA,EAAW;AACtB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,MAAA,EAAS,MAAM,CAAA,8BAAA,EAAiC,SAAS,CAAA,CAAA,CAAG,CAAA;AAAA,IAC9E;AACA,IAAA,IAAI,SAAS,SAAA,EAAW;AACtB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,MAAA,EAAS,MAAM,CAAA,mCAAA,EAAsC,SAAS,CAAA,CAAA,CAAG,CAAA;AAAA,IACnF;AAEA,IAAA,OAAO,MAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,OAAA;AAAA,EACT;AACF,CAAA;AAEA,IAAM,gBAAA,GAAN,cAA+B,aAAA,CAAsB;AAAA,EAC1C,KAAA;AAAA,EAET,MAAM,KAAA,EAAwB;AAE5B,IAAA,IAAI,iBAAiB,MAAA,EAAQ;AAC3B,MAAA,MAAM,IAAI,MAAM,CAAA,0CAAA,CAA4C,CAAA;AAAA,IAC9D;AACA,IAAA,IAAI,OAAO,UAAU,QAAA,EAAU;AAC7B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,6BAAA,EAAgC,WAAA,CAAY,KAAK,CAAC,CAAA,CAAE,CAAA;AAAA,IACtE;AAEA,IAAA,IAAI,MAAA,CAAO,KAAA,CAAM,KAAK,CAAA,EAAG;AACvB,MAAA,MAAM,IAAI,MAAM,CAAA,0BAAA,CAA4B,CAAA;AAAA,IAC9C;AAEA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,SAAA;AAAA,EACT;AACF,CAAA;AAEA,IAAM,cAAA,GAAN,cAA6B,aAAA,CAA2B;AAAA,EAC7C,KAAA;AAAA,EAET,MAAM,KAAA,EAA6B;AACjC,IAAA,IAAI,iBAAiB,WAAA,EAAa;AAChC,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,IAAI,WAAA,CAAY,MAAA,CAAO,KAAK,CAAA,EAAG;AAC7B,MAAA,OAAO,KAAA,CAAM,OAAO,KAAA,CAAM,KAAA,CAAM,YAAY,KAAA,CAAM,UAAA,GAAa,MAAM,UAAU,CAAA;AAAA,IACjF;AACA,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,gCAAA,EAAmC,OAAO,KAAK,CAAA,CAAE,CAAA;AAAA,EACnE;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,OAAA;AAAA,EACT;AACF,CAAA;AASA,IAAM,aAAA,GAAgB,EAAA;AAKtB,IAAM,aAAA,GAAgB,GAAA;AAMtB,IAAM,gBAAA,GAAmB,gBAAA;AAEzB,IAAM,WAAA,GAAN,cAAoD,aAAA,CAAmD;AAAA,EAC5F,KAAA;AAAA,EACD,SAAA;AAAA,EAER,YAAY,SAAA,EAAsB;AAChC,IAAA,KAAA,EAAM;AACN,IAAA,IAAI,CAAC,SAAA,IAAa,SAAA,CAAU,IAAA,OAAW,EAAA,EAAI;AACzC,MAAA,MAAM,IAAI,MAAM,4BAA4B,CAAA;AAAA,IAC9C;AACA,IAAA,IAAA,CAAK,SAAA,GAAY,SAAA;AAAA,EACnB;AAAA,EAEA,MAAM,KAAA,EAAqD;AAEzD,IAAA,IAAI,OAAO,UAAU,QAAA,EAAU;AAC7B,MAAA,MAAM,IAAI,MAAM,CAAA,uBAAA,EAA0B,IAAA,CAAK,SAAS,CAAA,OAAA,EAAU,WAAA,CAAY,KAAK,CAAC,CAAA,CAAE,CAAA;AAAA,IACxF;AAGA,IAAA,IAAI,KAAA,CAAM,WAAW,CAAA,EAAG;AACtB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,cAAA,EAAiB,IAAA,CAAK,SAAS,CAAA,iBAAA,CAAmB,CAAA;AAAA,IACpE;AAGA,IAAA,IAAI,KAAA,CAAM,SAAS,aAAA,EAAe;AAChC,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,sBAAA,EAAyB,KAAK,SAAS,CAAA,4BAAA,EAA+B,aAAa,CAAA,YAAA,CAAc,CAAA;AAAA,IACnH;AAGA,IAAA,IAAI,KAAA,CAAM,SAAS,aAAA,EAAe;AAChC,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,sBAAA,EAAyB,KAAK,SAAS,CAAA,2BAAA,EAA8B,aAAa,CAAA,YAAA,CAAc,CAAA;AAAA,IAClH;AAGA,IAAA,IAAI,CAAC,gBAAA,CAAiB,IAAA,CAAK,KAAK,CAAA,EAAG;AACjC,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,sBAAA,EAAyB,IAAA,CAAK,SAAS,CAAA,iCAAA,CAAmC,CAAA;AAAA,IAC5F;AAEA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,CAAA,MAAA,EAAS,KAAK,SAAS,CAAA,EAAA,CAAA;AAAA,EAChC;AACF,CAAA;AAaA,IAAM,eAAA,GAAN,MAAM,gBAAA,SAA+C,aAAA,CAA8B;AAAA,EACxE,KAAA;AAAA,EACD,KAAA;AAAA,EACA,IAAA;AAAA,EAER,WAAA,CAAY,KAAA,EAAU,IAAA,GAAmB,OAAA,EAAS;AAChD,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AACb,IAAA,IAAA,CAAK,IAAA,GAAO,IAAA;AAAA,EACd;AAAA,EAEA,MAAM,KAAA,EAAgC;AACpC,IAAA,OAAO,WAAA,CAAY,MAAM,IAAA,CAAK,aAAA,CAAc,KAAK,CAAC,CAAA;AAAA,EACpD;AAAA,EAEQ,cAAc,KAAA,EAAgC;AACpD,IAAA,IAAI,OAAO,UAAU,QAAA,IAAY,KAAA,KAAU,QAAQ,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;AACvE,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,qBAAA,EAAwB,KAAA,KAAU,IAAA,GAAO,MAAA,GAAS,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,GAAI,OAAA,GAAU,OAAO,KAAK,CAAA,CAAE,CAAA;AAAA,IACnH;AAEA,IAAA,MAAM,SAAkC,EAAC;AACzC,IAAA,MAAM,GAAA,GAAM,KAAA;AACZ,IAAA,MAAM,aAAa,IAAI,GAAA,CAAI,OAAO,IAAA,CAAK,IAAA,CAAK,KAAK,CAAC,CAAA;AAGlD,IAAA,IAAI,IAAA,CAAK,SAAS,QAAA,EAAU;AAC1B,MAAA,KAAA,MAAW,GAAA,IAAO,MAAA,CAAO,IAAA,CAAK,GAAG,CAAA,EAAG;AAClC,QAAA,IAAI,CAAC,UAAA,CAAW,GAAA,CAAI,GAAG,CAAA,EAAG;AACxB,UAAA,MAAM,IAAI,KAAA,CAAM,CAAA,kBAAA,EAAqB,GAAG,CAAA,WAAA,CAAa,CAAA;AAAA,QACvD;AAAA,MACF;AAAA,IACF;AAGA,IAAA,KAAA,MAAW,CAAC,KAAK,SAAS,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,KAAK,CAAA,EAAG;AACzD,MAAA,MAAM,UAAA,GAAa,IAAI,GAAG,CAAA;AAC1B,MAAA,IAAI,UAAA,KAAe,MAAA,IAAa,CAAC,SAAA,CAAU,UAAA,EAAY;AACrD,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,wBAAA,EAA2B,GAAG,CAAA,CAAA,CAAG,CAAA;AAAA,MACnD;AACA,MAAA,IAAI,eAAe,MAAA,EAAW;AAC5B,QAAA,QAAA,CAAS,GAAG,CAAA;AACZ,QAAA,IAAI;AACF,UAAA,MAAA,CAAO,GAAG,CAAA,GAAI,SAAA,CAAU,KAAA,CAAM,UAAU,CAAA;AAAA,QAC1C,SAAS,CAAA,EAAG;AACV,UAAA,MAAM,OAAO,aAAA,EAAc;AAC3B,UAAA,MAAM,WAAY,CAAA,CAAY,OAAA;AAC9B,UAAA,MAAM,IAAI,MAAM,IAAA,GAAO,CAAA,oBAAA,EAAuB,IAAI,CAAA,EAAA,EAAK,QAAQ,KAAK,QAAQ,CAAA;AAAA,QAC9E,CAAA,SAAE;AACA,UAAA,OAAA,EAAQ;AAAA,QACV;AAAA,MACF;AAAA,IACF;AAGA,IAAA,IAAI,IAAA,CAAK,SAAS,aAAA,EAAe;AAC/B,MAAA,KAAA,MAAW,GAAA,IAAO,MAAA,CAAO,IAAA,CAAK,GAAG,CAAA,EAAG;AAClC,QAAA,IAAI,CAAC,UAAA,CAAW,GAAA,CAAI,GAAG,CAAA,EAAG;AACxB,UAAA,MAAA,CAAO,GAAG,CAAA,GAAI,GAAA,CAAI,GAAG,CAAA;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAEA,IAAA,OAAO,MAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,MAAM,MAAA,GAAS,OAAO,OAAA,CAAQ,IAAA,CAAK,KAAK,CAAA,CACrC,GAAA,CAAI,CAAC,CAAC,GAAA,EAAKA,EAAC,CAAA,KAAM,CAAA,EAAG,GAAG,CAAA,EAAA,EAAKA,EAAAA,CAAE,UAAU,CAAA,CAAE,CAAA,CAC3C,IAAA,CAAK,IAAI,CAAA;AACZ,IAAA,OAAO,KAAK,MAAM,CAAA,EAAA,CAAA;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAA,GAA6B;AAC3B,IAAA,OAAO,IAAI,gBAAA,CAAgB,IAAA,CAAK,KAAA,EAAO,QAAQ,CAAA;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,GAAkC;AAChC,IAAA,OAAO,IAAI,gBAAA,CAAgB,IAAA,CAAK,KAAA,EAAO,aAAa,CAAA;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKA,OAA8B,eAAA,EAA4C;AACxE,IAAA,OAAO,IAAI,gBAAA,CAAgB,EAAE,GAAG,IAAA,CAAK,OAAO,GAAG,eAAA,EAAgB,EAAY,IAAA,CAAK,IAAI,CAAA;AAAA,EACtF;AAAA;AAAA;AAAA;AAAA,EAKA,KAAwB,IAAA,EAAwC;AAC9D,IAAA,MAAM,WAAuB,EAAC;AAC9B,IAAA,KAAA,MAAW,OAAO,IAAA,EAAM;AACtB,MAAA,IAAI,GAAA,IAAO,KAAK,KAAA,EAAO;AACrB,QAAA,QAAA,CAAS,GAAG,CAAA,GAAI,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA;AAAA,MAChC;AAAA,IACF;AACA,IAAA,OAAO,IAAI,gBAAA,CAAgB,QAAA,EAAwB,IAAA,CAAK,IAAI,CAAA;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKA,KAAwB,IAAA,EAAwC;AAC9D,IAAA,MAAM,UAAA,GAAa,IAAI,GAAA,CAAI,IAAoC,CAAA;AAC/D,IAAA,MAAM,WAAuB,EAAC;AAC9B,IAAA,KAAA,MAAW,CAAC,KAAK,SAAS,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,KAAK,CAAA,EAAG;AACzD,MAAA,IAAI,CAAC,UAAA,CAAW,GAAA,CAAI,GAAG,CAAA,EAAG;AACxB,QAAC,QAAA,CAAqC,GAAG,CAAA,GAAI,SAAA;AAAA,MAC/C;AAAA,IACF;AACA,IAAA,OAAO,IAAI,gBAAA,CAAgB,QAAA,EAAwB,IAAA,CAAK,IAAI,CAAA;AAAA,EAC9D;AACF,CAAA;AAQA,IAAM,cAAA,GAAN,MAAM,eAAA,SAA4C,aAAA,CAA0B;AAAA,EACjE,KAAA;AAAA,EACD,OAAA;AAAA,EACA,WAAA;AAAA,EAER,WAAA,CAAY,OAAA,EAAY,WAAA,GAAgC,EAAC,EAAG;AAC1D,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AACf,IAAA,IAAA,CAAK,WAAA,GAAc,WAAA;AAAA,EACrB;AAAA,EAEA,MAAM,KAAA,EAA4B;AAChC,IAAA,IAAI,CAAC,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;AACzB,MAAA,MAAM,IAAI,MAAM,CAAA,oBAAA,EAAuB,KAAA,KAAU,OAAO,MAAA,GAAS,OAAO,KAAK,CAAA,CAAE,CAAA;AAAA,IACjF;AAGA,IAAA,IAAI,IAAA,CAAK,YAAY,SAAA,KAAc,MAAA,IAAa,MAAM,MAAA,GAAS,IAAA,CAAK,YAAY,SAAA,EAAW;AACzF,MAAA,MAAM,IAAI,MAAM,CAAA,yBAAA,EAA4B,IAAA,CAAK,YAAY,SAAS,CAAA,iBAAA,EAAoB,KAAA,CAAM,MAAM,CAAA,CAAE,CAAA;AAAA,IAC1G;AACA,IAAA,IAAI,IAAA,CAAK,YAAY,SAAA,KAAc,MAAA,IAAa,MAAM,MAAA,GAAS,IAAA,CAAK,YAAY,SAAA,EAAW;AACzF,MAAA,MAAM,IAAI,MAAM,CAAA,wBAAA,EAA2B,IAAA,CAAK,YAAY,SAAS,CAAA,iBAAA,EAAoB,KAAA,CAAM,MAAM,CAAA,CAAE,CAAA;AAAA,IACzG;AACA,IAAA,IAAI,IAAA,CAAK,YAAY,WAAA,KAAgB,MAAA,IAAa,MAAM,MAAA,KAAW,IAAA,CAAK,YAAY,WAAA,EAAa;AAC/F,MAAA,MAAM,IAAI,MAAM,CAAA,wBAAA,EAA2B,IAAA,CAAK,YAAY,WAAW,CAAA,iBAAA,EAAoB,KAAA,CAAM,MAAM,CAAA,CAAE,CAAA;AAAA,IAC3G;AAEA,IAAA,OAAO,KAAA,CAAM,GAAA,CAAI,CAAC,IAAA,EAAM,KAAA,KAAU;AAChC,MAAA,QAAA,CAAS,KAAK,CAAA;AACd,MAAA,IAAI;AACF,QAAA,OAAO,IAAA,CAAK,OAAA,CAAQ,KAAA,CAAM,IAAI,CAAA;AAAA,MAChC,SAAS,CAAA,EAAG;AACV,QAAA,MAAM,OAAO,aAAA,EAAc;AAC3B,QAAA,MAAM,WAAY,CAAA,CAAY,OAAA;AAC9B,QAAA,MAAM,IAAI,KAAA,CAAM,IAAA,GAAO,CAAA,yBAAA,EAA4B,KAAK,CAAA,EAAA,EAAK,QAAQ,CAAA,CAAA,GAAK,CAAA,+BAAA,EAAkC,KAAK,CAAA,EAAA,EAAK,QAAQ,CAAA,CAAE,CAAA;AAAA,MAClI,CAAA,SAAE;AACA,QAAA,OAAA,EAAQ;AAAA,MACV;AAAA,IACF,CAAC,CAAA;AAAA,EACH;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,CAAA,EAAG,IAAA,CAAK,OAAA,CAAQ,QAAA,EAAU,CAAA,EAAA,CAAA;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,QAAA,GAA8B;AAC5B,IAAA,OAAO,IAAI,eAAA,CAAe,IAAA,CAAK,OAAA,EAAS,EAAE,GAAG,IAAA,CAAK,WAAA,EAAa,SAAA,EAAW,CAAA,EAAG,CAAA;AAAA,EAC/E;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,SAAA,EAAsC;AACxC,IAAA,OAAO,IAAI,gBAAe,IAAA,CAAK,OAAA,EAAS,EAAE,GAAG,IAAA,CAAK,WAAA,EAAa,SAAA,EAAW,CAAA;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,SAAA,EAAsC;AACxC,IAAA,OAAO,IAAI,gBAAe,IAAA,CAAK,OAAA,EAAS,EAAE,GAAG,IAAA,CAAK,WAAA,EAAa,SAAA,EAAW,CAAA;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,WAAA,EAAwC;AAC7C,IAAA,OAAO,IAAI,gBAAe,IAAA,CAAK,OAAA,EAAS,EAAE,GAAG,IAAA,CAAK,WAAA,EAAa,WAAA,EAAa,CAAA;AAAA,EAC9E;AACF,CAAA;AAIA,IAAM,cAAA,GAAN,cAAoD,aAAA,CAA6B;AAAA,EACtE,KAAA;AAAA,EACD,UAAA;AAAA,EAER,YAAY,UAAA,EAAe;AACzB,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,UAAA,GAAa,UAAA;AAAA,EACpB;AAAA,EAEA,MAAM,KAAA,EAA+B;AACnC,IAAA,MAAM,SAAmB,EAAC;AAE1B,IAAA,KAAA,MAAW,SAAA,IAAa,KAAK,UAAA,EAAY;AACvC,MAAA,IAAI;AACF,QAAA,OAAO,SAAA,CAAU,MAAM,KAAK,CAAA;AAAA,MAC9B,SAAS,CAAA,EAAG;AACV,QAAA,MAAA,CAAO,IAAA,CAAM,EAAY,OAAO,CAAA;AAAA,MAClC;AAAA,IACF;AAEA,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iCAAA,EAAoC,OAAO,IAAA,CAAK,IAAI,CAAC,CAAA,CAAE,CAAA;AAAA,EACzE;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,IAAA,CAAK,UAAA,CAAW,GAAA,CAAI,CAAAA,EAAAA,KAAKA,GAAE,QAAA,EAAU,CAAA,CAAE,IAAA,CAAK,KAAK,CAAA;AAAA,EAC1D;AACF,CAAA;AAEA,IAAM,iBAAA,GAAN,cAAmC,aAAA,CAAmC;AAAA,EAC3D,KAAA;AAAA,EACS,UAAA,GAAmB,IAAA;AAAA,EAC7B,KAAA;AAAA,EAER,YAAY,KAAA,EAAqB;AAC/B,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AAAA,EACf;AAAA,EAEA,MAAM,KAAA,EAA+B;AACnC,IAAA,IAAI,UAAU,MAAA,EAAW;AACvB,MAAA,OAAO,MAAA;AAAA,IACT;AACA,IAAA,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,KAAK,CAAA;AAAA,EAC/B;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,CAAA,EAAG,IAAA,CAAK,KAAA,CAAM,QAAA,EAAU,CAAA,YAAA,CAAA;AAAA,EACjC;AAAA,EAES,QAAA,GAA6C;AACpD,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,YAAA,EAAsC;AAC5C,IAAA,OAAO,IAAI,gBAAA,CAAiB,IAAA,CAAK,KAAA,EAAO,YAAY,CAAA;AAAA,EACtD;AACF,CAAA;AAEA,IAAM,gBAAA,GAAN,cAAkC,aAAA,CAAuB;AAAA,EAC9C,KAAA;AAAA,EACS,UAAA,GAAmB,IAAA;AAAA,EAC7B,KAAA;AAAA,EACA,YAAA;AAAA,EAER,WAAA,CAAY,OAAqB,YAAA,EAAiB;AAChD,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AACb,IAAA,IAAA,CAAK,YAAA,GAAe,YAAA;AAAA,EACtB;AAAA,EAEA,MAAM,KAAA,EAAmB;AACvB,IAAA,IAAI,UAAU,MAAA,EAAW;AACvB,MAAA,OAAO,IAAA,CAAK,YAAA;AAAA,IACd;AACA,IAAA,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,KAAK,CAAA;AAAA,EAC/B;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,CAAA,EAAG,IAAA,CAAK,KAAA,CAAM,QAAA,EAAU,cAAc,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,YAAY,CAAC,CAAA,CAAA,CAAA;AAAA,EAChF;AACF,CAAA;AAEA,IAAM,gBAAA,GAAN,cAAoE,aAAA,CAAiB;AAAA,EAC1E,KAAA;AAAA,EACD,OAAA;AAAA,EAER,YAAY,OAAA,EAAY;AACtB,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AAAA,EACjB;AAAA,EAEA,MAAM,KAAA,EAAmB;AACvB,IAAA,IAAI,KAAA,KAAU,KAAK,OAAA,EAAS;AAC1B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iBAAA,EAAoB,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,OAAO,CAAC,CAAA,MAAA,EAAS,IAAA,CAAK,SAAA,CAAU,KAAK,CAAC,CAAA,CAAE,CAAA;AAAA,IAClG;AACA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,IAAA,CAAK,SAAA,CAAU,IAAA,CAAK,OAAO,CAAA;AAAA,EACpC;AACF,CAAA;AAEA,IAAM,eAAA,GAAN,cAAgF,aAAA,CAA0C;AAAA,EAC/G,KAAA;AAAA,EACD,IAAA;AAAA,EACA,MAAA;AAAA,EAER,WAAA,CAAY,MAAS,MAAA,EAAW;AAC9B,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,IAAA,GAAO,IAAA;AACZ,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AAAA,EAChB;AAAA,EAEA,MAAM,KAAA,EAA4C;AAChD,IAAA,IAAI,OAAO,UAAU,QAAA,IAAY,KAAA,KAAU,QAAQ,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;AACvE,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,4BAAA,EAA+B,KAAA,KAAU,IAAA,GAAO,MAAA,GAAS,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,GAAI,OAAA,GAAU,OAAO,KAAK,CAAA,CAAE,CAAA;AAAA,IAC1H;AAEA,IAAA,MAAM,SAAkC,EAAC;AACzC,IAAA,MAAM,GAAA,GAAM,KAAA;AAEZ,IAAA,KAAA,MAAW,CAAC,GAAA,EAAK,GAAG,KAAK,MAAA,CAAO,OAAA,CAAQ,GAAG,CAAA,EAAG;AAC5C,MAAA,IAAI;AACF,QAAA,IAAA,CAAK,IAAA,CAAK,MAAM,GAAG,CAAA;AAAA,MACrB,SAAS,CAAA,EAAG;AACV,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,aAAA,EAAgB,GAAG,CAAA,GAAA,EAAO,CAAA,CAAY,OAAO,CAAA,CAAE,CAAA;AAAA,MACjE;AACA,MAAA,IAAI;AACF,QAAA,MAAA,CAAO,GAAG,CAAA,GAAI,IAAA,CAAK,MAAA,CAAO,MAAM,GAAG,CAAA;AAAA,MACrC,SAAS,CAAA,EAAG;AACV,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,uBAAA,EAA0B,GAAG,CAAA,GAAA,EAAO,CAAA,CAAY,OAAO,CAAA,CAAE,CAAA;AAAA,MAC3E;AAAA,IACF;AAEA,IAAA,OAAO,MAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,CAAA,OAAA,EAAU,KAAK,IAAA,CAAK,QAAA,EAAU,CAAA,EAAA,EAAK,IAAA,CAAK,MAAA,CAAO,QAAA,EAAU,CAAA,CAAA,CAAA;AAAA,EAClE;AACF,CAAA;AAEA,IAAM,YAAA,GAAN,cAA2B,aAAA,CAAuB;AAAA,EACvC,KAAA;AAAA,EAET,MAAM,KAAA,EAAyB;AAC7B,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,KAAA;AAAA,EACT;AACF,CAAA;AAEA,IAAM,gBAAA,GAAN,cAA+B,aAAA,CAAuB;AAAA,EAC3C,KAAA;AAAA,EAET,MAAM,KAAA,EAAyB;AAC7B,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,SAAA;AAAA,EACT;AACF,CAAA;AAEA,IAAM,iBAAA,GAAN,cAAmC,aAAA,CAAwB;AAAA,EAChD,KAAA;AAAA,EACD,KAAA;AAAA,EAER,YAAY,KAAA,EAAqB;AAC/B,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AAAA,EACf;AAAA,EAEA,MAAM,KAAA,EAA0B;AAC9B,IAAA,IAAI,UAAU,IAAA,EAAM;AAClB,MAAA,OAAO,IAAA;AAAA,IACT;AACA,IAAA,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,KAAK,CAAA;AAAA,EAC/B;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,CAAA,EAAG,IAAA,CAAK,KAAA,CAAM,QAAA,EAAU,CAAA,OAAA,CAAA;AAAA,EACjC;AACF,CAAA;AAEA,IAAM,gBAAA,GAAN,cAAkC,aAAA,CAA0C;AAAA,EACjE,KAAA;AAAA,EACS,UAAA,GAAmB,IAAA;AAAA,EAC7B,KAAA;AAAA,EAER,YAAY,KAAA,EAAqB;AAC/B,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,KAAA,GAAQ,KAAA;AAAA,EACf;AAAA,EAEA,MAAM,KAAA,EAAsC;AAC1C,IAAA,IAAI,UAAU,IAAA,EAAM;AAClB,MAAA,OAAO,IAAA;AAAA,IACT;AACA,IAAA,IAAI,UAAU,MAAA,EAAW;AACvB,MAAA,OAAO,MAAA;AAAA,IACT;AACA,IAAA,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,KAAK,CAAA;AAAA,EAC/B;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,CAAA,EAAG,IAAA,CAAK,KAAA,CAAM,QAAA,EAAU,CAAA,mBAAA,CAAA;AAAA,EACjC;AACF,CAAA;AAEA,IAAM,2BAAA,GAAN,cAAiE,aAAA,CAA6B;AAAA,EACnF,KAAA;AAAA,EACD,aAAA;AAAA,EACA,UAAA;AAAA,EAER,WAAA,CAAY,eAAuB,UAAA,EAAe;AAChD,IAAA,KAAA,EAAM;AACN,IAAA,IAAA,CAAK,aAAA,GAAgB,aAAA;AACrB,IAAA,IAAA,CAAK,UAAA,GAAa,UAAA;AAAA,EACpB;AAAA,EAEA,MAAM,KAAA,EAA+B;AACnC,IAAA,IAAI,OAAO,UAAU,QAAA,IAAY,KAAA,KAAU,QAAQ,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;AACvE,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,oCAAA,EAAuC,IAAA,CAAK,aAAa,UAAU,KAAA,KAAU,IAAA,GAAO,MAAA,GAAS,KAAA,CAAM,QAAQ,KAAK,CAAA,GAAI,OAAA,GAAU,OAAO,KAAK,CAAA,CAAE,CAAA;AAAA,IAC9J;AAGA,IAAA,MAAM,SAAmB,EAAC;AAC1B,IAAA,KAAA,MAAW,SAAA,IAAa,KAAK,UAAA,EAAY;AACvC,MAAA,IAAI;AACF,QAAA,OAAO,SAAA,CAAU,MAAM,KAAK,CAAA;AAAA,MAC9B,SAAS,CAAA,EAAG;AACV,QAAA,MAAA,CAAO,IAAA,CAAM,EAAY,OAAO,CAAA;AAAA,MAClC;AAAA,IACF;AAEA,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,mDAAA,EAAsD,IAAA,CAAK,aAAa,MAAM,MAAA,CAAO,IAAA,CAAK,IAAI,CAAC,CAAA,CAAE,CAAA;AAAA,EACnH;AAAA,EAEA,QAAA,GAAmB;AACjB,IAAA,OAAO,IAAA,CAAK,UAAA,CAAW,GAAA,CAAI,CAAAA,EAAAA,KAAKA,GAAE,QAAA,EAAU,CAAA,CAAE,IAAA,CAAK,KAAK,CAAA;AAAA,EAC1D;AACF,CAAA;AAUO,IAAM,CAAA,GAAI;AAAA;AAAA,EAEf,MAAA,EAAQ,MAAM,IAAI,eAAA,EAAgB;AAAA,EAClC,MAAA,EAAQ,MAAM,IAAI,eAAA,EAAgB;AAAA,EAClC,OAAA,EAAS,MAAM,IAAI,gBAAA,EAAiB;AAAA,EACpC,IAAA,EAAM,MAAM,IAAI,aAAA,EAAc;AAAA,EAC9B,KAAA,EAAO,MAAM,IAAI,cAAA,EAAe;AAAA,EAChC,OAAA,EAAS,MAAM,IAAI,gBAAA,EAAiB;AAAA,EACpC,KAAA,EAAO,MAAM,IAAI,cAAA,EAAe;AAAA;AAAA,EAGhC,EAAA,EAAI,CAAmB,SAAA,KAAiB,IAAI,YAAY,SAAS,CAAA;AAAA;AAAA,EAGjE,MAAA,EAAQ,CAAwB,KAAA,KAAa,IAAI,gBAAgB,KAAK,CAAA;AAAA,EACtE,KAAA,EAAO,CAAsB,OAAA,KAAe,IAAI,eAAe,OAAO,CAAA;AAAA,EACtE,KAAA,EAAO,CAAA,GAA2B,UAAA,KAAkB,IAAI,eAAe,UAAU,CAAA;AAAA,EACjF,QAAA,EAAU,CAAsB,SAAA,KAAiB,IAAI,kBAAkB,SAAgC,CAAA;AAAA,EACvG,OAAA,EAAS,CAAsC,KAAA,KAAa,IAAI,iBAAiB,KAAK,CAAA;AAAA,EACtF,MAAA,EAAQ,CAAmD,IAAA,EAAa,MAAA,KAAe;AAErF,IAAA,IAAI,WAAW,MAAA,EAAW;AAExB,MAAA,OAAO,IAAI,eAAA,CAAgB,IAAI,eAAA,IAAmB,IAAS,CAAA;AAAA,IAC7D;AACA,IAAA,OAAO,IAAI,eAAA,CAAgB,IAAA,EAAW,MAAM,CAAA;AAAA,EAC9C,CAAA;AAAA,EACA,GAAA,EAAK,MAAM,IAAI,YAAA,EAAa;AAAA,EAC5B,OAAA,EAAS,MAAM,IAAI,gBAAA,EAAiB;AAAA,EACpC,QAAA,EAAU,CAAsB,SAAA,KAAiB,IAAI,kBAAkB,SAAgC,CAAA;AAAA,EACvG,OAAA,EAAS,CAAsB,SAAA,KAAiB,IAAI,iBAAiB,SAAgC,CAAA;AAAA,EACrG,oBAAoB,CAAwB,aAAA,EAAuB,eAAkB,IAAI,2BAAA,CAA4B,eAAe,UAAU;AAChJ;;;ACtyBO,SAAS,MAId,MAAA,EACgC;AAChC,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,OAAA;AAAA,IACP,KAAA,EAAO,MAAA;AAAA,IACP,QAAA,EAAU,MAAA;AAAA,IACV,WAAA,EAAa,QAAA;AAAA,IACb,OAAA,EAAS;AAAA,GACX;AACF;AAmBO,SAAS,cAId,MAAA,EACgC;AAChC,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,OAAA;AAAA,IACP,KAAA,EAAO,MAAA;AAAA,IACP,QAAA,EAAU,MAAA;AAAA,IACV,WAAA,EAAa,UAAA;AAAA,IACb,OAAA,EAAS;AAAA,GACX;AACF;;;ACtCO,SAAS,SAId,MAAA,EACmC;AACnC,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,UAAA;AAAA,IACP,KAAA,EAAO,MAAA;AAAA,IACP,QAAA,EAAU,MAAA;AAAA,IACV,WAAA,EAAa,QAAA;AAAA,IACb,OAAA,EAAS;AAAA,GACX;AACF;AAwBO,SAAS,iBAId,MAAA,EACmC;AACnC,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,UAAA;AAAA,IACP,KAAA,EAAO,MAAA;AAAA,IACP,QAAA,EAAU,MAAA;AAAA,IACV,WAAA,EAAa,UAAA;AAAA,IACb,OAAA,EAAS;AAAA,GACX;AACF;;;ACzBO,SAAS,OAId,MAAA,EACiC;AACjC,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,QAAA;AAAA,IACP,KAAA,EAAO,MAAA;AAAA,IACP,QAAA,EAAU,MAAA;AAAA,IACV,WAAA,EAAa,QAAA;AAAA,IACb,OAAA,EAAS;AAAA,GACX;AACF;AA4BO,SAAS,eAId,MAAA,EACiC;AACjC,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,QAAA;AAAA,IACP,KAAA,EAAO,MAAA;AAAA,IACP,QAAA,EAAU,MAAA;AAAA,IACV,WAAA,EAAa,UAAA;AAAA,IACb,OAAA,EAAS;AAAA,GACX;AACF;;;ACrFO,IAAM,aAAN,MAAiB;AAAA,EACd,SAA4B,EAAC;AAAA;AAAA;AAAA;AAAA,EAKrC,MAAM,MAAA,EAIG;AACP,IAAA,IAAA,CAAK,OAAO,IAAA,CAAK;AAAA,MACf,MAAM,MAAA,CAAO,IAAA;AAAA,MACb,QAAQ,MAAA,CAAO,MAAA;AAAA,MACf,OAAA,EAAS,MAAA,CAAO,OAAA,CAAQ,OAAA,CAAQ;AAAA,KACjC,CAAA;AACD,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,GAAA,CAAI,MAAc,OAAA,EAAqC;AACrD,IAAA,OAAO,KAAK,KAAA,CAAM,EAAE,MAAM,MAAA,EAAQ,KAAA,EAAO,SAAS,CAAA;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAA,CAAK,MAAc,OAAA,EAAqC;AACtD,IAAA,OAAO,KAAK,KAAA,CAAM,EAAE,MAAM,MAAA,EAAQ,MAAA,EAAQ,SAAS,CAAA;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKA,GAAA,CAAI,MAAc,OAAA,EAAqC;AACrD,IAAA,OAAO,KAAK,KAAA,CAAM,EAAE,MAAM,MAAA,EAAQ,KAAA,EAAO,SAAS,CAAA;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,KAAA,CAAM,MAAc,OAAA,EAAqC;AACvD,IAAA,OAAO,KAAK,KAAA,CAAM,EAAE,MAAM,MAAA,EAAQ,OAAA,EAAS,SAAS,CAAA;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAA,CAAO,MAAc,OAAA,EAAqC;AACxD,IAAA,OAAO,KAAK,KAAA,CAAM,EAAE,MAAM,MAAA,EAAQ,QAAA,EAAU,SAAS,CAAA;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAA,CAAQ,MAAc,OAAA,EAAqC;AACzD,IAAA,OAAO,KAAK,KAAA,CAAM,EAAE,MAAM,MAAA,EAAQ,SAAA,EAAW,SAAS,CAAA;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA,EAKA,IAAA,CAAK,MAAc,OAAA,EAAqC;AACtD,IAAA,OAAO,KAAK,KAAA,CAAM,EAAE,MAAM,MAAA,EAAQ,MAAA,EAAQ,SAAS,CAAA;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKA,SAAA,GAAwC;AACtC,IAAA,OAAO,IAAA,CAAK,MAAA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAA,EAA0C;AAC9C,IAAA,MAAM,GAAA,GAAM,IAAI,GAAA,CAAI,OAAA,CAAQ,GAAG,CAAA;AAC/B,IAAA,MAAM,SAAS,OAAA,CAAQ,MAAA;AACvB,IAAA,MAAM,OAAO,GAAA,CAAI,QAAA;AAEjB,IAAA,KAAA,MAAW,KAAA,IAAS,KAAK,MAAA,EAAQ;AAC/B,MAAA,IAAI,KAAA,CAAM,WAAW,MAAA,IAAU,IAAA,CAAK,YAAY,KAAA,CAAM,IAAA,EAAM,IAAI,CAAA,EAAG;AACjE,QAAA,OAAO,KAAA;AAAA,MACT;AAAA,IACF;AAEA,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,MAAA,CAAO,GAAA,EAAoB,OAAA,EAA4C;AAC3E,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,KAAA,CAAM,OAAO,CAAA;AAChC,IAAA,IAAI,CAAC,KAAA,EAAO;AACV,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,aAAA,CAAc,OAAA,EAAS,MAAM,IAAI,CAAA;AAC9D,IAAA,OAAO,KAAA,CAAM,OAAA,CAAQ,GAAA,EAAK,eAAe,CAAA;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAA,CAAc,SAAkB,OAAA,EAA+D;AAC7F,IAAA,MAAM,GAAA,GAAM,IAAI,GAAA,CAAI,OAAA,CAAQ,GAAG,CAAA;AAC/B,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,aAAA,CAAc,OAAA,EAAS,IAAI,QAAQ,CAAA;AAGvD,IAAA,MAAM,kBAAkB,MAAA,CAAO,MAAA,CAAO,OAAA,EAAS,EAAE,QAAQ,CAAA;AAIzD,IAAA,OAAO,eAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,WAAA,CAAY,SAAiB,IAAA,EAAuB;AAE1D,IAAA,IAAI,OAAA,KAAY,MAAM,OAAO,IAAA;AAG7B,IAAA,MAAM,YAAA,GAAe,OAAA,CAAQ,KAAA,CAAM,GAAG,CAAA;AACtC,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA;AAGhC,IAAA,MAAM,eAAA,GAAkB,YAAA,CAAa,YAAA,CAAa,MAAA,GAAS,CAAC,CAAA;AAC5D,IAAA,IAAI,eAAA,EAAiB,UAAA,CAAW,GAAG,CAAA,EAAG;AAGpC,MAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,YAAA,CAAa,MAAA,GAAS,GAAG,CAAA,EAAA,EAAK;AAChD,QAAA,MAAM,WAAA,GAAc,aAAa,CAAC,CAAA;AAClC,QAAA,MAAM,QAAA,GAAW,UAAU,CAAC,CAAA;AAE5B,QAAA,IAAI,WAAA,EAAa,UAAA,CAAW,GAAG,CAAA,EAAG;AAClC,QAAA,IAAI,WAAA,KAAgB,UAAU,OAAO,KAAA;AAAA,MACvC;AAGA,MAAA,OAAO,SAAA,CAAU,UAAU,YAAA,CAAa,MAAA;AAAA,IAC1C;AAGA,IAAA,IAAI,YAAA,CAAa,MAAA,KAAW,SAAA,CAAU,MAAA,EAAQ,OAAO,KAAA;AAErD,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,YAAA,CAAa,QAAQ,CAAA,EAAA,EAAK;AAC5C,MAAA,MAAM,WAAA,GAAc,aAAa,CAAC,CAAA;AAClC,MAAA,MAAM,QAAA,GAAW,UAAU,CAAC,CAAA;AAG5B,MAAA,IAAI,WAAA,EAAa,UAAA,CAAW,GAAG,CAAA,EAAG;AAGlC,MAAA,IAAI,WAAA,KAAgB,UAAU,OAAO,KAAA;AAAA,IACvC;AAEA,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAA,CAAc,SAAiB,IAAA,EAAsC;AACnE,IAAA,MAAM,SAAiC,EAAC;AACxC,IAAA,MAAM,YAAA,GAAe,OAAA,CAAQ,KAAA,CAAM,GAAG,CAAA;AACtC,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,KAAA,CAAM,GAAG,CAAA;AAEhC,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,YAAA,CAAa,QAAQ,CAAA,EAAA,EAAK;AAC5C,MAAA,MAAM,WAAA,GAAc,aAAa,CAAC,CAAA;AAClC,MAAA,MAAM,QAAA,GAAW,UAAU,CAAC,CAAA;AAE5B,MAAA,IAAI,WAAA,EAAa,UAAA,CAAW,GAAG,CAAA,IAAK,QAAA,EAAU;AAE5C,QAAA,MAAM,SAAA,GAAY,WAAA,CAAY,KAAA,CAAM,CAAC,CAAA;AACrC,QAAA,MAAA,CAAO,SAAS,CAAA,GAAI,QAAA;AAAA,MACtB,CAAA,MAAA,IAAW,WAAA,EAAa,UAAA,CAAW,GAAG,CAAA,EAAG;AAEvC,QAAA,MAAM,SAAA,GAAY,WAAA,CAAY,KAAA,CAAM,CAAC,CAAA,IAAK,UAAA;AAE1C,QAAA,MAAA,CAAO,SAAS,CAAA,GAAI,SAAA,CAAU,MAAM,CAAC,CAAA,CAAE,KAAK,GAAG,CAAA;AAC/C,QAAA;AAAA,MACF;AAAA,IACF;AAEA,IAAA,OAAO,MAAA;AAAA,EACT;AACF;AA0BO,SAAS,UAAA,GAAyB;AACvC,EAAA,OAAO,IAAI,UAAA,EAAW;AACxB;AAwBO,SAAS,WAAW,OAAA,EAAkD;AAC3E,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,YAAA;AAAA,IACP,OAAA,EAAS;AAAA,MACP,IAAA,EAAM,EAAA;AAAA,MACN,MAAA,EAAQ,KAAA;AAAA,MACR;AAAA;AACF,GACF;AACF;;;AC9TA,IAAM,uCAAuB,IAAI,GAAA,CAAI,CAAC,kBAAA,EAAoB,OAAO,CAAC,CAAA;AAGlE,IAAM,wBAAA,GAA2B,yBAAA;AAGjC,IAAM,4BAAA,GAA+B,SAAA;AAMrC,SAAS,kBAAkB,IAAA,EAAoB;AAE7C,EAAA,IAAI,SAAS,EAAA,EAAI;AACf,IAAA,MAAM,IAAI,MAAM,0CAA0C,CAAA;AAAA,EAC5D;AAGA,EAAA,IAAI,IAAA,CAAK,IAAA,EAAK,KAAM,EAAA,EAAI;AACtB,IAAA,MAAM,IAAI,MAAM,oDAAoD,CAAA;AAAA,EACtE;AAGA,EAAA,IAAI,IAAA,CAAK,UAAA,CAAW,GAAG,CAAA,EAAG;AACxB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,IAAI,CAAA,iCAAA,CAAmC,CAAA;AAAA,EACxE;AAGA,EAAA,IAAI,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA,EAAG;AACpB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,IAAI,CAAA,4BAAA,CAA8B,CAAA;AAAA,EACnE;AAGA,EAAA,IAAI,CAAC,wBAAA,CAAyB,IAAA,CAAK,IAAI,CAAA,EAAG;AACxC,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,IAAI,CAAA,iFAAA,CAAmF,CAAA;AAAA,EACxH;AAGA,EAAA,IAAI,oBAAA,CAAqB,GAAA,CAAI,IAAI,CAAA,EAAG;AAClC,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,IAAI,CAAA,gCAAA,CAAkC,CAAA;AAAA,EACvE;AACF;AAOA,SAAS,iBAAA,CAAkB,WAAmB,cAAA,EAAiD;AAE7F,EAAA,IAAI,cAAc,EAAA,EAAI;AACpB,IAAA,MAAM,IAAI,MAAM,kCAAkC,CAAA;AAAA,EACpD;AAGA,EAAA,IAAI,SAAA,CAAU,IAAA,EAAK,KAAM,EAAA,EAAI;AAC3B,IAAA,MAAM,IAAI,MAAM,4CAA4C,CAAA;AAAA,EAC9D;AAGA,EAAA,IAAI,4BAAA,CAA6B,IAAA,CAAK,SAAS,CAAA,EAAG;AAChD,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,wDAAA,EAA2D,SAAS,CAAA,CAAA,CAAG,CAAA;AAAA,EACzF;AAGA,EAAA,MAAM,SAAA,GAAY,SAAA,CAAU,KAAA,CAAM,GAAG,CAAA;AACrC,EAAA,IAAI,aAAA,GAAkD,cAAA;AAEtD,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,SAAA,CAAU,QAAQ,CAAA,EAAA,EAAK;AACzC,IAAA,MAAM,IAAA,GAAO,UAAU,CAAC,CAAA;AAExB,IAAA,IAAI,CAAC,aAAA,IAAiB,EAAE,IAAA,IAAQ,aAAA,CAAA,EAAgB;AAC9C,MAAA,MAAM,QAAA,GAAW,UAAU,KAAA,CAAM,CAAA,EAAG,IAAI,CAAC,CAAA,CAAE,KAAK,GAAG,CAAA;AACnD,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,QAAQ,CAAA,mCAAA,CAAqC,CAAA;AAAA,IACzE;AAEA,IAAA,MAAM,SAAA,GAAY,cAAc,IAAI,CAAA;AAGpC,IAAA,IAAI,CAAA,GAAI,SAAA,CAAU,MAAA,GAAS,CAAA,EAAG;AAG5B,MAAA,MAAM,YAAA,GAAe,SAAA;AAGrB,MAAA,IAAI,aAAoD,YAAA,CAAa,KAAA;AAGrE,MAAA,IAAI,CAAC,UAAA,IAAc,YAAA,IAAgB,SAAA,IAAa,UAAU,UAAA,EAAY;AACpE,QAAA,MAAM,gBAAiB,SAAA,CAA+C,KAAA;AACtE,QAAA,IAAI,aAAA,EAAe;AACjB,UAAA,UAAA,GAAc,aAAA,CAAmE,KAAA;AAAA,QACnF;AAAA,MACF;AAEA,MAAA,IAAI,CAAC,UAAA,EAAY;AACf,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,4BAAA,EAA+B,SAAA,CAAU,CAAA,GAAI,CAAC,CAAC,CAAA,uBAAA,EAA0B,SAAA,CAAU,KAAA,CAAM,GAAG,CAAA,GAAI,CAAC,EAAE,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA,CAAG,CAAA;AAAA,MACjI;AAEA,MAAA,aAAA,GAAgB,UAAA;AAAA,IAClB;AAAA,EACF;AACF;AAMA,SAAS,mBAAA,CACP,QACA,cAAA,EACM;AAEN,EAAA,IAAI,MAAA,CAAO,WAAW,CAAA,EAAG;AACvB,IAAA,MAAM,IAAI,MAAM,oCAAoC,CAAA;AAAA,EACtD;AAGA,EAAA,MAAM,UAAA,uBAAiB,GAAA,EAAY;AACnC,EAAA,KAAA,MAAW,SAAS,MAAA,EAAQ;AAE1B,IAAA,MAAM,SAAA,GAAY,OAAO,KAAA,KAAU,QAAA,GAAW,QAAQ,KAAA,CAAM,KAAA;AAE5D,IAAA,IAAI,UAAA,CAAW,GAAA,CAAI,SAAS,CAAA,EAAG;AAC7B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iBAAA,EAAoB,SAAS,CAAA,UAAA,CAAY,CAAA;AAAA,IAC3D;AACA,IAAA,UAAA,CAAW,IAAI,SAAS,CAAA;AAGxB,IAAA,iBAAA,CAAkB,WAAW,cAAc,CAAA;AAAA,EAC7C;AACF;AAmFO,IAAM,YAAA,GAAN,MAAM,aAAA,CAA6E;AAAA,EAC/E,QAAA;AAAA,EACA,UAAuC,EAAC;AAAA,EACxC,gBAAmD,EAAC;AAAA,EACpD,gBAAmD,EAAC;AAAA,EAE7D,YAAY,QAAA,EAAe;AACzB,IAAA,IAAA,CAAK,QAAA,GAAW,QAAA;AAChB,IAAA,IAAA,CAAK,UAAA,EAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,KAAA,CACE,IAAA,EACA,MAAA,EACA,OAAA,EACM;AAEN,IAAA,iBAAA,CAAkB,IAAI,CAAA;AAGtB,IAAA,IAAI,IAAA,IAAQ,KAAK,OAAA,EAAS;AACxB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,kBAAA,EAAqB,IAAI,CAAA,8BAAA,CAAgC,CAAA;AAAA,IAC3E;AAGA,IAAA,mBAAA,CAAoB,MAAA,EAAQ,KAAK,QAAQ,CAAA;AAGzC,IAAA,MAAM,WAAA,GAA2B;AAAA,MAC/B;AAAA,KACF;AAGA,IAAA,IAAI,OAAA,EAAS,WAAW,MAAA,EAAW;AACjC,MAAA,WAAA,CAAY,SAAS,OAAA,CAAQ,MAAA;AAAA,IAC/B;AACA,IAAA,IAAI,OAAA,EAAS,WAAW,MAAA,EAAW;AACjC,MAAA,WAAA,CAAY,SAAS,OAAA,CAAQ,MAAA;AAAA,IAC/B;AAEA,IAAA,IAAA,CAAK,OAAA,CAAQ,IAAI,CAAA,GAAI,WAAA;AACrB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,WAAA,CAAY,MAAc,MAAA,EAAiC;AAEzD,IAAA,IAAI,CAAC,IAAA,IAAQ,IAAA,CAAK,IAAA,OAAW,EAAA,EAAI;AAC/B,MAAA,MAAM,IAAI,MAAM,mDAAmD,CAAA;AAAA,IACrE;AAGA,IAAA,IAAI,CAAC,iBAAA,CAAkB,IAAA,CAAK,IAAI,CAAA,EAAG;AACjC,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,2BAAA,EAA8B,IAAI,CAAA,iEAAA,CAAmE,CAAA;AAAA,IACvH;AAGA,IAAA,IAAI,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA,EAAG;AAC5B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,6BAAA,EAAgC,IAAI,CAAA,+CAAA,CAAiD,CAAA;AAAA,IACvG;AAGA,IAAA,IAAI,CAAC,MAAA,IAAU,MAAA,CAAO,gBAAgB,MAAA,IAAa,MAAA,CAAO,gBAAgB,IAAA,EAAM;AAC9E,MAAA,MAAM,IAAI,MAAM,wDAAwD,CAAA;AAAA,IAC1E;AAGA,IAAA,IAAI,OAAO,OAAO,WAAA,KAAgB,QAAA,IAAY,OAAO,WAAA,CAAY,IAAA,OAAW,EAAA,EAAI;AAC9E,MAAA,MAAM,IAAI,MAAM,wCAAwC,CAAA;AAAA,IAC1D;AAEA,IAAA,MAAM,cAAc,MAAA,CAAO,WAAA;AAG3B,IAAA,MAAM,cAAA,GAAiB,IAAA,CAAK,yBAAA,CAA0B,WAAW,CAAA;AAGjE,IAAA,IAAI,CAAC,IAAA,CAAK,YAAA,CAAa,cAAc,CAAA,EAAG;AACtC,MAAA,MAAM,IAAI,MAAM,CAAA,aAAA,EAAgB,WAAW,6CAA6C,cAAA,CAAe,QAAA,EAAU,CAAA,CAAE,CAAA;AAAA,IACrH;AAGA,IAAA,IAAI,OAAO,YAAA,EAAc;AACvB,MAAA,KAAA,MAAW,WAAA,IAAe,OAAO,YAAA,EAAc;AAE7C,QAAA,IAAI,gBAAgB,WAAA,EAAa;AAC/B,UAAA,MAAM,IAAI,KAAA,CAAM,CAAA,aAAA,EAAgB,WAAW,CAAA,gCAAA,CAAkC,CAAA;AAAA,QAC/E;AAGA,QAAA,IAAA,CAAK,0BAA0B,WAAW,CAAA;AAAA,MAC5C;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA,GAAI,MAAA;AAC3B,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,0BAA0B,SAAA,EAA8B;AAC9D,IAAA,MAAM,SAAA,GAAY,SAAA,CAAU,KAAA,CAAM,GAAG,CAAA;AACrC,IAAA,IAAI,gBAAkD,IAAA,CAAK,QAAA;AAE3D,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,SAAA,CAAU,QAAQ,CAAA,EAAA,EAAK;AACzC,MAAA,MAAM,IAAA,GAAO,UAAU,CAAC,CAAA;AAExB,MAAA,IAAI,CAAC,aAAA,IAAiB,EAAE,IAAA,IAAQ,aAAA,CAAA,EAAgB;AAC9C,QAAA,MAAM,QAAA,GAAW,UAAU,KAAA,CAAM,CAAA,EAAG,IAAI,CAAC,CAAA,CAAE,KAAK,GAAG,CAAA;AACnD,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,QAAQ,CAAA,uCAAA,CAAyC,CAAA;AAAA,MAC7E;AAEA,MAAA,MAAM,SAAA,GAAY,cAAc,IAAI,CAAA;AAGpC,MAAA,IAAI,CAAA,KAAM,SAAA,CAAU,MAAA,GAAS,CAAA,EAAG;AAC9B,QAAA,OAAO,SAAA;AAAA,MACT;AAGA,MAAA,MAAM,YAAA,GAAe,SAAA;AACrB,MAAA,IAAI,aAAoD,YAAA,CAAa,KAAA;AAGrE,MAAA,IAAI,CAAC,UAAA,IAAc,YAAA,IAAgB,SAAA,IAAa,UAAU,UAAA,EAAY;AACpE,QAAA,MAAM,gBAAiB,SAAA,CAA+C,KAAA;AACtE,QAAA,IAAI,aAAA,EAAe;AACjB,UAAA,UAAA,GAAc,aAAA,CAAmE,KAAA;AAAA,QACnF;AAAA,MACF;AAEA,MAAA,IAAI,CAAC,UAAA,EAAY;AACf,QAAA,MAAM,IAAI,MAAM,CAAA,+BAAA,EAAkC,SAAA,CAAU,MAAM,CAAA,GAAI,CAAC,EAAE,IAAA,CAAK,GAAG,CAAC,CAAA,uBAAA,EAA0B,SAAA,CAAU,MAAM,CAAA,EAAG,CAAA,GAAI,CAAC,CAAA,CAAE,IAAA,CAAK,GAAG,CAAC,CAAA,CAAA,CAAG,CAAA;AAAA,MACpJ;AAEA,MAAA,aAAA,GAAgB,UAAA;AAAA,IAClB;AAGA,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,SAAS,CAAA,uCAAA,CAAyC,CAAA;AAAA,EAC9E;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAa,SAAA,EAA+B;AAClD,IAAA,MAAM,IAAA,GAAO,UAAU,QAAA,EAAS;AAGhC,IAAA,IAAI,SAAS,QAAA,EAAU;AACrB,MAAA,OAAO,IAAA;AAAA,IACT;AAGA,IAAA,IAAI,SAAS,oBAAA,EAAsB;AACjC,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,SAAA,EAA+B;AACjD,IAAA,MAAM,IAAA,GAAO,UAAU,QAAA,EAAS;AAGhC,IAAA,IAAI,IAAA,CAAK,QAAA,CAAS,IAAI,CAAA,EAAG;AACvB,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,WAAA,CAAY,MAAc,MAAA,EAAiC;AAEzD,IAAA,IAAI,CAAC,IAAA,IAAQ,IAAA,CAAK,IAAA,OAAW,EAAA,EAAI;AAC/B,MAAA,MAAM,IAAI,MAAM,mDAAmD,CAAA;AAAA,IACrE;AAGA,IAAA,IAAI,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA,EAAG;AAC5B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,yBAAA,EAA4B,IAAI,CAAA,8BAAA,CAAgC,CAAA;AAAA,IAClF;AAGA,IAAA,IAAI,EAAE,MAAA,CAAO,WAAA,IAAe,IAAA,CAAK,QAAA,CAAA,EAAW;AAC1C,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,MAAA,CAAO,WAAW,CAAA,uCAAA,CAAyC,CAAA;AAAA,IACvF;AAGA,IAAA,MAAM,oBAAA,GAAuB,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,WAAW,CAAA;AAC7D,IAAA,IAAI,CAAC,IAAA,CAAK,WAAA,CAAY,oBAAoB,CAAA,EAAG;AAC3C,MAAA,MAAM,IAAI,MAAM,CAAA,cAAA,EAAiB,MAAA,CAAO,WAAW,CAAA,6BAAA,EAAgC,oBAAA,CAAqB,QAAA,EAAU,CAAA,CAAE,CAAA;AAAA,IACtH;AAGA,IAAA,IAAI,MAAA,CAAO,cAAc,CAAA,EAAG;AAC1B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,mDAAA,EAAsD,MAAA,CAAO,UAAU,CAAA,CAAE,CAAA;AAAA,IAC3F;AAGA,IAAA,IAAI,OAAO,YAAA,EAAc;AACvB,MAAA,KAAA,MAAW,WAAA,IAAe,OAAO,YAAA,EAAc;AAC7C,QAAA,IAAI,EAAE,WAAA,IAAe,IAAA,CAAK,QAAA,CAAA,EAAW;AACnC,UAAA,MAAM,IAAI,KAAA,CAAM,CAAA,cAAA,EAAiB,WAAW,CAAA,uCAAA,CAAyC,CAAA;AAAA,QACvF;AAAA,MACF;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,aAAA,CAAc,IAAI,CAAA,GAAI,MAAA;AAC3B,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,GAAA,EAAgC;AACvC,IAAA,MAAM,SAA0C,EAAC;AAEjD,IAAA,IAAI,OAAO,GAAA,KAAQ,QAAA,IAAY,GAAA,KAAQ,IAAA,EAAM;AAC3C,MAAA,OAAO;AAAA,QACL,KAAA,EAAO,KAAA;AAAA,QACP,MAAA,EAAQ,CAAC,4BAA4B;AAAA,OACvC;AAAA,IACF;AAEA,IAAA,MAAM,MAAA,GAAS,GAAA;AAGf,IAAA,MAAM,cAAA,GAAiB,CACrB,GAAA,EACA,MAAA,EACA,OAAe,EAAA,KACN;AACT,MAAA,KAAA,MAAW,CAAC,GAAA,EAAK,SAAS,KAAK,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA,EAAG;AACrD,QAAA,MAAM,cAAc,IAAA,GAAO,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,GAAG,CAAA,CAAA,GAAK,GAAA;AAC9C,QAAA,MAAM,KAAA,GAAQ,IAAI,GAAG,CAAA;AAGrB,QAAA,IAAI,UAAU,MAAA,EAAW;AACvB,UAAA,IAAI,CAAC,UAAU,UAAA,EAAY;AACzB,YAAA,MAAA,CAAO,IAAA,CAAK,CAAA,wBAAA,EAA2B,WAAW,CAAA,CAAE,CAAA;AAAA,UACtD;AACA,UAAA;AAAA,QACF;AAGA,QAAA,IAAI;AACF,UAAA,SAAA,CAAU,MAAM,KAAK,CAAA;AAAA,QACvB,SAAS,CAAA,EAAG;AACV,UAAA,MAAM,UAAU,CAAA,YAAa,KAAA,GAAQ,CAAA,CAAE,OAAA,GAAU,OAAO,CAAC,CAAA;AACzD,UAAA,MAAA,CAAO,IAAA,CAAK,EAAE,IAAA,EAAM,WAAA,EAAa,SAAS,CAAA;AAAA,QAC5C;AAAA,MACF;AAAA,IACF,CAAA;AAEA,IAAA,cAAA,CAAe,MAAA,EAAQ,KAAK,QAAQ,CAAA;AAEpC,IAAA,OAAO;AAAA,MACL,KAAA,EAAO,OAAO,MAAA,KAAW,CAAA;AAAA,MACzB;AAAA,KACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAA,GAAqF;AACnF,IAAA,MAAM,YAAA,GAAe;AAAA,MACnB,GAAA,EAAK,EAAE,MAAA,EAAO;AAAA,MACd,aAAA,EAAe,EAAE,MAAA;AAAO,KAC1B;AAEA,IAAA,MAAM,WAAA,GAAc;AAAA,MAClB,GAAG,IAAA,CAAK,QAAA;AAAA,MACR,GAAG;AAAA,KACL;AAEA,IAAA,MAAM,OAAA,GAAU,IAAI,aAAA,CAAa,WAAW,CAAA;AAC5C,IAAA,MAAA,CAAO,MAAA,CAAO,OAAA,CAAQ,OAAA,EAAS,IAAA,CAAK,OAAO,CAAA;AAC3C,IAAA,MAAA,CAAO,MAAA,CAAO,OAAA,CAAQ,aAAA,EAAe,IAAA,CAAK,aAAa,CAAA;AACvD,IAAA,MAAA,CAAO,MAAA,CAAO,OAAA,CAAQ,aAAA,EAAe,IAAA,CAAK,aAAa,CAAA;AAEvD,IAAA,OAAO,OAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAA,GAKE;AACA,IAAA,MAAM,eAAiD,EAAC;AAExD,IAAA,KAAA,MAAW,CAAC,KAAK,SAAS,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,QAAQ,CAAA,EAAG;AAC5D,MAAA,MAAM,IAAA,GAAO,SAAA,CAAU,QAAA,EAAS,CAAE,WAAA,EAAY;AAC9C,MAAA,IAAI,IAAA,GAAO,SAAA;AAEX,MAAA,IAAI,IAAA,KAAS,UAAU,IAAA,GAAO,QAAA;AAAA,WAAA,IACrB,IAAA,KAAS,UAAU,IAAA,GAAO,QAAA;AAAA,WAAA,IAC1B,IAAA,KAAS,WAAW,IAAA,GAAO,SAAA;AAAA,WAAA,IAC3B,IAAA,KAAS,QAAQ,IAAA,GAAO,MAAA;AAAA,WAAA,IACxB,IAAA,KAAS,SAAS,IAAA,GAAO,OAAA;AAAA,WAAA,IACzB,IAAA,KAAS,WAAW,IAAA,GAAO,SAAA;AAAA,WAAA,IAC3B,IAAA,KAAS,SAAS,IAAA,GAAO,OAAA;AAAA,WAAA,IACzB,IAAA,CAAK,QAAA,CAAS,IAAI,CAAA,EAAG,IAAA,GAAO,OAAA;AAAA,WAAA,IAC5B,IAAA,CAAK,UAAA,CAAW,GAAG,CAAA,EAAG,IAAA,GAAO,QAAA;AAAA,WAAA,IAC7B,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA,EAAG,IAAA,GAAO,IAAA;AAAA,WACpC,IAAA,GAAO,IAAA;AAEZ,MAAA,YAAA,CAAa,GAAG,CAAA,GAAI,EAAE,IAAA,EAAK;AAAA,IAC7B;AAEA,IAAA,OAAO;AAAA,MACL,QAAA,EAAU,YAAA;AAAA,MACV,OAAA,EAAS,EAAE,GAAG,IAAA,CAAK,OAAA,EAAQ;AAAA,MAC3B,aAAA,EAAe,EAAE,GAAG,IAAA,CAAK,aAAA,EAAc;AAAA,MACvC,aAAA,EAAe,EAAE,GAAG,IAAA,CAAK,aAAA;AAAc,KACzC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAA,GAKE;AACA,IAAA,OAAO;AAAA,MACL,UAAU,IAAA,CAAK,QAAA;AAAA,MACf,OAAA,EAAS,EAAE,GAAG,IAAA,CAAK,OAAA,EAAQ;AAAA,MAC3B,aAAA,EAAe,EAAE,GAAG,IAAA,CAAK,aAAA,EAAc;AAAA,MACvC,aAAA,EAAe,EAAE,GAAG,IAAA,CAAK,aAAA;AAAc,KACzC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAA,GAAiB;AACf,IAAA,MAAM,KAAA,GAAkB,CAAC,eAAe,CAAA;AAExC,IAAA,KAAA,MAAW,CAAC,KAAK,SAAS,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,QAAQ,CAAA,EAAG;AAC5D,MAAA,MAAM,IAAA,GAAO,UAAU,QAAA,EAAS;AAChC,MAAA,IAAI,OAAA,GAAU,aAAA;AAEd,MAAA,IAAI,IAAA,KAAS,UAAU,OAAA,GAAU,YAAA;AAAA,WAAA,IACxB,IAAA,KAAS,UAAU,OAAA,GAAU,YAAA;AAAA,WAAA,IAC7B,IAAA,KAAS,WAAW,OAAA,GAAU,aAAA;AAAA,WAAA,IAC9B,IAAA,KAAS,QAAQ,OAAA,GAAU,UAAA;AAAA,WAAA,IAC3B,IAAA,KAAS,SAAS,OAAA,GAAU,WAAA;AAAA,WAAA,IAC5B,IAAA,KAAS,WAAW,OAAA,GAAU,aAAA;AAAA,WAAA,IAC9B,IAAA,KAAS,SAAS,OAAA,GAAU,WAAA;AAAA,WAAA,IAC5B,IAAA,CAAK,QAAA,CAAS,IAAI,CAAA,EAAG;AAC5B,QAAA,MAAM,SAAA,GAAY,IAAA,CAAK,OAAA,CAAQ,IAAA,EAAM,EAAE,CAAA;AACvC,QAAA,OAAA,GAAU,aAAa,SAAS,CAAA,GAAA,CAAA;AAAA,MAClC,CAAA,MAAA,IACS,IAAA,CAAK,UAAA,CAAW,MAAM,GAAG,OAAA,GAAU,IAAA;AAAA,WACvC,OAAA,GAAU,KAAK,IAAI,CAAA,EAAA,CAAA;AAExB,MAAA,KAAA,CAAM,IAAA,CAAK,CAAA,EAAA,EAAK,GAAG,CAAA,EAAA,EAAK,OAAO,CAAA,CAAA,CAAG,CAAA;AAAA,IACpC;AAEA,IAAA,KAAA,CAAM,KAAK,IAAI,CAAA;AAGf,IAAA,KAAA,MAAW,CAAC,MAAM,MAAM,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,OAAO,CAAA,EAAG;AACzD,MAAA,MAAM,SAAA,GAAY,IAAA,CAAK,SAAA,CAAU,MAAA,CAAO,MAAM,CAAA;AAC9C,MAAA,KAAA,CAAM,KAAA,CAAM,SAAS,CAAC,CAAA,GAAI,MAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,GAAI;AAAA,UAAA,EAAe,IAAI,MAAM,SAAS,CAAA,CAAA,CAAA;AAAA,IACxF;AAGA,IAAA,KAAA,MAAW,CAAC,MAAM,MAAM,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,aAAa,CAAA,EAAG;AAC/D,MAAA,KAAA,CAAM,KAAA,CAAM,SAAS,CAAC,CAAA,GAAI,MAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,GAAI;AAAA,gBAAA,EAAqB,IAAI,CAAA,GAAA,EAAM,IAAA,CAAK,SAAA,CAAU,MAAM,CAAC,CAAA,CAAA,CAAA;AAAA,IAC3G;AAGA,IAAA,KAAA,MAAW,CAAC,MAAM,MAAM,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,aAAa,CAAA,EAAG;AAC/D,MAAA,KAAA,CAAM,KAAA,CAAM,SAAS,CAAC,CAAA,GAAI,MAAM,KAAA,CAAM,MAAA,GAAS,CAAC,CAAA,GAAI;AAAA,gBAAA,EAAqB,IAAI,CAAA,GAAA,EAAM,IAAA,CAAK,SAAA,CAAU,MAAM,CAAC,CAAA,CAAA,CAAA;AAAA,IAC3G;AAEA,IAAA,OAAO,KAAA,CAAM,KAAK,IAAI,CAAA;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKA,KAAA,GAA2B;AAEzB,IAAA,MAAM,SAAA,GAAY,EAAE,GAAG,IAAA,CAAK,QAAA,EAAS;AACrC,IAAA,MAAM,MAAA,GAAS,IAAI,aAAA,CAAa,SAAS,CAAA;AAGzC,IAAA,KAAA,MAAW,CAAC,MAAM,MAAM,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,OAAO,CAAA,EAAG;AACzD,MAAA,MAAA,CAAO,OAAA,CAAQ,IAAI,CAAA,GAAI,EAAE,QAAQ,CAAC,GAAG,MAAA,CAAO,MAAM,CAAA,EAAE;AAAA,IACtD;AAGA,IAAA,KAAA,MAAW,CAAC,MAAM,MAAM,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,aAAa,CAAA,EAAG;AAC/D,MAAA,MAAA,CAAO,aAAA,CAAc,IAAI,CAAA,GAAI;AAAA,QAC3B,aAAa,MAAA,CAAO,WAAA;AAAA,QACpB,cAAc,MAAA,CAAO,YAAA,GAAe,CAAC,GAAG,MAAA,CAAO,YAAY,CAAA,GAAI;AAAA,OACjE;AAAA,IACF;AAGA,IAAA,KAAA,MAAW,CAAC,MAAM,MAAM,CAAA,IAAK,OAAO,OAAA,CAAQ,IAAA,CAAK,aAAa,CAAA,EAAG;AAC/D,MAAA,MAAA,CAAO,aAAA,CAAc,IAAI,CAAA,GAAI;AAAA,QAC3B,aAAa,MAAA,CAAO,WAAA;AAAA,QACpB,YAAY,MAAA,CAAO,UAAA;AAAA,QACnB,cAAc,MAAA,CAAO,YAAA,GAAe,CAAC,GAAG,MAAA,CAAO,YAAY,CAAA,GAAI;AAAA,OACjE;AAAA,IACF;AAGA,IAAA,IAAI,KAAK,QAAA,EAAU;AACjB,MAAA,MAAA,CAAO,QAAA,GAAW,EAAE,GAAG,IAAA,CAAK,QAAA,EAAS;AAAA,IACvC;AAGA,IAAA,IAAI,KAAK,YAAA,EAAc;AACrB,MAAA,MAAA,CAAO,MAAA,CAAO,KAAK,YAAY,CAAA;AAAA,IACjC;AAEA,IAAA,OAAO,MAAA;AAAA,EACT;AAAA;AAAA,EAGA,QAAA;AAAA;AAAA,EAGQ,YAAA;AAAA;AAAA;AAAA;AAAA,EAKR,MAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,IAAA,EAAoB;AAC9B,IAAA,IAAA,CAAK,QAAA,GAAW,IAAA,CAAK,QAAA,IAAY,EAAC;AAClC,IAAA,IAAA,CAAK,SAAS,WAAA,GAAc,IAAA;AAC5B,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,UAAA,GAAmB;AACzB,IAAA,MAAM,IAAA,GAAO,IAAA;AACb,IAAA,MAAM,QAAA,GAAW,SAAU,GAAA,EAAiD;AAC1E,MAAA,IAAA,CAAK,YAAA,GAAe,GAAA;AAEpB,MAAA,MAAA,CAAO,MAAA,CAAO,UAAU,GAAG,CAAA;AAC3B,MAAA,OAAO,IAAA;AAAA,IACT,CAAA;AACA,IAAA,IAAA,CAAK,MAAA,GAAS,QAAA;AAAA,EAChB;AACF,CAAA;AAgBO,SAAS,YACd,QAAA,EACmB;AACnB,EAAA,OAAO,IAAI,aAAa,QAAQ,CAAA;AAClC;AA0CO,IAAM,gBAAN,MAAqE;AAAA,EACjE,MAAA;AAAA,EACA,UAAA,GAAsB,IAAA;AAAA,EACtB,gBAAA,GAA4B,IAAA;AAAA,EAC5B,oBAAA,GAAgC,IAAA;AAAA,EAEzC,WAAA,CAAY,QAAW,OAAA,EAAyB;AAE9C,IAAA,IAAI,OAAA,EAAS,qBAAqB,MAAA,EAAW;AAC3C,MAAC,IAAA,CAAuC,mBAAmB,OAAA,CAAQ,gBAAA;AAAA,IACrE;AACA,IAAA,IAAI,OAAA,EAAS,yBAAyB,MAAA,EAAW;AAC/C,MAAC,IAAA,CAA2C,uBAAuB,OAAA,CAAQ,oBAAA;AAAA,IAC7E;AACA,IAAA,IAAI,OAAA,EAAS,WAAW,MAAA,EAAW;AACjC,MAAC,IAAA,CAAiC,aAAa,OAAA,CAAQ,MAAA;AAAA,IACzD;AAEA,IAAA,IAAA,CAAK,MAAA,GAAS,MAAA;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,OAAA,EAAwB;AAC7B,IAAC,KAAiC,UAAA,GAAa,OAAA;AAC/C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAA,GAAkB;AAChB,IAAA,OAAO;AAAA,MACL,QAAQ,IAAA,CAAK,MAAA;AAAA,MACb,kBAAkB,IAAA,CAAK,gBAAA;AAAA,MACvB,sBAAsB,IAAA,CAAK,oBAAA;AAAA,MAC3B,YAAY,IAAA,CAAK;AAAA,KACnB;AAAA,EACF;AACF,CAAA;AAMA,IAAM,wBAAA,GAA2B,yBAAA;AAKjC,SAAS,kBAAkB,IAAA,EAAoB;AAC7C,EAAA,IAAI,SAAS,EAAA,EAAI;AACf,IAAA,MAAM,IAAI,MAAM,4BAA4B,CAAA;AAAA,EAC9C;AACA,EAAA,IAAI,IAAA,CAAK,UAAA,CAAW,GAAG,CAAA,EAAG;AACxB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,IAAI,CAAA,2DAAA,CAA6D,CAAA;AAAA,EAClG;AACA,EAAA,IAAI,QAAA,CAAS,IAAA,CAAK,IAAI,CAAA,EAAG;AACvB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,IAAI,CAAA,4BAAA,CAA8B,CAAA;AAAA,EACnE;AACA,EAAA,IAAI,CAAC,wBAAA,CAAyB,IAAA,CAAK,IAAI,CAAA,EAAG;AACxC,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,IAAI,CAAA,8EAAA,CAAgF,CAAA;AAAA,EACrH;AACF;AAKA,SAAS,uBAAA,CAAwB,MAAc,UAAA,EAA2B;AACxE,EAAA,IAAI,eAAe,IAAA,EAAM;AACvB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,IAAI,CAAA,4EAAA,CAA8E,CAAA;AAAA,EAC9G;AACA,EAAA,IAAI,eAAe,MAAA,EAAW;AAC5B,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,IAAI,CAAA,iFAAA,CAAmF,CAAA;AAAA,EACnH;AACA,EAAA,IAAI,OAAO,eAAe,QAAA,EAAU;AAClC,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,IAAI,CAAA,8EAAA,CAAgF,CAAA;AAAA,EAChH;AACA,EAAA,IAAI,OAAO,UAAA,KAAe,QAAA,IAAY,OAAO,eAAe,SAAA,EAAW;AACrE,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,IAAI,CAAA,iFAAA,CAAmF,CAAA;AAAA,EACnH;AACA,EAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,UAAU,CAAA,EAAG;AAC7B,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,IAAI,CAAA,6EAAA,CAA+E,CAAA;AAAA,EAC/G;AACA,EAAA,IAAI,EAAE,sBAAsB,YAAA,CAAA,EAAe;AACzC,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,OAAA,EAAU,IAAI,CAAA,+EAAA,CAAiF,CAAA;AAAA,EACjH;AACF;AAKA,SAAS,sBAAsB,OAAA,EAA8B;AAC3D,EAAA,IAAI,QAAQ,gBAAA,KAAqB,MAAA,IAAa,OAAO,OAAA,CAAQ,qBAAqB,SAAA,EAAW;AAC3F,IAAA,MAAM,IAAI,MAAM,2CAA2C,CAAA;AAAA,EAC7D;AACA,EAAA,IAAI,QAAQ,oBAAA,KAAyB,MAAA,IAAa,OAAO,OAAA,CAAQ,yBAAyB,SAAA,EAAW;AACnG,IAAA,MAAM,IAAI,MAAM,+CAA+C,CAAA;AAAA,EACjE;AACA,EAAA,IAAI,QAAQ,MAAA,KAAW,MAAA,IAAa,OAAO,OAAA,CAAQ,WAAW,SAAA,EAAW;AACvE,IAAA,MAAM,IAAI,MAAM,iCAAiC,CAAA;AAAA,EACnD;AACF;AAkCO,SAAS,YAAA,CACd,QACA,OAAA,EACkB;AAElB,EAAA,IAAI,OAAA,EAAS;AACX,IAAA,qBAAA,CAAsB,OAAO,CAAA;AAAA,EAC/B;AAGA,EAAA,KAAA,MAAW,CAAC,SAAA,EAAW,eAAe,KAAK,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA,EAAG;AACjE,IAAA,iBAAA,CAAkB,SAAS,CAAA;AAC3B,IAAA,uBAAA,CAAwB,WAAW,eAAe,CAAA;AAAA,EACpD;AAEA,EAAA,MAAM,MAAA,GAAS,IAAI,aAAA,CAAc,MAAA,EAAQ,OAAO,CAAA;AAGhD,EAAA,MAAA,CAAO,OAAO,MAAM,CAAA;AACpB,EAAA,KAAA,MAAW,eAAA,IAAmB,MAAA,CAAO,MAAA,CAAO,MAAM,CAAA,EAAG;AACnD,IAAA,MAAA,CAAO,OAAO,eAAe,CAAA;AAC7B,IAAA,IAAI,cAAc,eAAA,EAAiB;AACjC,MAAA,MAAA,CAAO,MAAA,CAAO,gBAAgB,QAAQ,CAAA;AAAA,IACxC;AACA,IAAA,IAAI,aAAa,eAAA,EAAiB;AAChC,MAAA,MAAA,CAAO,MAAA,CAAO,gBAAgB,OAAO,CAAA;AAAA,IACvC;AACA,IAAA,IAAI,mBAAmB,eAAA,EAAiB;AACtC,MAAA,MAAA,CAAO,MAAA,CAAO,gBAAgB,aAAa,CAAA;AAAA,IAC7C;AACA,IAAA,IAAI,mBAAmB,eAAA,EAAiB;AACtC,MAAA,MAAA,CAAO,MAAA,CAAO,gBAAgB,aAAa,CAAA;AAAA,IAC7C;AAAA,EACF;AACA,EAAA,MAAA,CAAO,OAAO,MAAM,CAAA;AAEpB,EAAA,OAAO,MAAA;AACT;;;ACvwBO,IAAM,mBAAN,MAAoF;AAAA,EACjF,SAAA;AAAA,EACA,SAAA;AAAA,EACA,eAAqE,EAAC;AAAA,EACtE,oBAAwC,EAAC;AAAA,EACzC,cAAA,GAAiC,KAAA;AAAA,EACjC,UAAA;AAAA;AAAA,EAGA,OAAA;AAAA,EAER,WAAA,CACE,WACA,OAAA,EACA;AACA,IAAA,IAAA,CAAK,SAAA,GAAY,SAAA;AACjB,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AAAA,EACjB;AAAA,EAEA,SAAA,CACE,WACA,UAAA,EACyB;AACzB,IAAA,IAAA,CAAK,SAAA,GAAY,SAAA;AAEjB,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,MAAM,OAAA,GAAU,IAAI,qBAAA,EAAsB;AAC1C,MAAA,UAAA,CAAW,OAAO,CAAA;AAClB,MAAA,IAAA,CAAK,YAAA,GAAe,QAAQ,UAAA,EAAW;AAAA,IACzC;AAEA,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,eAAA,CACE,YACA,aAAA,EACyB;AAEzB,IAAA,MAAM,IAAI,MAAM,oCAAoC,CAAA;AAAA,EACtD;AAAA,EAEA,OACE,SAAA,EACyB;AACzB,IAAA,MAAM,OAAA,GAAU,IAAI,iBAAA,EAAkB;AACtC,IAAA,MAAM,UAAA,GAAa,UAAU,OAAO,CAAA;AACpC,IAAA,IAAA,CAAK,iBAAA,CAAkB,KAAK,UAAU,CAAA;AACtC,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,MAAM,KAAA,EAAgD;AACpD,IAAA,IAAA,CAAK,cAAA,GAAiB,KAAA;AACtB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,MAAM,OAAA,GAAmG;AACvG,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,OAAA,CAAQ,IAAI,CAAA;AACvC,IAAA,OAAO,OAAA;AAAA,EACT;AAAA,EAEA,MAAM,KAAA,GAAmG;AACvG,IAAA,IAAA,CAAK,UAAA,GAAa,CAAA;AAClB,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,OAAA,EAAQ;AACnC,IAAA,OAAO,OAAA,CAAQ,CAAC,CAAA,IAAK,IAAA;AAAA,EACvB;AAAA,EAEA,MAAM,MAAA,GAAoG;AACxG,IAAA,IAAA,CAAK,UAAA,GAAa,CAAA;AAClB,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,OAAA,EAAQ;AAEnC,IAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iCAAA,EAAoC,OAAA,CAAQ,MAAM,CAAA,CAAE,CAAA;AAAA,IACtE;AAEA,IAAA,OAAO,OAAA,CAAQ,CAAC,CAAA,IAAK,IAAA;AAAA,EACvB;AAAA,EAEA,MAAM,KAAK,CAAA,EAAoG;AAC7G,IAAA,IAAA,CAAK,UAAA,GAAa,CAAA;AAClB,IAAA,OAAO,KAAK,OAAA,EAAQ;AAAA,EACtB;AAAA,EAEA,MAAM,SACJ,cAAA,EACoG;AAEpG,IAAA,IAAA,CAAK,UAAA,GAAa,eAAe,QAAA,GAAW,CAAA;AAC5C,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,OAAA,EAAQ;AAEnC,IAAA,MAAM,MAAA,GAAS,OAAA,CAAQ,MAAA,IAAU,cAAA,CAAe,QAAA;AAChD,IAAA,MAAM,IAAA,GAAO,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAG,eAAe,QAAQ,CAAA;AACrD,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,CAAC,CAAA;AACrC,IAAA,MAAM,cAAA,GAAiB,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,EAAE,EAAA,EAAI,QAAA,CAAS,GAAA,EAAK,CAAC,CAAA,GAAI,EAAA;AAE/E,IAAA,OAAO;AAAA,MACL,IAAA;AAAA,MACA,MAAA;AAAA,MACA;AAAA,KACF;AAAA,EACF;AAAA;AAAA,EAGA,YAAA,GAA0B;AACxB,IAAA,OAAO,IAAA,CAAK,SAAA;AAAA,EACd;AAAA,EAEA,YAAA,GAAmC;AACjC,IAAA,OAAO,IAAA,CAAK,SAAA;AAAA,EACd;AAAA,EAEA,eAAA,GAAwE;AACtE,IAAA,OAAO,IAAA,CAAK,YAAA;AAAA,EACd;AAAA,EAEA,oBAAA,GAA2C;AACzC,IAAA,OAAO,IAAA,CAAK,iBAAA;AAAA,EACd;AAAA,EAEA,QAAA,GAA2B;AACzB,IAAA,OAAO,IAAA,CAAK,cAAA;AAAA,EACd;AAAA,EAEA,QAAA,GAA+B;AAC7B,IAAA,OAAO,IAAA,CAAK,UAAA;AAAA,EACd;AACF;AAKA,IAAM,wBAAN,MAAmE;AAAA,EACzD,UAAgE,EAAC;AAAA,EAEzE,EAAA,CAAqB,OAAU,KAAA,EAA6C;AAC1E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,IAAA,EAAM,OAAO,CAAA;AAC5C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,EAAA,CAAqB,OAAU,KAAA,EAA6C;AAC1E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,IAAA,EAAM,OAAO,CAAA;AAC5C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAA6C;AAC3E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,KAAA,EAAO,OAAO,CAAA;AAC7C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,EAAA,CAAqB,OAAU,KAAA,EAA6C;AAC1E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,IAAA,EAAM,OAAO,CAAA;AAC5C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAA6C;AAC3E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,KAAA,EAAO,OAAO,CAAA;AAC7C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,UAAA,GAAmE;AACjE,IAAA,OAAO,IAAA,CAAK,OAAA;AAAA,EACd;AACF,CAAA;AAKA,IAAM,oBAAN,MAA0E;AAAA,EACxE,EAAA,CAAqB,OAAU,KAAA,EAAkC;AAC/D,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,IAAA,EAAM,OAAO,KAAA,EAAM;AAAA,EAChE;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAAkC;AAChE,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,KAAA,EAAO,OAAO,KAAA,EAAM;AAAA,EACjE;AAAA,EAEA,EAAA,CAAqB,OAAU,KAAA,EAAkC;AAC/D,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,IAAA,EAAM,OAAO,KAAA,EAAM;AAAA,EAChE;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAAkC;AAChE,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,KAAA,EAAO,OAAO,KAAA,EAAM;AAAA,EACjE;AAAA,EAEA,EAAA,CAAqB,OAAU,KAAA,EAAkC;AAC/D,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,IAAA,EAAM,OAAO,KAAA,EAAM;AAAA,EAChE;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAAkC;AAChE,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,KAAA,EAAO,OAAO,KAAA,EAAM;AAAA,EACjE;AAAA,EAEA,OAAO,OAAA,EAA+C;AACpD,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,OAAO,OAAA,EAAQ;AAAA,EAC5D;AAAA,EAEA,MAAM,OAAA,EAA+C;AACnD,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,MAAM,OAAA,EAAQ;AAAA,EAC3D;AAAA,EAEA,IAAI,MAAA,EAA4C;AAC9C,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,OAAO,MAAA,EAAO;AAAA,EAC3D;AACF,CAAA;;;ACtMO,IAAMC,oBAAN,MAAoF;AAAA,EACjF,SAAA;AAAA,EACA,SAAA;AAAA,EACA,eAAqE,EAAC;AAAA,EACtE,oBAAwC,EAAC;AAAA,EACzC,cAAA,GAAiC,KAAA;AAAA,EACjC,UAAA;AAAA;AAAA,EAGA,OAAA;AAAA,EAER,WAAA,CACE,WACA,OAAA,EACA;AACA,IAAA,IAAA,CAAK,SAAA,GAAY,SAAA;AACjB,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AAAA,EACjB;AAAA,EAEA,SAAA,CACE,WACA,UAAA,EACyB;AACzB,IAAA,IAAA,CAAK,SAAA,GAAY,SAAA;AAEjB,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,MAAM,OAAA,GAAU,IAAIC,sBAAAA,EAAsB;AAC1C,MAAA,UAAA,CAAW,OAAO,CAAA;AAClB,MAAA,IAAA,CAAK,YAAA,GAAe,QAAQ,UAAA,EAAW;AAAA,IACzC;AAEA,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,eAAA,CACE,YACA,aAAA,EACyB;AAEzB,IAAA,MAAM,IAAI,MAAM,oCAAoC,CAAA;AAAA,EACtD;AAAA,EAEA,OACE,SAAA,EACyB;AACzB,IAAA,MAAM,OAAA,GAAU,IAAIC,kBAAAA,EAAkB;AACtC,IAAA,MAAM,UAAA,GAAa,UAAU,OAAO,CAAA;AACpC,IAAA,IAAA,CAAK,iBAAA,CAAkB,KAAK,UAAU,CAAA;AACtC,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,MAAM,KAAA,EAAgD;AACpD,IAAA,IAAA,CAAK,cAAA,GAAiB,KAAA;AACtB,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,MAAM,OAAA,GAAmG;AACvG,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,OAAA,CAAQ,IAAI,CAAA;AACvC,IAAA,OAAO,OAAA;AAAA,EACT;AAAA,EAEA,MAAM,KAAA,GAAmG;AACvG,IAAA,IAAA,CAAK,UAAA,GAAa,CAAA;AAClB,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,OAAA,EAAQ;AACnC,IAAA,OAAO,OAAA,CAAQ,CAAC,CAAA,IAAK,IAAA;AAAA,EACvB;AAAA,EAEA,MAAM,MAAA,GAAoG;AACxG,IAAA,IAAA,CAAK,UAAA,GAAa,CAAA;AAClB,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,OAAA,EAAQ;AAEnC,IAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iCAAA,EAAoC,OAAA,CAAQ,MAAM,CAAA,CAAE,CAAA;AAAA,IACtE;AAEA,IAAA,OAAO,OAAA,CAAQ,CAAC,CAAA,IAAK,IAAA;AAAA,EACvB;AAAA,EAEA,MAAM,KAAK,CAAA,EAAoG;AAC7G,IAAA,IAAA,CAAK,UAAA,GAAa,CAAA;AAClB,IAAA,OAAO,KAAK,OAAA,EAAQ;AAAA,EACtB;AAAA,EAEA,MAAM,SACJ,cAAA,EACoG;AAEpG,IAAA,IAAA,CAAK,UAAA,GAAa,eAAe,QAAA,GAAW,CAAA;AAC5C,IAAA,MAAM,OAAA,GAAU,MAAM,IAAA,CAAK,OAAA,EAAQ;AAEnC,IAAA,MAAM,MAAA,GAAS,OAAA,CAAQ,MAAA,IAAU,cAAA,CAAe,QAAA;AAChD,IAAA,MAAM,IAAA,GAAO,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAG,eAAe,QAAQ,CAAA;AACrD,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,CAAC,CAAA;AACrC,IAAA,MAAM,cAAA,GAAiB,QAAA,GAAW,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,EAAE,EAAA,EAAI,QAAA,CAAS,GAAA,EAAK,CAAC,CAAA,GAAI,EAAA;AAE/E,IAAA,OAAO;AAAA,MACL,IAAA;AAAA,MACA,MAAA;AAAA,MACA;AAAA,KACF;AAAA,EACF;AAAA;AAAA,EAGA,YAAA,GAA0B;AACxB,IAAA,OAAO,IAAA,CAAK,SAAA;AAAA,EACd;AAAA,EAEA,YAAA,GAAmC;AACjC,IAAA,OAAO,IAAA,CAAK,SAAA;AAAA,EACd;AAAA,EAEA,eAAA,GAAwE;AACtE,IAAA,OAAO,IAAA,CAAK,YAAA;AAAA,EACd;AAAA,EAEA,QAAA,GAA2B;AACzB,IAAA,OAAO,IAAA,CAAK,cAAA;AAAA,EACd;AAAA,EAEA,QAAA,GAA+B;AAC7B,IAAA,OAAO,IAAA,CAAK,UAAA;AAAA,EACd;AAAA,EAEA,oBAAA,GAA2C;AACzC,IAAA,OAAO,IAAA,CAAK,iBAAA;AAAA,EACd;AACF,CAAA;AAKA,IAAMD,yBAAN,MAAmE;AAAA,EACzD,UAAgE,EAAC;AAAA,EAEzE,EAAA,CAAqB,OAAU,KAAA,EAA6C;AAC1E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,IAAA,EAAM,OAAO,CAAA;AAC5C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,EAAA,CAAqB,OAAU,KAAA,EAA6C;AAC1E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,IAAA,EAAM,OAAO,CAAA;AAC5C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAA6C;AAC3E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,KAAA,EAAO,OAAO,CAAA;AAC7C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,EAAA,CAAqB,OAAU,KAAA,EAA6C;AAC1E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,IAAA,EAAM,OAAO,CAAA;AAC5C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAA6C;AAC3E,IAAA,IAAA,CAAK,QAAQ,IAAA,CAAK,EAAE,OAAO,EAAA,EAAI,KAAA,EAAO,OAAO,CAAA;AAC7C,IAAA,OAAO,IAAA;AAAA,EACT;AAAA,EAEA,UAAA,GAAmE;AACjE,IAAA,OAAO,IAAA,CAAK,OAAA;AAAA,EACd;AACF,CAAA;AAKA,IAAMC,qBAAN,MAA0E;AAAA,EACxE,EAAA,CAAqB,OAAU,KAAA,EAAkC;AAC/D,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,IAAA,EAAM,OAAO,KAAA,EAAM;AAAA,EAChE;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAAkC;AAChE,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,KAAA,EAAO,OAAO,KAAA,EAAM;AAAA,EACjE;AAAA,EAEA,EAAA,CAAqB,OAAU,KAAA,EAAkC;AAC/D,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,IAAA,EAAM,OAAO,KAAA,EAAM;AAAA,EAChE;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAAkC;AAChE,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,KAAA,EAAO,OAAO,KAAA,EAAM;AAAA,EACjE;AAAA,EAEA,EAAA,CAAqB,OAAU,KAAA,EAAkC;AAC/D,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,IAAA,EAAM,OAAO,KAAA,EAAM;AAAA,EAChE;AAAA,EAEA,GAAA,CAAsB,OAAU,KAAA,EAAkC;AAChE,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,KAAA,EAAO,OAAO,KAAA,EAAM;AAAA,EACjE;AAAA,EAEA,OAAO,OAAA,EAA+C;AACpD,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,OAAO,OAAA,EAAQ;AAAA,EAC5D;AAAA,EAEA,MAAM,OAAA,EAA+C;AACnD,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,MAAM,OAAA,EAAQ;AAAA,EAC3D;AAAA,EAEA,IAAI,MAAA,EAA4C;AAC9C,IAAA,OAAO,EAAE,MAAA,EAAQ,kBAAA,EAAoB,IAAA,EAAM,OAAO,MAAA,EAAO;AAAA,EAC3D;AACF,CAAA;;;ACrXO,IAAM,iBAAN,MAAqB;AAAA,EAClB,OAAA;AAAA,EAER,YAAY,OAAA,EAAyB;AACnC,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IACJ,EAAA,EACyC;AACzC,IAAA,OAAO,IAAA,CAAK,OAAA,CAAQ,WAAA,CAAY,EAAY,CAAA;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAgC,SAAA,EAA+C;AAE7E,IAAA,MAAM,OAAA,GAAU,OAAOC,MAAAA,KAAuC;AAC5D,MAAA,MAAM,OAAA,GAAwB;AAAA,QAC5B,SAAA,EAAWA,OAAM,YAAA,EAAa;AAAA,QAC9B,YAAA,EAAcA,OAAM,eAAA,EAAgB;AAAA,QACpC,OAAA,EAASA,OAAM,oBAAA,EAAqB;AAAA,QACpC,KAAA,EAAOA,OAAM,QAAA,EAAS;AAAA,QACtB,KAAA,EAAOA,OAAM,QAAA;AAAS,OACxB;AAEA,MAAA,OAAO,IAAA,CAAK,OAAA,CAAQ,cAAA,CAAe,SAAA,EAAW,OAAO,CAAA;AAAA,IACvD,CAAA;AAEA,IAAA,OAAO,IAAIH,iBAAAA,CAAiB,SAAA,EAAW,OAAO,CAAA;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAA,CACE,WACA,EAAA,EACsB;AAEtB,IAAA,IAAI,OAAO,OAAO,QAAA,EAAU;AAC1B,MAAA,OAAO,IAAA;AAAA,IACT;AAGA,IAAA,IAAI,EAAA,KAAO,EAAA,IAAM,EAAA,CAAG,IAAA,OAAW,EAAA,EAAI;AACjC,MAAA,OAAO,IAAA;AAAA,IACT;AAGA,IAAA,MAAMI,iBAAAA,GAAmB,kBAAA;AACzB,IAAA,IAAI,CAACA,iBAAAA,CAAiB,IAAA,CAAK,EAAE,CAAA,EAAG;AAC9B,MAAA,OAAO,IAAA;AAAA,IACT;AAGA,IAAA,MAAMC,cAAAA,GAAgB,GAAA;AACtB,IAAA,IAAI,EAAA,CAAG,SAASA,cAAAA,EAAe;AAC7B,MAAA,OAAO,IAAA;AAAA,IACT;AAGA,IAAA,OAAO,EAAA;AAAA,EACT;AACF;AASO,IAAM,kBAAN,MAAgD;AAAA,EAC7C,SAAA,uBAAgB,GAAA,EAA8E;AAAA,EAEtG,MAAM,YAAY,EAAA,EAAqD;AACrE,IAAA,OAAO,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,EAAE,CAAA,IAAK,IAAA;AAAA,EACnC;AAAA,EAEA,MAAM,cAAA,CACJ,SAAA,EACA,OAAA,EACkF;AAElF,IAAA,IAAI,UAAmF,EAAC;AAExF,IAAA,KAAA,MAAW,CAAC,EAAA,EAAI,GAAG,CAAA,IAAK,KAAK,SAAA,EAAW;AACtC,MAAA,IAAI,EAAA,CAAG,UAAA,CAAW,CAAA,EAAG,SAAS,GAAG,CAAA,EAAG;AAClC,QAAA,OAAA,CAAQ,KAAK,GAAG,CAAA;AAAA,MAClB;AAAA,IACF;AAGA,IAAA,IAAI,OAAA,EAAS,YAAA,IAAgB,OAAA,CAAQ,YAAA,CAAa,SAAS,CAAA,EAAG;AAC5D,MAAA,OAAA,GAAU,OAAA,CAAQ,MAAA,CAAO,CAAC,GAAA,KAAQ;AAChC,QAAA,OAAO,OAAA,CAAQ,YAAA,CAAc,KAAA,CAAM,CAAC,MAAA,KAAW;AAC7C,UAAA,MAAM,KAAA,GAAQ,GAAA,CAAI,MAAA,CAAO,KAAK,CAAA;AAC9B,UAAA,OAAO,KAAK,cAAA,CAAe,KAAA,EAAO,MAAA,CAAO,EAAA,EAAI,OAAO,KAAK,CAAA;AAAA,QAC3D,CAAC,CAAA;AAAA,MACH,CAAC,CAAA;AAAA,IACH;AAGA,IAAA,IAAI,OAAA,EAAS,OAAA,IAAW,OAAA,CAAQ,OAAA,CAAQ,SAAS,CAAA,EAAG;AAClD,MAAA,KAAA,MAAW,MAAA,IAAU,QAAQ,OAAA,EAAS;AACpC,QAAA,OAAA,GAAU,OAAA,CAAQ,OAAO,CAAC,GAAA,KAAQ,KAAK,wBAAA,CAAyB,GAAA,EAAK,MAAM,CAAC,CAAA;AAAA,MAC9E;AAAA,IACF;AAGA,IAAA,MAAM,KAAA,GAAQ,SAAS,KAAA,IAAS,KAAA;AAChC,IAAA,OAAA,CAAQ,IAAA,CAAK,CAAC,CAAA,EAAG,CAAA,KAAM;AACrB,MAAA,IAAI,UAAU,KAAA,EAAO;AACnB,QAAA,OAAO,CAAA,CAAE,gBAAgB,CAAA,CAAE,aAAA;AAAA,MAC7B,CAAA,MAAO;AACL,QAAA,OAAO,CAAA,CAAE,gBAAgB,CAAA,CAAE,aAAA;AAAA,MAC7B;AAAA,IACF,CAAC,CAAA;AAGD,IAAA,IAAI,OAAA,EAAS,UAAU,MAAA,EAAW;AAChC,MAAA,OAAA,GAAU,OAAA,CAAQ,KAAA,CAAM,CAAA,EAAG,OAAA,CAAQ,KAAK,CAAA;AAAA,IAC1C;AAEA,IAAA,OAAO,OAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,cAAA,CAAe,KAAA,EAAgB,EAAA,EAAY,MAAA,EAA0B;AAC3E,IAAA,QAAQ,EAAA;AAAI,MACV,KAAK,IAAA;AACH,QAAA,OAAO,KAAA,KAAU,MAAA;AAAA,MACnB,KAAK,KAAA;AACH,QAAA,OAAO,KAAA,KAAU,MAAA;AAAA,MACnB,KAAK,IAAA;AACH,QAAA,OAAQ,KAAA,GAAoB,MAAA;AAAA,MAC9B,KAAK,KAAA;AACH,QAAA,OAAQ,KAAA,IAAqB,MAAA;AAAA,MAC/B,KAAK,IAAA;AACH,QAAA,OAAQ,KAAA,GAAoB,MAAA;AAAA,MAC9B,KAAK,KAAA;AACH,QAAA,OAAQ,KAAA,IAAqB,MAAA;AAAA,MAC/B;AACE,QAAA,OAAO,KAAA;AAAA;AACX,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,wBAAA,CAAyB,KAA8B,MAAA,EAAmC;AAChG,IAAA,MAAM,SAAA,GAAY,MAAA;AAQlB,IAAA,QAAQ,UAAU,IAAA;AAAM,MACtB,KAAK,IAAA;AACH,QAAA,OAAO,GAAA,CAAI,SAAA,CAAU,KAAM,CAAA,KAAM,SAAA,CAAU,KAAA;AAAA,MAC7C,KAAK,KAAA;AACH,QAAA,OAAO,GAAA,CAAI,SAAA,CAAU,KAAM,CAAA,KAAM,SAAA,CAAU,KAAA;AAAA,MAC7C,KAAK,IAAA;AACH,QAAA,OAAQ,GAAA,CAAI,SAAA,CAAU,KAAM,CAAA,GAAgB,SAAA,CAAU,KAAA;AAAA,MACxD,KAAK,KAAA;AACH,QAAA,OAAQ,GAAA,CAAI,SAAA,CAAU,KAAM,CAAA,IAAiB,SAAA,CAAU,KAAA;AAAA,MACzD,KAAK,IAAA;AACH,QAAA,OAAQ,GAAA,CAAI,SAAA,CAAU,KAAM,CAAA,GAAgB,SAAA,CAAU,KAAA;AAAA,MACxD,KAAK,KAAA;AACH,QAAA,OAAQ,GAAA,CAAI,SAAA,CAAU,KAAM,CAAA,IAAiB,SAAA,CAAU,KAAA;AAAA,MACzD,KAAK,KAAA;AACH,QAAA,OAAO,SAAA,CAAU,QAAS,KAAA,CAAM,CAAC,MAAM,IAAA,CAAK,wBAAA,CAAyB,GAAA,EAAK,CAAC,CAAC,CAAA;AAAA,MAC9E,KAAK,IAAA;AACH,QAAA,OAAO,SAAA,CAAU,QAAS,IAAA,CAAK,CAAC,MAAM,IAAA,CAAK,wBAAA,CAAyB,GAAA,EAAK,CAAC,CAAC,CAAA;AAAA,MAC7E,KAAK,KAAA;AACH,QAAA,OAAO,CAAC,IAAA,CAAK,wBAAA,CAAyB,GAAA,EAAK,UAAU,MAAO,CAAA;AAAA,MAC9D;AACE,QAAA,OAAO,IAAA;AAAA;AACX,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,WAAA,CAAY,IAAY,GAAA,EAAuE;AAC7F,IAAA,IAAA,CAAK,SAAA,CAAU,GAAA,CAAI,EAAA,EAAI,GAAG,CAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,KAAA,GAAQ;AACN,IAAA,IAAA,CAAK,UAAU,KAAA,EAAM;AAAA,EACvB;AACF;;;AC3OA,IAAM,aAAA,GAAgB,CAAC,KAAA,EAAO,eAAe,CAAA;AAKtC,IAAM,cAAA,GAAN,cAA6B,cAAA,CAAe;AAAA,EACvC,OAAA;AAAA,EAEV,YAAY,OAAA,EAAkB;AAC5B,IAAA,KAAA,CAAM,OAAO,CAAA;AACb,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,IACJ,EAAA,EACyC;AAEzC,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,kBAAA,CAAmB,EAAE,CAAA;AAC5C,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,OAAA,CAAQ,WAAA,CAAY,WAAW,EAAE,CAAA;AAClD,IAAA,OAAO,GAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,MAAA,CACJ,SAAA,EACA,QAAA,EACwB;AAExB,IAAA,IAAA,CAAK,sBAAA,CAAuB,UAAU,QAAQ,CAAA;AAG9C,IAAA,IAAA,CAAK,uBAAuB,QAAQ,CAAA;AAGpC,IAAA,MAAM,EAAA,GAAK,IAAA,CAAK,UAAA,CAAW,SAAS,CAAA;AAGpC,IAAA,MAAM,YAAA,GAAe;AAAA,MACnB,GAAG,QAAA;AAAA,MACH,GAAA,EAAK,EAAA;AAAA,MACL,aAAA,EAAe,KAAK,GAAA;AAAI,KAC1B;AAGA,IAAA,IAAA,CAAK,OAAA,CAAQ,YAAA,CAAa,SAAA,EAAW,EAAA,EAAI,YAAY,CAAA;AAErD,IAAA,OAAO,EAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,KAAA,CACJ,EAAA,EACA,MAAA,EACe;AAEf,IAAA,IAAI,MAAA,CAAO,IAAA,CAAK,MAAM,CAAA,CAAE,WAAW,CAAA,EAAG;AACpC,MAAA,MAAM,IAAI,MAAM,+CAA+C,CAAA;AAAA,IACjE;AAGA,IAAA,IAAA,CAAK,sBAAA,CAAuB,QAAQ,OAAO,CAAA;AAG3C,IAAA,IAAA,CAAK,uBAAuB,MAAM,CAAA;AAGlC,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,kBAAA,CAAmB,EAAE,CAAA;AAC5C,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,OAAA,CAAQ,WAAA,CAAY,WAAW,EAAE,CAAA;AAE1D,IAAA,IAAI,CAAC,WAAA,EAAa;AAChB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iBAAA,EAAoB,EAAE,CAAA,UAAA,CAAY,CAAA;AAAA,IACpD;AAGA,IAAA,MAAM,UAAA,GAAa;AAAA,MACjB,GAAG,WAAA;AAAA,MACH,GAAG;AAAA,KACL;AAGA,IAAA,IAAA,CAAK,OAAA,CAAQ,YAAA,CAAa,SAAA,EAAW,EAAA,EAAI,UAAU,CAAA;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,OAAA,CACJ,EAAA,EACA,QAAA,EACe;AAEf,IAAA,IAAA,CAAK,sBAAA,CAAuB,UAAU,SAAS,CAAA;AAG/C,IAAA,IAAA,CAAK,uBAAuB,QAAQ,CAAA;AAGpC,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,kBAAA,CAAmB,EAAE,CAAA;AAC5C,IAAA,MAAM,WAAA,GAAc,IAAA,CAAK,OAAA,CAAQ,WAAA,CAAY,WAAW,EAAE,CAAA;AAE1D,IAAA,IAAI,CAAC,WAAA,EAAa;AAChB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,iBAAA,EAAoB,EAAE,CAAA,UAAA,CAAY,CAAA;AAAA,IACpD;AAGA,IAAA,MAAM,MAAA,GAAS;AAAA,MACb,GAAG,QAAA;AAAA,MACH,KAAK,WAAA,CAAY,GAAA;AAAA,MACjB,eAAe,WAAA,CAAY;AAAA,KAC7B;AAGA,IAAA,IAAA,CAAK,OAAA,CAAQ,YAAA,CAAa,SAAA,EAAW,EAAA,EAAI,MAAM,CAAA;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,OAAO,EAAA,EAA+B;AAC1C,IAAA,MAAM,SAAA,GAAY,IAAA,CAAK,kBAAA,CAAmB,EAAE,CAAA;AAC5C,IAAA,IAAA,CAAK,OAAA,CAAQ,cAAA,CAAe,SAAA,EAAW,EAAE,CAAA;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKQ,sBAAA,CACN,UACA,SAAA,EACM;AACN,IAAA,KAAA,MAAW,SAAS,aAAA,EAAe;AACjC,MAAA,IAAI,SAAS,QAAA,EAAU;AACrB,QAAA,MAAM,IAAI,KAAA;AAAA,UACR,iBAAiB,KAAK,CAAA,qEAAA;AAAA,SACxB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAAuB,QAAA,EAAyC;AACtE,IAAA,KAAA,MAAW,CAAC,GAAA,EAAK,KAAK,KAAK,MAAA,CAAO,OAAA,CAAQ,QAAQ,CAAA,EAAG;AACnD,MAAA,IAAA,CAAK,aAAA,CAAc,OAAO,GAAG,CAAA;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAA,CAAc,OAAgB,IAAA,EAAoB;AAExD,IAAA,IAAI,UAAU,MAAA,EAAW;AACvB,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,qBAAqB,IAAI,CAAA,0DAAA;AAAA,OAC3B;AAAA,IACF;AAGA,IAAA,IAAI,OAAO,KAAA,KAAU,QAAA,IAAY,KAAA,CAAM,KAAK,CAAA,EAAG;AAC7C,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,qBAAqB,IAAI,CAAA,sBAAA;AAAA,OAC3B;AAAA,IACF;AAGA,IAAA,IAAI,KAAA,KAAU,QAAA,IAAY,KAAA,KAAU,CAAA,QAAA,EAAW;AAC7C,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,qBAAqB,IAAI,CAAA,2BAAA;AAAA,OAC3B;AAAA,IACF;AAGA,IAAA,IAAI,OAAO,UAAU,UAAA,EAAY;AAC/B,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,qBAAqB,IAAI,CAAA,2BAAA;AAAA,OAC3B;AAAA,IACF;AAGA,IAAA,IAAI,OAAO,UAAU,QAAA,EAAU;AAC7B,MAAA,MAAM,IAAI,KAAA;AAAA,QACR,qBAAqB,IAAI,CAAA,yBAAA;AAAA,OAC3B;AAAA,IACF;AAGA,IAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;AACxB,MAAA,KAAA,CAAM,OAAA,CAAQ,CAAC,IAAA,EAAM,KAAA,KAAU;AAC7B,QAAA,IAAA,CAAK,cAAc,IAAA,EAAM,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,KAAK,CAAA,CAAA,CAAG,CAAA;AAAA,MAC9C,CAAC,CAAA;AAAA,IACH;AAGA,IAAA,IAAI,UAAU,IAAA,IAAQ,OAAO,UAAU,QAAA,IAAY,KAAA,CAAM,gBAAgB,MAAA,EAAQ;AAC/E,MAAA,KAAA,MAAW,CAAC,GAAA,EAAK,GAAG,KAAK,MAAA,CAAO,OAAA,CAAQ,KAAK,CAAA,EAAG;AAC9C,QAAA,IAAA,CAAK,cAAc,GAAA,EAAK,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,GAAG,CAAA,CAAE,CAAA;AAAA,MAC1C;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,WAAqC,SAAA,EAAqC;AAEhF,IAAA,MAAM,WAAA,GAAc,IAAI,UAAA,CAAW,EAAE,CAAA;AACrC,IAAA,MAAA,CAAO,gBAAgB,WAAW,CAAA;AAGlC,IAAA,MAAM,MAAA,GAAS,IAAA,CAAK,sBAAA,CAAuB,WAAA,CAAY,MAAM,CAAA;AAG7D,IAAA,MAAM,EAAA,GAAK,CAAA,EAAG,SAAS,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA;AAEjC,IAAA,OAAO,EAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAAuB,MAAA,EAA6B;AAC1D,IAAA,MAAM,KAAA,GAAQ,IAAI,UAAA,CAAW,MAAM,CAAA;AACnC,IAAA,IAAI,MAAA,GAAS,EAAA;AACb,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,KAAA,CAAM,QAAQ,CAAA,EAAA,EAAK;AACrC,MAAA,MAAA,IAAU,MAAA,CAAO,YAAA,CAAa,KAAA,CAAM,CAAC,CAAC,CAAA;AAAA,IACxC;AAEA,IAAA,OAAO,IAAA,CAAK,MAAM,CAAA,CACf,OAAA,CAAQ,KAAA,EAAO,GAAG,CAAA,CAClB,OAAA,CAAQ,KAAA,EAAO,GAAG,CAAA,CAClB,OAAA,CAAQ,MAAM,EAAE,CAAA;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAmB,EAAA,EAAoB;AAC7C,IAAA,MAAM,KAAA,GAAQ,EAAA,CAAG,KAAA,CAAM,GAAG,CAAA;AAC1B,IAAA,IAAI,KAAA,CAAM,SAAS,CAAA,EAAG;AACpB,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,4BAAA,EAA+B,EAAE,CAAA,CAAE,CAAA;AAAA,IACrD;AACA,IAAA,OAAO,MAAM,CAAC,CAAA;AAAA,EAChB;AACF;;;AC5QO,IAAM,qBAAN,MAAmD;AAAA;AAAA;AAAA;AAAA,EAIxD,MAAM,IACJ,EAAA,EACyC;AAGzC,IAAA,MAAM,IAAI,MAAM,qDAAqD,CAAA;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA,EAKA,MACE,SAAA,EACyB;AAGzB,IAAA,OAAO,IAAIL,iBAAAA,CAAiB,SAAA,EAAW,OAAOG,MAAAA,KAAU;AACtD,MAAA,MAAM,IAAI,MAAM,gDAAgD,CAAA;AAAA,IAClE,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAA,CACE,WACA,EAAA,EACsB;AAGtB,IAAA,MAAM,IAAI,MAAM,6DAA6D,CAAA;AAAA,EAC/E;AAAA;AAAA;AAAA;AAAA,EAKA,MAAA,GAAS;AAAA,IACP,GAAA,EAAK,OAAO,EAAA,KAOC;AACX,MAAA,MAAM,IAAI,MAAM,4DAA4D,CAAA;AAAA,IAC9E,CAAA;AAAA,IACA,KAAA,EAAO,CAAC,SAAA,KAA4E;AAClF,MAAA,OAAO,IAAIH,iBAAAA,CAAiB,SAAA,EAAW,OAAOG,MAAAA,KAAU;AACtD,QAAA,MAAM,IAAI,MAAM,gDAAgD,CAAA;AAAA,MAClE,CAAC,CAAA;AAAA,IACH;AAAA,GACF;AACF;AASO,IAAM,WAAN,MAA+B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKpC,MAAM,eAAA,GAAgD;AAGpD,IAAA,MAAM,IAAI,MAAM,uDAAuD,CAAA;AAAA,EACzE;AACF;AASO,IAAM,oBAAN,MAAiD;AAAA;AAAA;AAAA;AAAA,EAItD,MAAM,OAAO,SAAA,EAA8C;AAGzD,IAAA,MAAM,IAAI,MAAM,uDAAuD,CAAA;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,SAAA,EAKR;AAGR,IAAA,MAAM,IAAI,MAAM,4DAA4D,CAAA;AAAA,EAC9E;AACF;AASO,IAAM,eAAN,MAAuC;AAAA;AAAA,EAE5C,EAAA;AAAA;AAAA,EAGA,IAAA;AAAA;AAAA,EAGA,OAAA;AAAA,EAEA,WAAA,CACE,EAAA,EACA,IAAA,EACA,OAAA,EACA;AACA,IAAA,IAAA,CAAK,EAAA,GAAK,EAAA,IAAM,IAAI,kBAAA,EAAmB;AACvC,IAAA,IAAA,CAAK,IAAA,GAAO,IAAA,IAAQ,IAAI,QAAA,EAAS;AACjC,IAAA,IAAA,CAAK,OAAA,GAAU,OAAA,IAAW,IAAI,iBAAA,EAAkB;AAAA,EAClD;AACF;AAUO,SAAS,cAAA,CACd,EAAA,EACA,IAAA,EACA,OAAA,EACU;AACV,EAAA,OAAO,IAAI,YAAA,CAAa,EAAA,EAAI,IAAA,EAAM,OAAO,CAAA;AAC3C;AAMO,SAAS,qBAAA,GAAkC;AAChD,EAAA,OAAO,IAAI,YAAA,EAAa;AAC1B;;;ACzIO,SAAS,iBAAA,CACd,EAAA,EACA,IAAA,EACA,OAAA,EACA,SAAA,EACa;AACb,EAAA,OAAO;AAAA,IACL,EAAA;AAAA,IACA,IAAA;AAAA,IACA,OAAA;AAAA,IACA;AAAA,GACF;AACF;AAYO,SAAS,oBAAoB,GAAA,EAAkC;AACpE,EAAA,IAAI,CAAC,GAAA,IAAO,OAAO,GAAA,KAAQ,QAAA,EAAU;AACnC,IAAA,MAAM,IAAI,MAAM,+BAA+B,CAAA;AAAA,EACjD;AAEA,EAAA,MAAM,WAAA,GAAc,GAAA;AAEpB,EAAA,IAAI,CAAC,WAAA,CAAY,EAAA,IAAM,OAAO,WAAA,CAAY,OAAO,QAAA,EAAU;AACzD,IAAA,MAAM,IAAI,MAAM,yDAAyD,CAAA;AAAA,EAC3E;AAEA,EAAA,IAAI,CAAC,WAAA,CAAY,IAAA,IAAQ,OAAO,WAAA,CAAY,SAAS,QAAA,EAAU;AAC7D,IAAA,MAAM,IAAI,MAAM,2DAA2D,CAAA;AAAA,EAC7E;AAEA,EAAA,IAAI,CAAC,WAAA,CAAY,OAAA,IAAW,OAAO,WAAA,CAAY,YAAY,QAAA,EAAU;AACnE,IAAA,MAAM,IAAI,MAAM,6DAA6D,CAAA;AAAA,EAC/E;AAEA,EAAA,IAAI,CAAC,WAAA,CAAY,SAAA,IAAa,OAAO,WAAA,CAAY,cAAc,QAAA,EAAU;AACvE,IAAA,MAAM,IAAI,MAAM,2DAA2D,CAAA;AAAA,EAC7E;AAEA,EAAA,OAAO,IAAA;AACT;AAOO,SAAS,uBAAuB,EAAA,EAAmC;AACxE,EAAA,IAAI,CAAC,EAAA,IAAM,OAAO,EAAA,KAAO,QAAA,EAAU;AACjC,IAAA,MAAM,IAAI,MAAM,kCAAkC,CAAA;AAAA,EACpD;AAEA,EAAA,MAAM,QAAA,GAAW,EAAA;AAGjB,EAAA,IAAI,OAAO,QAAA,CAAS,GAAA,KAAQ,UAAA,EAAY;AACtC,IAAA,MAAM,IAAI,MAAM,uCAAuC,CAAA;AAAA,EACzD;AAEA,EAAA,IAAI,OAAO,QAAA,CAAS,KAAA,KAAU,UAAA,EAAY;AACxC,IAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAAA,EAC3D;AAEA,EAAA,IAAI,OAAO,QAAA,CAAS,WAAA,KAAgB,UAAA,EAAY;AAC9C,IAAA,MAAM,IAAI,MAAM,+CAA+C,CAAA;AAAA,EACjE;AAGA,EAAA,IAAI,OAAO,QAAA,CAAS,MAAA,KAAW,UAAA,EAAY;AACzC,IAAA,MAAM,IAAI,MAAM,0CAA0C,CAAA;AAAA,EAC5D;AAEA,EAAA,IAAI,OAAO,QAAA,CAAS,KAAA,KAAU,UAAA,EAAY;AACxC,IAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAAA,EAC3D;AAEA,EAAA,IAAI,OAAO,QAAA,CAAS,OAAA,KAAY,UAAA,EAAY;AAC1C,IAAA,MAAM,IAAI,MAAM,2CAA2C,CAAA;AAAA,EAC7D;AAEA,EAAA,IAAI,OAAO,QAAA,CAAS,MAAA,KAAW,UAAA,EAAY;AACzC,IAAA,MAAM,IAAI,MAAM,0CAA0C,CAAA;AAAA,EAC5D;AAEA,EAAA,OAAO,IAAA;AACT;AAOO,SAAS,sBAAsB,OAAA,EAA4C;AAChF,EAAA,IAAI,CAAC,OAAA,IAAW,OAAO,OAAA,KAAY,QAAA,EAAU;AAC3C,IAAA,MAAM,IAAI,MAAM,iCAAiC,CAAA;AAAA,EACnD;AAEA,EAAA,MAAM,aAAA,GAAgB,OAAA;AAGtB,EAAA,IAAI,OAAO,aAAA,CAAc,MAAA,KAAW,UAAA,EAAY;AAC9C,IAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAAA,EAC3D;AAEA,EAAA,IAAI,OAAO,aAAA,CAAc,WAAA,KAAgB,UAAA,EAAY;AACnD,IAAA,MAAM,IAAI,MAAM,8CAA8C,CAAA;AAAA,EAChE;AAGA,EAAA,IAAI,OAAO,aAAA,CAAc,iBAAA,KAAsB,UAAA,EAAY;AACzD,IAAA,MAAM,IAAI,MAAM,oDAAoD,CAAA;AAAA,EACtE;AAEA,EAAA,IAAI,OAAO,aAAA,CAAc,KAAA,KAAU,UAAA,EAAY;AAC7C,IAAA,MAAM,IAAI,MAAM,wCAAwC,CAAA;AAAA,EAC1D;AAEA,EAAA,IAAI,OAAO,aAAA,CAAc,MAAA,KAAW,UAAA,EAAY;AAC9C,IAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAAA,EAC3D;AAEA,EAAA,OAAO,IAAA;AACT;AAOO,SAAS,kBAAkB,SAAA,EAA4C;AAC5E,EAAA,IAAI,CAAC,SAAA,IAAa,OAAO,SAAA,KAAc,QAAA,EAAU;AAC/C,IAAA,MAAM,IAAI,MAAM,6BAA6B,CAAA;AAAA,EAC/C;AAEA,EAAA,MAAM,YAAA,GAAe,SAAA;AAErB,EAAA,IAAI,OAAO,YAAA,CAAa,QAAA,KAAa,UAAA,EAAY;AAC/C,IAAA,MAAM,IAAI,MAAM,uCAAuC,CAAA;AAAA,EACzD;AAEA,EAAA,IAAI,OAAO,YAAA,CAAa,KAAA,KAAU,UAAA,EAAY;AAC5C,IAAA,MAAM,IAAI,MAAM,oCAAoC,CAAA;AAAA,EACtD;AAEA,EAAA,IAAI,OAAO,YAAA,CAAa,MAAA,KAAW,UAAA,EAAY;AAC7C,IAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AAAA,EACvD;AAEA,EAAA,OAAO,IAAA;AACT;AAOO,SAAS,aAAa,IAAA,EAA6B;AACxD,EAAA,IAAI,CAAC,IAAA,IAAQ,OAAO,IAAA,KAAS,QAAA,EAAU;AACrC,IAAA,MAAM,IAAI,MAAM,wBAAwB,CAAA;AAAA,EAC1C;AAEA,EAAA,MAAM,OAAA,GAAU,IAAA;AAEhB,EAAA,IAAI,OAAO,OAAA,CAAQ,eAAA,KAAoB,UAAA,EAAY;AACjD,IAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAAA,EAC3D;AAEA,EAAA,OAAO,IAAA;AACT;AAeO,SAAS,0BAAA,CACd,EAAA,EACA,IAAA,EACA,OAAA,EACA,SAAA,EACa;AAEb,EAAA,sBAAA,CAAuB,EAAE,CAAA;AACzB,EAAA,YAAA,CAAa,IAAI,CAAA;AACjB,EAAA,qBAAA,CAAsB,OAAO,CAAA;AAC7B,EAAA,iBAAA,CAAkB,SAAS,CAAA;AAG3B,EAAA,OAAO,iBAAA,CAAkB,EAAA,EAAI,IAAA,EAAM,OAAA,EAAS,SAAS,CAAA;AACvD;;;AC5LO,SAAS,gBACd,IAAA,EACA,OAAA,EACA,WACA,QAAA,EAIA,WAAA,EAIA,WAIA,YAAA,EASW;AACX,EAAA,OAAO;AAAA,IACL,IAAA;AAAA,IACA,OAAA;AAAA,IACA,SAAA;AAAA,IACA,QAAA;AAAA,IACA,WAAA;AAAA,IACA,SAAA;AAAA,IACA;AAAA,GACF;AACF;AAYO,SAAS,kBAAkB,GAAA,EAAgC;AAChE,EAAA,IAAI,CAAC,GAAA,IAAO,OAAO,GAAA,KAAQ,QAAA,EAAU;AACnC,IAAA,MAAM,IAAI,MAAM,6BAA6B,CAAA;AAAA,EAC/C;AAEA,EAAA,MAAM,SAAA,GAAY,GAAA;AAElB,EAAA,IAAI,CAAC,SAAA,CAAU,IAAA,IAAQ,OAAO,SAAA,CAAU,SAAS,QAAA,EAAU;AACzD,IAAA,MAAM,IAAI,MAAM,yDAAyD,CAAA;AAAA,EAC3E;AAEA,EAAA,IAAI,CAAC,SAAA,CAAU,OAAA,IAAW,OAAO,SAAA,CAAU,YAAY,QAAA,EAAU;AAC/D,IAAA,MAAM,IAAI,MAAM,2DAA2D,CAAA;AAAA,EAC7E;AAEA,EAAA,IAAI,CAAC,SAAA,CAAU,SAAA,IAAa,OAAO,SAAA,CAAU,cAAc,QAAA,EAAU;AACnE,IAAA,MAAM,IAAI,MAAM,yDAAyD,CAAA;AAAA,EAC3E;AAEA,EAAA,IAAI,OAAO,SAAA,CAAU,QAAA,KAAa,UAAA,EAAY;AAC5C,IAAA,MAAM,IAAI,MAAM,uDAAuD,CAAA;AAAA,EACzE;AAEA,EAAA,IAAI,OAAO,SAAA,CAAU,WAAA,KAAgB,UAAA,EAAY;AAC/C,IAAA,MAAM,IAAI,MAAM,0DAA0D,CAAA;AAAA,EAC5E;AAEA,EAAA,IAAI,OAAO,SAAA,CAAU,SAAA,KAAc,UAAA,EAAY;AAC7C,IAAA,MAAM,IAAI,MAAM,wDAAwD,CAAA;AAAA,EAC1E;AAEA,EAAA,IAAI,OAAO,SAAA,CAAU,YAAA,KAAiB,UAAA,EAAY;AAChD,IAAA,MAAM,IAAI,MAAM,2DAA2D,CAAA;AAAA,EAC7E;AAEA,EAAA,OAAO,IAAA;AACT;AAOO,SAASG,cAAa,IAAA,EAA6B;AACxD,EAAA,IAAI,CAAC,IAAA,IAAQ,OAAO,IAAA,KAAS,QAAA,EAAU;AACrC,IAAA,MAAM,IAAI,MAAM,wBAAwB,CAAA;AAAA,EAC1C;AAEA,EAAA,MAAM,OAAA,GAAU,IAAA;AAEhB,EAAA,IAAI,OAAO,OAAA,CAAQ,eAAA,KAAoB,UAAA,EAAY;AACjD,IAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAAA,EAC3D;AAEA,EAAA,OAAO,IAAA;AACT;AAOO,SAAS,sBAAsB,OAAA,EAA4C;AAChF,EAAA,IAAI,CAAC,OAAA,IAAW,OAAO,OAAA,KAAY,QAAA,EAAU;AAC3C,IAAA,MAAM,IAAI,MAAM,iCAAiC,CAAA;AAAA,EACnD;AAEA,EAAA,MAAM,aAAA,GAAgB,OAAA;AAEtB,EAAA,IAAI,OAAO,aAAA,CAAc,MAAA,KAAW,UAAA,EAAY;AAC9C,IAAA,MAAM,IAAI,MAAM,yCAAyC,CAAA;AAAA,EAC3D;AAEA,EAAA,IAAI,OAAO,aAAA,CAAc,WAAA,KAAgB,UAAA,EAAY;AACnD,IAAA,MAAM,IAAI,MAAM,8CAA8C,CAAA;AAAA,EAChE;AAEA,EAAA,OAAO,IAAA;AACT;AAOO,SAASC,mBAAkB,SAAA,EAA4C;AAC5E,EAAA,IAAI,CAAC,SAAA,IAAa,OAAO,SAAA,KAAc,QAAA,EAAU;AAC/C,IAAA,MAAM,IAAI,MAAM,6BAA6B,CAAA;AAAA,EAC/C;AAEA,EAAA,MAAM,YAAA,GAAe,SAAA;AAErB,EAAA,IAAI,OAAO,YAAA,CAAa,QAAA,KAAa,UAAA,EAAY;AAC/C,IAAA,MAAM,IAAI,MAAM,uCAAuC,CAAA;AAAA,EACzD;AAEA,EAAA,IAAI,OAAO,YAAA,CAAa,KAAA,KAAU,UAAA,EAAY;AAC5C,IAAA,MAAM,IAAI,MAAM,oCAAoC,CAAA;AAAA,EACtD;AAEA,EAAA,IAAI,OAAO,YAAA,CAAa,MAAA,KAAW,UAAA,EAAY;AAC7C,IAAA,MAAM,IAAI,MAAM,qCAAqC,CAAA;AAAA,EACvD;AAEA,EAAA,OAAO,IAAA;AACT;AAkBO,SAAS,yBACd,IAAA,EACA,OAAA,EACA,WACA,QAAA,EAIA,WAAA,EAIA,WAIA,YAAA,EASW;AAEX,EAAAD,cAAa,IAAI,CAAA;AACjB,EAAA,qBAAA,CAAsB,OAAO,CAAA;AAC7B,EAAAC,mBAAkB,SAAS,CAAA;AAG3B,EAAA,IAAI,OAAO,aAAa,UAAA,EAAY;AAClC,IAAA,MAAM,IAAI,MAAM,6BAA6B,CAAA;AAAA,EAC/C;AACA,EAAA,IAAI,OAAO,gBAAgB,UAAA,EAAY;AACrC,IAAA,MAAM,IAAI,MAAM,gCAAgC,CAAA;AAAA,EAClD;AACA,EAAA,IAAI,OAAO,cAAc,UAAA,EAAY;AACnC,IAAA,MAAM,IAAI,MAAM,8BAA8B,CAAA;AAAA,EAChD;AACA,EAAA,IAAI,OAAO,iBAAiB,UAAA,EAAY;AACtC,IAAA,MAAM,IAAI,MAAM,iCAAiC,CAAA;AAAA,EACnD;AAGA,EAAA,OAAO,eAAA;AAAA,IACL,IAAA;AAAA,IACA,OAAA;AAAA,IACA,SAAA;AAAA,IACA,QAAA;AAAA,IACA,WAAA;AAAA,IACA,SAAA;AAAA,IACA;AAAA,GACF;AACF;;;ACtMO,SAAS,QAAQ,EAAA,EAAwE;AAC9F,EAAA,OACE,EAAA,KAAO,IAAA,IACP,EAAA,KAAO,MAAA,IACP,OAAO,OAAO,QAAA,IACd,OAAA,IAAW,EAAA,IACX,EAAA,CAAG,KAAA,KAAU,OAAA;AAEjB;AAgBO,SAAS,WAAW,EAAA,EAA2E;AACpG,EAAA,OACE,EAAA,KAAO,IAAA,IACP,EAAA,KAAO,MAAA,IACP,OAAO,OAAO,QAAA,IACd,OAAA,IAAW,EAAA,IACX,EAAA,CAAG,KAAA,KAAU,UAAA;AAEjB;AAgBO,SAAS,SAAS,EAAA,EAAyE;AAChG,EAAA,OACE,EAAA,KAAO,IAAA,IACP,EAAA,KAAO,MAAA,IACP,OAAO,OAAO,QAAA,IACd,OAAA,IAAW,EAAA,IACX,EAAA,CAAG,KAAA,KAAU,QAAA;AAEjB;AAeO,SAAS,qBAAqB,EAAA,EAA0C;AAC7E,EAAA,OAAO,QAAQ,EAAE,CAAA,IAAK,WAAW,EAAE,CAAA,IAAK,SAAS,EAAE,CAAA;AACrD;AAiBO,SAAS,iBAAiB,EAAA,EAA0C;AACzE,EAAA,OAAO,oBAAA,CAAqB,EAAE,CAAA,IAAK,EAAA,CAAG,WAAA,KAAgB,QAAA;AACxD;AAcO,SAAS,mBAAmB,EAAA,EAA0C;AAC3E,EAAA,OAAO,oBAAA,CAAqB,EAAE,CAAA,IAAK,EAAA,CAAG,WAAA,KAAgB,UAAA;AACxD;AAkBO,SAAS,gBAAgB,EAAA,EAAyC;AACvE,EAAA,OAAO,EAAA,CAAG,KAAA;AACZ;AAiBO,SAAS,sBAAsB,EAAA,EAA+C;AACnF,EAAA,OAAO,EAAA,CAAG,WAAA;AACZ;AAiBO,SAAS,iBAAiB,EAAA,EAAsD;AACrF,EAAA,OAAO,GAAG,OAAA,CAAQ,IAAA;AACpB;AAiBO,SAAS,oBAAoB,EAAA,EAAkD;AACpF,EAAA,OAAO,GAAG,OAAA,CAAQ,OAAA;AACpB;AAcO,SAAS,mBACd,EAAA,EACyB;AACzB,EAAA,OAAO,GAAG,OAAA,CAAQ,OAAA;AACpB;;;ACtLO,IAAM,qBAAA,GAAN,MAAM,sBAAA,SAA8B,KAAA,CAAM;AAAA,EAC/B,IAAA;AAAA,EAEhB,WAAA,CAAY,SAAiB,IAAA,EAAe;AAC1C,IAAA,KAAA,CAAM,OAAO,CAAA;AACb,IAAA,IAAA,CAAK,IAAA,GAAO,uBAAA;AACZ,IAAA,IAAA,CAAK,IAAA,GAAO,IAAA;AAGZ,IAAA,IAAI,MAAM,iBAAA,EAAmB;AAC3B,MAAA,KAAA,CAAM,iBAAA,CAAkB,MAAM,sBAAqB,CAAA;AAAA,IACrD;AAAA,EACF;AACF;AAWA,IAAM,mBAAA,GAAsB,qCAAA;AAM5B,IAAM,eAAA,GAAkB,uBAAA;AAKxB,SAAS,qBAAqB,IAAA,EAAoB;AAChD,EAAA,IAAI,CAAC,IAAA,IAAQ,IAAA,CAAK,IAAA,OAAW,EAAA,EAAI;AAC/B,IAAA,MAAM,IAAI,qBAAA,CAAsB,+BAAA,EAAiC,cAAc,CAAA;AAAA,EACjF;AAEA,EAAA,MAAM,WAAA,GAAc,KAAK,IAAA,EAAK;AAE9B,EAAA,IAAI,CAAC,mBAAA,CAAoB,IAAA,CAAK,WAAW,CAAA,EAAG;AAC1C,IAAA,MAAM,IAAI,qBAAA;AAAA,MACR,2BAA2B,IAAI,CAAA,+EAAA,CAAA;AAAA,MAC/B;AAAA,KACF;AAAA,EACF;AACF;AAKA,SAAS,iBAAiB,IAAA,EAAoB;AAC5C,EAAA,IAAI,CAAC,IAAA,IAAQ,IAAA,CAAK,IAAA,OAAW,EAAA,EAAI;AAC/B,IAAA,MAAM,IAAI,qBAAA,CAAsB,2BAAA,EAA6B,cAAc,CAAA;AAAA,EAC7E;AAEA,EAAA,IAAI,CAAC,IAAA,CAAK,UAAA,CAAW,GAAG,CAAA,EAAG;AACzB,IAAA,MAAM,IAAI,qBAAA;AAAA,MACR,uBAAuB,IAAI,CAAA,kCAAA,CAAA;AAAA,MAC3B;AAAA,KACF;AAAA,EACF;AAEA,EAAA,IAAI,CAAC,eAAA,CAAgB,IAAA,CAAK,IAAI,CAAA,EAAG;AAC/B,IAAA,MAAM,IAAI,qBAAA;AAAA,MACR,uBAAuB,IAAI,CAAA,sCAAA,CAAA;AAAA,MAC3B;AAAA,KACF;AAAA,EACF;AACF;AA0BO,IAAM,gBAAA,GAAN,MAAM,iBAAA,CAAoD;AAAA,EAC/D,OAAe,QAAA,GAAoC,IAAA;AAAA,EAElC,WAAA,uBAA8C,GAAA,EAAI;AAAA,EAClD,aAAA,uBAAoD,GAAA,EAAI;AAAA;AAAA;AAAA;AAAA,EAKjE,WAAA,GAAc;AAAA,EAAC;AAAA;AAAA;AAAA;AAAA,EAKvB,OAAc,WAAA,GAAgC;AAC5C,IAAA,IAAI,CAAC,kBAAiB,QAAA,EAAU;AAC9B,MAAA,iBAAA,CAAiB,QAAA,GAAW,IAAI,iBAAA,EAAiB;AAAA,IACnD;AACA,IAAA,OAAO,iBAAA,CAAiB,QAAA;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,OAAc,aAAA,GAAsB;AAClC,IAAA,iBAAA,CAAiB,QAAA,GAAW,IAAA;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeO,QAAA,CACL,IAAA,EACA,EAAA,EACA,OAAA,GAA+B,EAAC,EAC1B;AACN,IAAA,oBAAA,CAAqB,IAAI,CAAA;AAEzB,IAAA,IAAI,KAAK,WAAA,CAAY,GAAA,CAAI,IAAI,CAAA,IAAK,CAAC,QAAQ,KAAA,EAAO;AAChD,MAAA,MAAM,IAAI,qBAAA;AAAA,QACR,yCAAyC,IAAI,CAAA,oCAAA,CAAA;AAAA,QAC7C;AAAA,OACF;AAAA,IACF;AAEA,IAAA,MAAM,KAAA,GAAuB;AAAA,MAC3B,IAAA;AAAA,MACA,MAAM,EAAA,CAAG,KAAA;AAAA,MACT,YAAY,EAAA,CAAG,WAAA;AAAA,MACf;AAAA,KACF;AAEA,IAAA,IAAA,CAAK,WAAA,CAAY,GAAA,CAAI,IAAA,EAAM,KAAK,CAAA;AAChC,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,YAAY,IAAA,EAAyC;AAC1D,IAAA,OAAO,IAAA,CAAK,WAAA,CAAY,GAAA,CAAI,IAAI,CAAA;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,IAAI,IAAA,EAAuB;AAChC,IAAA,OAAO,IAAA,CAAK,WAAA,CAAY,GAAA,CAAI,IAAI,CAAA;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,WAAW,IAAA,EAAuB;AACvC,IAAA,OAAO,IAAA,CAAK,WAAA,CAAY,MAAA,CAAO,IAAI,CAAA;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,aAAA,CAAc,MAAqB,UAAA,EAAkD;AAC1F,IAAA,MAAM,UAAU,KAAA,CAAM,IAAA,CAAK,IAAA,CAAK,WAAA,CAAY,QAAQ,CAAA;AAEpD,IAAA,OAAO,OAAA,CAAQ,OAAO,CAAA,KAAA,KAAS;AAC7B,MAAA,IAAI,IAAA,KAAS,MAAA,IAAa,KAAA,CAAM,IAAA,KAAS,IAAA,EAAM;AAC7C,QAAA,OAAO,KAAA;AAAA,MACT;AACA,MAAA,IAAI,UAAA,KAAe,MAAA,IAAa,KAAA,CAAM,UAAA,KAAe,UAAA,EAAY;AAC/D,QAAA,OAAO,KAAA;AAAA,MACT;AACA,MAAA,OAAO,IAAA;AAAA,IACT,CAAC,CAAA;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,eAAA,CAAgB,MAAc,MAAA,EAA4B;AAChE,IAAA,OAAO,CAAA,EAAG,MAAM,CAAA,CAAA,EAAI,IAAI,CAAA,CAAA;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYO,qBACL,IAAA,EACA,MAAA,EACA,QAAA,EACA,OAAA,GAA+B,EAAC,EAC1B;AACN,IAAA,gBAAA,CAAiB,IAAI,CAAA;AAErB,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,eAAA,CAAgB,IAAA,EAAM,MAAM,CAAA;AAE7C,IAAA,IAAI,KAAK,aAAA,CAAc,GAAA,CAAI,GAAG,CAAA,IAAK,CAAC,QAAQ,KAAA,EAAO;AACjD,MAAA,MAAM,IAAI,qBAAA;AAAA,QACR,CAAA,oCAAA,EAAuC,MAAM,CAAA,CAAA,EAAI,IAAI,CAAA,mCAAA,CAAA;AAAA,QACrD;AAAA,OACF;AAAA,IACF;AAEA,IAAA,MAAM,KAAA,GAA2B;AAAA,MAC/B,IAAA;AAAA,MACA,MAAA;AAAA,MACA;AAAA,KACF;AAEA,IAAA,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,GAAA,EAAK,KAAK,CAAA;AACjC,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,eAAA,CAAgB,MAAc,MAAA,EAAmD;AACtF,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,eAAA,CAAgB,IAAA,EAAM,MAAM,CAAA;AAC7C,IAAA,OAAO,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,GAAG,CAAA;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,eAAA,CAAgB,MAAc,MAAA,EAA6B;AAChE,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,eAAA,CAAgB,IAAA,EAAM,MAAM,CAAA;AAC7C,IAAA,OAAO,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,GAAG,CAAA;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,sBAAA,CAAuB,MAAc,MAAA,EAA6B;AACvE,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,eAAA,CAAgB,IAAA,EAAM,MAAM,CAAA;AAC7C,IAAA,OAAO,IAAA,CAAK,aAAA,CAAc,MAAA,CAAO,GAAG,CAAA;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,kBAAkB,MAAA,EAA0C;AACjE,IAAA,MAAM,UAAU,KAAA,CAAM,IAAA,CAAK,IAAA,CAAK,aAAA,CAAc,QAAQ,CAAA;AAEtD,IAAA,IAAI,WAAW,MAAA,EAAW;AACxB,MAAA,OAAO,OAAA;AAAA,IACT;AAEA,IAAA,OAAO,OAAA,CAAQ,MAAA,CAAO,CAAA,KAAA,KAAS,KAAA,CAAM,WAAW,MAAM,CAAA;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,iBAAA,CAAkB,aAAqB,MAAA,EAAmD;AAE/F,IAAA,MAAM,QAAA,GAAW,IAAA,CAAK,eAAA,CAAgB,WAAA,EAAa,MAAM,CAAA;AACzD,IAAA,MAAM,UAAA,GAAa,IAAA,CAAK,aAAA,CAAc,GAAA,CAAI,QAAQ,CAAA;AAClD,IAAA,IAAI,UAAA,EAAY;AACd,MAAA,OAAO;AAAA,QACL,GAAG,UAAA;AAAA,QACH,QAAQ;AAAC,OACX;AAAA,IACF;AAGA,IAAA,MAAM,eAAA,GAAkB,IAAA,CAAK,iBAAA,CAAkB,MAAM,CAAA;AAErD,IAAA,KAAA,MAAW,SAAS,eAAA,EAAiB;AACnC,MAAA,MAAM,MAAA,GAAS,IAAA,CAAK,SAAA,CAAU,KAAA,CAAM,MAAM,WAAW,CAAA;AACrD,MAAA,IAAI,WAAW,IAAA,EAAM;AACnB,QAAA,OAAO;AAAA,UACL,GAAG,KAAA;AAAA,UACH;AAAA,SACF;AAAA,MACF;AAAA,IACF;AAEA,IAAA,OAAO,MAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASQ,SAAA,CAAU,SAAiB,WAAA,EAAoD;AACrF,IAAA,MAAM,eAAe,OAAA,CAAQ,KAAA,CAAM,GAAG,CAAA,CAAE,OAAO,OAAO,CAAA;AACtD,IAAA,MAAM,eAAe,WAAA,CAAY,KAAA,CAAM,GAAG,CAAA,CAAE,OAAO,OAAO,CAAA;AAE1D,IAAA,IAAI,YAAA,CAAa,MAAA,KAAW,YAAA,CAAa,MAAA,EAAQ;AAC/C,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,MAAM,SAAiC,EAAC;AAExC,IAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,YAAA,CAAa,QAAQ,CAAA,EAAA,EAAK;AAC5C,MAAA,MAAM,WAAA,GAAc,aAAa,CAAC,CAAA;AAClC,MAAA,MAAM,WAAA,GAAc,aAAa,CAAC,CAAA;AAElC,MAAA,IAAI,WAAA,CAAY,UAAA,CAAW,GAAG,CAAA,EAAG;AAE/B,QAAA,MAAM,SAAA,GAAY,WAAA,CAAY,KAAA,CAAM,CAAC,CAAA;AACrC,QAAA,MAAA,CAAO,SAAS,CAAA,GAAI,WAAA;AAAA,MACtB,CAAA,MAAA,IAAW,gBAAgB,WAAA,EAAa;AAEtC,QAAA,OAAO,IAAA;AAAA,MACT;AAAA,IACF;AAEA,IAAA,OAAO,MAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaO,cAAA,CACL,QACA,MAAA,EACM;AACN,IAAA,KAAA,MAAW,CAAC,IAAA,EAAM,KAAK,KAAK,MAAA,CAAO,OAAA,CAAQ,MAAM,CAAA,EAAG;AAElD,MAAA,IAAI,IAAA,CAAK,oBAAA,CAAqB,KAAK,CAAA,EAAG;AACpC,QAAA,MAAM,IAAA,GAAO,CAAA,EAAG,MAAM,CAAA,CAAA,EAAI,IAAI,CAAA,CAAA;AAC9B,QAAA,IAAA,CAAK,QAAA,CAAS,MAAM,KAAK,CAAA;AAAA,MAC3B;AAAA,IACF;AACA,IAAA,OAAO,IAAA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,qBAAqB,KAAA,EAA6C;AACxE,IAAA,IAAI,CAAC,KAAA,IAAS,OAAO,KAAA,KAAU,QAAA,EAAU;AACvC,MAAA,OAAO,KAAA;AAAA,IACT;AAEA,IAAA,MAAM,GAAA,GAAM,KAAA;AACZ,IAAA,OAAA,CACE,GAAA,CAAI,KAAA,KAAU,OAAA,IACd,GAAA,CAAI,KAAA,KAAU,cACd,GAAA,CAAI,KAAA,KAAU,QAAA,MAEd,GAAA,CAAI,WAAA,KAAgB,QAAA,IACpB,IAAI,WAAA,KAAgB,UAAA,CAAA,KAEpB,OAAO,GAAA,CAAI,OAAA,KAAY,QAAA,IACvB,GAAA,CAAI,OAAA,KAAY,IAAA,IAChB,OAAQ,GAAA,CAAI,OAAA,CAAoC,OAAA,KAAY,UAAA,CAAA;AAAA,EAEhE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,IAAA,GAAe;AACpB,IAAA,OAAO,KAAK,WAAA,CAAY,IAAA;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKO,iBAAA,GAA4B;AACjC,IAAA,OAAO,KAAK,aAAA,CAAc,IAAA;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKO,KAAA,GAAc;AACnB,IAAA,IAAA,CAAK,YAAY,KAAA,EAAM;AACvB,IAAA,IAAA,CAAK,cAAc,KAAA,EAAM;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,CAAQ,MAAA,CAAO,QAAQ,CAAA,GAA6B;AAClD,IAAA,OAAO,IAAA,CAAK,YAAY,MAAA,EAAO;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKO,OAAA,GAAqD;AAC1D,IAAA,OAAO,IAAA,CAAK,YAAY,OAAA,EAAQ;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKO,KAAA,GAAkC;AACvC,IAAA,OAAO,IAAA,CAAK,YAAY,IAAA,EAAK;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKA,CAAQ,SAAA,GAAkD;AACxD,IAAA,KAAA,MAAW,KAAA,IAAS,IAAA,CAAK,WAAA,CAAY,MAAA,EAAO,EAAG;AAC7C,MAAA,MAAM,KAAA,CAAM,EAAA;AAAA,IACd;AAAA,EACF;AACF;;;AChaO,SAAS,kBAAkB,IAAA,EAAkC;AAClE,EAAA,MAAM,UAAA,GAAa,IAAA,CAAK,WAAA,CAAY,GAAG,CAAA;AAEvC,EAAA,IAAI,eAAe,EAAA,EAAI;AAErB,IAAA,OAAO;AAAA,MACL,MAAA,EAAQ,EAAA;AAAA,MACR,YAAA,EAAc,IAAA;AAAA,MACd,QAAA,EAAU;AAAA,KACZ;AAAA,EACF;AAEA,EAAA,OAAO;AAAA,IACL,MAAA,EAAQ,IAAA,CAAK,SAAA,CAAU,CAAA,EAAG,UAAU,CAAA;AAAA,IACpC,YAAA,EAAc,IAAA,CAAK,SAAA,CAAU,UAAA,GAAa,CAAC,CAAA;AAAA,IAC3C,QAAA,EAAU;AAAA,GACZ;AACF;AASA,SAAS,iBAAA,CAMP,IAAA,EACA,IAAA,EACA,UAAA,EACoD;AACpD,EAAA,OAAO;AAAA,IACL,KAAA,EAAO,IAAA;AAAA,IACP,KAAA,EAAO,MAAA;AAAA,IACP,QAAA,EAAU,MAAA;AAAA,IACV,KAAA,EAAO,IAAA;AAAA,IACP,WAAA,EAAa;AAAA,GACf;AACF;AA8CO,SAAS,qBAAA,CAMd,IAAA,EACA,UAAA,GAAyB,QAAA,EAC2B;AAQpD,EAAA,OAAO,iBAAA,CAAkB,OAAA,EAAiB,IAAA,EAAM,UAAU,CAAA;AAC5D;AAKO,SAAS,kBAAA,CAKd,IAAA,EACA,UAAA,GAAyB,QAAA,EAC8B;AACvD,EAAA,OAAO,iBAAA,CAAkB,OAAA,EAAS,IAAA,EAAM,UAAU,CAAA;AACpD;AAKO,SAAS,qBAAA,CAKd,IAAA,EACA,UAAA,GAAyB,QAAA,EACiC;AAC1D,EAAA,OAAO,iBAAA,CAAkB,UAAA,EAAY,IAAA,EAAM,UAAU,CAAA;AACvD;AAKO,SAAS,mBAAA,CAKd,IAAA,EACA,UAAA,GAAyB,QAAA,EAC+B;AACxD,EAAA,OAAO,iBAAA,CAAkB,QAAA,EAAU,IAAA,EAAM,UAAU,CAAA;AACrD;AAkBO,SAAS,gBAAgB,GAAA,EAAmC;AACjE,EAAA,OAAO,GAAA,CAAI,KAAA;AACb;AAUA,IAAM,gBAAA,GAAmB,gDAAA;AAiBlB,SAAS,YAAA,CACd,YACG,MAAA,EACK;AAER,EAAA,IAAI,MAAA,GAAS,QAAQ,CAAC,CAAA;AACtB,EAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,MAAA,CAAO,QAAQ,CAAA,EAAA,EAAK;AACtC,IAAA,MAAA,IAAU,OAAO,MAAA,CAAO,CAAC,CAAC,CAAA,GAAI,OAAA,CAAQ,IAAI,CAAC,CAAA;AAAA,EAC7C;AAGA,EAAA,IAAI,CAAC,gBAAA,CAAiB,IAAA,CAAK,MAAM,CAAA,EAAG;AAClC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,kCAAkC,MAAM,CAAA,oEAAA;AAAA,KAC1C;AAAA,EACF;AAEA,EAAA,OAAO,MAAA;AACT;AAoBO,SAAS,qBAAqB,GAAA,EAAmC;AACtE,EAAA,OAAO,GAAA,CAAI,KAAA;AACb;AAkBA,SAAS,cAAA,CAAe,GAAA,EAAgB,IAAA,EAAgB,KAAA,EAAmC;AACzF,EAAA,IAAI,OAAA,GAAU,GAAA;AACd,EAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,GAAI,IAAA,CAAK,MAAA,GAAS,GAAG,CAAA,EAAA,EAAK;AACxC,IAAA,MAAM,GAAA,GAAM,KAAK,CAAC,CAAA;AAClB,IAAA,IAAI,EAAE,OAAO,OAAA,CAAA,EAAU;AACrB,MAAA,OAAA,CAAQ,GAAG,IAAI,EAAC;AAAA,IAClB;AACA,IAAA,OAAA,GAAU,QAAQ,GAAG,CAAA;AAAA,EACvB;AACA,EAAA,OAAA,CAAQ,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,CAAC,CAAC,CAAA,GAAI,KAAA;AACnC;AAMA,SAAS,eAAe,YAAA,EAAgC;AACtD,EAAA,MAAM,MAAA,GAAS,kBAAkB,YAAY,CAAA;AAC7C,EAAA,MAAM,WAAA,GAAc,OAAO,MAAA,GAAS,MAAA,CAAO,OAAO,KAAA,CAAM,GAAG,IAAI,EAAC;AAChE,EAAA,OAAO,CAAC,GAAG,WAAA,EAAa,MAAA,CAAO,YAAY,CAAA;AAC7C;AAsBO,SAAS,UACd,mBAAA,EACW;AACX,EAAA,MAAM,MAAiB,EAAC;AAExB,EAAA,KAAA,MAAW,CAAC,IAAA,EAAM,IAAI,KAAK,MAAA,CAAO,OAAA,CAAQ,mBAAmB,CAAA,EAAG;AAE9D,IAAA,IAAI,IAAA,CAAK,gBAAgB,QAAA,EAAU;AACjC,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,SAAA,GAAY,eAAe,IAAI,CAAA;AACrC,IAAA,MAAM,GAAA,GAA4B;AAAA,MAChC,OAAO,IAAA,CAAK,KAAA;AAAA,MACZ,OAAO,IAAA,CAAK,KAAA;AAAA,MACZ,UAAU,IAAA,CAAK,QAAA;AAAA,MACf,KAAA,EAAO,IAAA;AAAA,MACP,WAAA,EAAa;AAAA,KACf;AAEA,IAAA,cAAA,CAAe,GAAA,EAAK,WAAW,GAAG,CAAA;AAAA,EACpC;AAEA,EAAA,OAAO,GAAA;AACT;AAqBO,SAAS,kBACd,mBAAA,EACW;AACX,EAAA,MAAM,WAAsB,EAAC;AAE7B,EAAA,KAAA,MAAW,CAAC,IAAA,EAAM,IAAI,KAAK,MAAA,CAAO,OAAA,CAAQ,mBAAmB,CAAA,EAAG;AAE9D,IAAA,IAAI,IAAA,CAAK,gBAAgB,UAAA,EAAY;AACnC,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,SAAA,GAAY,eAAe,IAAI,CAAA;AACrC,IAAA,MAAM,GAAA,GAA4B;AAAA,MAChC,OAAO,IAAA,CAAK,KAAA;AAAA,MACZ,OAAO,IAAA,CAAK,KAAA;AAAA,MACZ,UAAU,IAAA,CAAK,QAAA;AAAA,MACf,KAAA,EAAO,IAAA;AAAA,MACP,WAAA,EAAa;AAAA,KACf;AAEA,IAAA,cAAA,CAAe,QAAA,EAAU,WAAW,GAAG,CAAA;AAAA,EACzC;AAEA,EAAA,OAAO,QAAA;AACT","file":"index.js","sourcesContent":["/**\n * Validator system for convex.do\n * 100% compatible with Convex v validators\n */\n\n// ============================================================================\n// Base Validator Interface\n// ============================================================================\n\n/**\n * Base interface for all validators.\n * Provides type inference and validation logic.\n */\nexport interface Validator<T = unknown, IsOptional extends boolean = boolean> {\n  /** The inferred TypeScript type */\n  readonly _type: T\n  /** Whether this validator is optional */\n  readonly isOptional: IsOptional\n  /** Parse and validate a value, throwing on invalid input */\n  parse(value: unknown): T\n  /** Check if a value is valid without throwing */\n  isValid(value: unknown): value is T\n  /** Make this validator optional */\n  optional(): OptionalValidator<T>\n  /** Get a description of this validator for error messages */\n  describe(): string\n}\n\n/**\n * Infer the TypeScript type from a validator.\n */\nexport type Infer<V extends Validator> = V['_type']\n\n// ============================================================================\n// Path context for nested validation errors\n// ============================================================================\n\nclass ValidationContext {\n  private path: (string | number)[] = []\n\n  push(segment: string | number): void {\n    this.path.push(segment)\n  }\n\n  pop(): void {\n    this.path.pop()\n  }\n\n  getPath(): (string | number)[] {\n    return [...this.path]\n  }\n\n  formatPath(): string {\n    return this.path.join('.')\n  }\n}\n\n// Thread-local context for validation\nlet currentContext: ValidationContext | null = null\n\nfunction withContext<T>(fn: () => T): T {\n  const hadContext = currentContext !== null\n  if (!hadContext) {\n    currentContext = new ValidationContext()\n  }\n  try {\n    return fn()\n  } finally {\n    if (!hadContext) {\n      currentContext = null\n    }\n  }\n}\n\nfunction pushPath(segment: string | number): void {\n  currentContext?.push(segment)\n}\n\nfunction popPath(): void {\n  currentContext?.pop()\n}\n\nfunction getPathString(): string {\n  return currentContext?.formatPath() ?? ''\n}\n\n// ============================================================================\n// Base Validator Implementation\n// ============================================================================\n\nabstract class BaseValidator<T, IsOptional extends boolean = false> implements Validator<T, IsOptional> {\n  abstract readonly _type: T\n  readonly isOptional: IsOptional = false as IsOptional\n\n  abstract parse(value: unknown): T\n  abstract describe(): string\n\n  isValid(value: unknown): value is T {\n    try {\n      this.parse(value)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  optional(): OptionalValidator<T> {\n    return new OptionalValidator(this)\n  }\n}\n\n// ============================================================================\n// Primitive Validators\n// ============================================================================\n\n/**\n * Gets a human-readable type name for a value.\n */\nfunction getTypeName(value: unknown): string {\n  if (value === null) return 'null'\n  if (value === undefined) return 'undefined'\n  if (Array.isArray(value)) return 'array'\n  if (value instanceof ArrayBuffer) return 'ArrayBuffer'\n  if (ArrayBuffer.isView(value)) return value.constructor.name\n  if (typeof value === 'number' && Number.isNaN(value)) return 'NaN'\n  if (typeof value === 'object' && value !== null) {\n    // Check for boxed primitives\n    if (value instanceof String) return 'String object'\n    if (value instanceof Number) return 'Number object'\n    if (value instanceof Boolean) return 'Boolean object'\n    return 'object'\n  }\n  return typeof value\n}\n\nclass StringValidator extends BaseValidator<string> {\n  readonly _type!: string\n\n  parse(value: unknown): string {\n    // Reject boxed String objects\n    if (value instanceof String) {\n      throw new Error(`Expected string, got String object`)\n    }\n    if (typeof value !== 'string') {\n      throw new Error(`Expected string, got ${getTypeName(value)}`)\n    }\n    return value\n  }\n\n  describe(): string {\n    return 'string'\n  }\n}\n\nclass NumberValidator extends BaseValidator<number> {\n  readonly _type!: number\n\n  parse(value: unknown): number {\n    // Reject boxed Number objects\n    if (value instanceof Number) {\n      throw new Error(`Expected number, got Number object`)\n    }\n    if (typeof value !== 'number') {\n      throw new Error(`Expected number, got ${getTypeName(value)}`)\n    }\n    // Reject NaN with specific message\n    if (Number.isNaN(value)) {\n      throw new Error(`Expected number, got NaN`)\n    }\n    // Reject Infinity and -Infinity\n    if (!Number.isFinite(value)) {\n      throw new Error(`Expected number, got ${value > 0 ? 'Infinity' : '-Infinity'}`)\n    }\n    return value\n  }\n\n  describe(): string {\n    return 'number'\n  }\n}\n\nclass BooleanValidator extends BaseValidator<boolean> {\n  readonly _type!: boolean\n\n  parse(value: unknown): boolean {\n    // Reject boxed Boolean objects\n    if (value instanceof Boolean) {\n      throw new Error(`Expected boolean, got Boolean object`)\n    }\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected boolean, got ${getTypeName(value)}`)\n    }\n    return value\n  }\n\n  describe(): string {\n    return 'boolean'\n  }\n}\n\nclass NullValidator extends BaseValidator<null> {\n  readonly _type!: null\n\n  parse(value: unknown): null {\n    if (value !== null) {\n      // Provide specific error message for undefined\n      if (value === undefined) {\n        throw new Error(`undefined is not null`)\n      }\n      throw new Error(`Expected null, got ${getTypeName(value)}`)\n    }\n    return value\n  }\n\n  describe(): string {\n    return 'null'\n  }\n}\n\nconst INT64_MAX = BigInt('9223372036854775807')\nconst INT64_MIN = BigInt('-9223372036854775808')\n\nclass Int64Validator extends BaseValidator<bigint> {\n  readonly _type!: bigint\n\n  parse(value: unknown): bigint {\n    let result: bigint\n\n    if (typeof value === 'bigint') {\n      result = value\n    } else if (typeof value === 'number') {\n      // Reject NaN, Infinity, -Infinity\n      if (Number.isNaN(value)) {\n        throw new Error(`Expected int64/bigint, got NaN`)\n      }\n      if (!Number.isFinite(value)) {\n        throw new Error(`Expected int64/bigint, got ${value > 0 ? 'Infinity' : '-Infinity'}`)\n      }\n      // Reject non-integer numbers\n      if (!Number.isInteger(value)) {\n        throw new Error(`Expected int64/bigint, got float (${value})`)\n      }\n      result = BigInt(value)\n    } else if (typeof value === 'string') {\n      // Reject empty strings with specific message\n      if (value === '') {\n        throw new Error(`Cannot convert empty string to int64`)\n      }\n      // Reject float strings\n      if (value.includes('.')) {\n        throw new Error(`Expected int64/bigint, got float string (\"${value}\")`)\n      }\n      try {\n        result = BigInt(value)\n      } catch {\n        throw new Error(`Cannot convert \"${value}\" to int64`)\n      }\n    } else {\n      throw new Error(`Expected int64/bigint, got ${getTypeName(value)}`)\n    }\n\n    // Check int64 bounds\n    if (result > INT64_MAX) {\n      throw new Error(`Value ${result} exceeds maximum int64 value (${INT64_MAX})`)\n    }\n    if (result < INT64_MIN) {\n      throw new Error(`Value ${result} is less than minimum int64 value (${INT64_MIN})`)\n    }\n\n    return result\n  }\n\n  describe(): string {\n    return 'int64'\n  }\n}\n\nclass Float64Validator extends BaseValidator<number> {\n  readonly _type!: number\n\n  parse(value: unknown): number {\n    // Reject boxed Number objects\n    if (value instanceof Number) {\n      throw new Error(`Expected float64/number, got Number object`)\n    }\n    if (typeof value !== 'number') {\n      throw new Error(`Expected float64/number, got ${getTypeName(value)}`)\n    }\n    // Reject NaN with specific message\n    if (Number.isNaN(value)) {\n      throw new Error(`NaN is not a valid float64`)\n    }\n    // Note: float64 accepts Infinity and -Infinity (they are valid IEEE 754 values)\n    return value\n  }\n\n  describe(): string {\n    return 'float64'\n  }\n}\n\nclass BytesValidator extends BaseValidator<ArrayBuffer> {\n  readonly _type!: ArrayBuffer\n\n  parse(value: unknown): ArrayBuffer {\n    if (value instanceof ArrayBuffer) {\n      return value\n    }\n    if (ArrayBuffer.isView(value)) {\n      return value.buffer.slice(value.byteOffset, value.byteOffset + value.byteLength) as ArrayBuffer\n    }\n    throw new Error(`Expected bytes/ArrayBuffer, got ${typeof value}`)\n  }\n\n  describe(): string {\n    return 'bytes'\n  }\n}\n\n// ============================================================================\n// ID Validator\n// ============================================================================\n\n/**\n * Minimum valid length for Convex IDs (32 characters standard)\n */\nconst MIN_ID_LENGTH = 32\n\n/**\n * Maximum valid length for Convex IDs\n */\nconst MAX_ID_LENGTH = 128\n\n/**\n * Pattern for valid Convex ID characters (alphanumeric only for standard format)\n * Allows uppercase, lowercase letters and digits\n */\nconst VALID_ID_PATTERN = /^[A-Za-z0-9]+$/\n\nclass IdValidator<TableName extends string> extends BaseValidator<string & { __tableName: TableName }> {\n  readonly _type!: string & { __tableName: TableName }\n  private tableName: TableName\n\n  constructor(tableName: TableName) {\n    super()\n    if (!tableName || tableName.trim() === '') {\n      throw new Error('Table name cannot be empty')\n    }\n    this.tableName = tableName\n  }\n\n  parse(value: unknown): string & { __tableName: TableName } {\n    // Must be a string\n    if (typeof value !== 'string') {\n      throw new Error(`Expected ID for table \"${this.tableName}\", got ${getTypeName(value)}`)\n    }\n\n    // ID cannot be empty\n    if (value.length === 0) {\n      throw new Error(`ID for table \"${this.tableName}\" cannot be empty`)\n    }\n\n    // ID must meet minimum length (32 characters for Convex IDs)\n    if (value.length < MIN_ID_LENGTH) {\n      throw new Error(`Invalid ID for table \"${this.tableName}\": ID is too short (minimum ${MIN_ID_LENGTH} characters)`)\n    }\n\n    // ID cannot exceed maximum length\n    if (value.length > MAX_ID_LENGTH) {\n      throw new Error(`Invalid ID for table \"${this.tableName}\": ID is too long (maximum ${MAX_ID_LENGTH} characters)`)\n    }\n\n    // ID must only contain valid characters (alphanumeric)\n    if (!VALID_ID_PATTERN.test(value)) {\n      throw new Error(`Invalid ID for table \"${this.tableName}\": ID contains invalid characters`)\n    }\n\n    return value as string & { __tableName: TableName }\n  }\n\n  describe(): string {\n    return `v.id(\"${this.tableName}\")`\n  }\n}\n\n// ============================================================================\n// Complex Validators\n// ============================================================================\n\ntype ObjectShape = Record<string, Validator>\ntype InferObject<T extends ObjectShape> = {\n  [K in keyof T]: Infer<T[K]>\n}\n\ntype ObjectMode = 'strip' | 'strict' | 'passthrough'\n\nclass ObjectValidator<T extends ObjectShape> extends BaseValidator<InferObject<T>> {\n  readonly _type!: InferObject<T>\n  private shape: T\n  private mode: ObjectMode\n\n  constructor(shape: T, mode: ObjectMode = 'strip') {\n    super()\n    this.shape = shape\n    this.mode = mode\n  }\n\n  parse(value: unknown): InferObject<T> {\n    return withContext(() => this.parseInternal(value))\n  }\n\n  private parseInternal(value: unknown): InferObject<T> {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`Expected object, got ${value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value}`)\n    }\n\n    const result: Record<string, unknown> = {}\n    const obj = value as Record<string, unknown>\n    const schemaKeys = new Set(Object.keys(this.shape))\n\n    // Check for extra fields in strict mode\n    if (this.mode === 'strict') {\n      for (const key of Object.keys(obj)) {\n        if (!schemaKeys.has(key)) {\n          throw new Error(`Unexpected field \"${key}\" in object`)\n        }\n      }\n    }\n\n    // Validate schema fields\n    for (const [key, validator] of Object.entries(this.shape)) {\n      const fieldValue = obj[key]\n      if (fieldValue === undefined && !validator.isOptional) {\n        throw new Error(`Missing required field \"${key}\"`)\n      }\n      if (fieldValue !== undefined) {\n        pushPath(key)\n        try {\n          result[key] = validator.parse(fieldValue)\n        } catch (e) {\n          const path = getPathString()\n          const innerMsg = (e as Error).message\n          throw new Error(path ? `Validation error at ${path}: ${innerMsg}` : innerMsg)\n        } finally {\n          popPath()\n        }\n      }\n    }\n\n    // In passthrough mode, include extra fields\n    if (this.mode === 'passthrough') {\n      for (const key of Object.keys(obj)) {\n        if (!schemaKeys.has(key)) {\n          result[key] = obj[key]\n        }\n      }\n    }\n\n    return result as InferObject<T>\n  }\n\n  describe(): string {\n    const fields = Object.entries(this.shape)\n      .map(([key, v]) => `${key}: ${v.describe()}`)\n      .join(', ')\n    return `{ ${fields} }`\n  }\n\n  /**\n   * Returns a new validator that throws on extra fields.\n   */\n  strict(): ObjectValidator<T> {\n    return new ObjectValidator(this.shape, 'strict')\n  }\n\n  /**\n   * Returns a new validator that passes through extra fields.\n   */\n  passthrough(): ObjectValidator<T> {\n    return new ObjectValidator(this.shape, 'passthrough')\n  }\n\n  /**\n   * Returns a new validator with additional fields.\n   */\n  extend<U extends ObjectShape>(additionalShape: U): ObjectValidator<T & U> {\n    return new ObjectValidator({ ...this.shape, ...additionalShape } as T & U, this.mode)\n  }\n\n  /**\n   * Returns a new validator with only the specified fields.\n   */\n  pick<K extends keyof T>(keys: K[]): ObjectValidator<Pick<T, K>> {\n    const newShape: Partial<T> = {}\n    for (const key of keys) {\n      if (key in this.shape) {\n        newShape[key] = this.shape[key]\n      }\n    }\n    return new ObjectValidator(newShape as Pick<T, K>, this.mode)\n  }\n\n  /**\n   * Returns a new validator without the specified fields.\n   */\n  omit<K extends keyof T>(keys: K[]): ObjectValidator<Omit<T, K>> {\n    const keysToOmit = new Set(keys as (string | number | symbol)[])\n    const newShape: Partial<T> = {}\n    for (const [key, validator] of Object.entries(this.shape)) {\n      if (!keysToOmit.has(key)) {\n        (newShape as Record<string, unknown>)[key] = validator\n      }\n    }\n    return new ObjectValidator(newShape as Omit<T, K>, this.mode)\n  }\n}\n\ninterface ArrayConstraints {\n  minLength?: number\n  maxLength?: number\n  exactLength?: number\n}\n\nclass ArrayValidator<T extends Validator> extends BaseValidator<Infer<T>[]> {\n  readonly _type!: Infer<T>[]\n  private element: T\n  private constraints: ArrayConstraints\n\n  constructor(element: T, constraints: ArrayConstraints = {}) {\n    super()\n    this.element = element\n    this.constraints = constraints\n  }\n\n  parse(value: unknown): Infer<T>[] {\n    if (!Array.isArray(value)) {\n      throw new Error(`Expected array, got ${value === null ? 'null' : typeof value}`)\n    }\n\n    // Check length constraints\n    if (this.constraints.minLength !== undefined && value.length < this.constraints.minLength) {\n      throw new Error(`Array must have at least ${this.constraints.minLength} element(s), got ${value.length}`)\n    }\n    if (this.constraints.maxLength !== undefined && value.length > this.constraints.maxLength) {\n      throw new Error(`Array must have at most ${this.constraints.maxLength} element(s), got ${value.length}`)\n    }\n    if (this.constraints.exactLength !== undefined && value.length !== this.constraints.exactLength) {\n      throw new Error(`Array must have exactly ${this.constraints.exactLength} element(s), got ${value.length}`)\n    }\n\n    return value.map((item, index) => {\n      pushPath(index)\n      try {\n        return this.element.parse(item)\n      } catch (e) {\n        const path = getPathString()\n        const innerMsg = (e as Error).message\n        throw new Error(path ? `Invalid element at index ${index}: ${innerMsg}` : `Invalid array element at index ${index}: ${innerMsg}`)\n      } finally {\n        popPath()\n      }\n    })\n  }\n\n  describe(): string {\n    return `${this.element.describe()}[]`\n  }\n\n  /**\n   * Returns a new validator that requires at least one element.\n   */\n  nonempty(): ArrayValidator<T> {\n    return new ArrayValidator(this.element, { ...this.constraints, minLength: 1 })\n  }\n\n  /**\n   * Returns a new validator with a minimum length constraint.\n   */\n  min(minLength: number): ArrayValidator<T> {\n    return new ArrayValidator(this.element, { ...this.constraints, minLength })\n  }\n\n  /**\n   * Returns a new validator with a maximum length constraint.\n   */\n  max(maxLength: number): ArrayValidator<T> {\n    return new ArrayValidator(this.element, { ...this.constraints, maxLength })\n  }\n\n  /**\n   * Returns a new validator with an exact length constraint.\n   */\n  length(exactLength: number): ArrayValidator<T> {\n    return new ArrayValidator(this.element, { ...this.constraints, exactLength })\n  }\n}\n\ntype InferUnion<T extends Validator[]> = T[number] extends Validator<infer U> ? U : never\n\nclass UnionValidator<T extends Validator[]> extends BaseValidator<InferUnion<T>> {\n  readonly _type!: InferUnion<T>\n  private validators: T\n\n  constructor(validators: T) {\n    super()\n    this.validators = validators\n  }\n\n  parse(value: unknown): InferUnion<T> {\n    const errors: string[] = []\n\n    for (const validator of this.validators) {\n      try {\n        return validator.parse(value) as InferUnion<T>\n      } catch (e) {\n        errors.push((e as Error).message)\n      }\n    }\n\n    throw new Error(`Value doesn't match any variant: ${errors.join('; ')}`)\n  }\n\n  describe(): string {\n    return this.validators.map(v => v.describe()).join(' | ')\n  }\n}\n\nclass OptionalValidator<T> extends BaseValidator<T | undefined, true> {\n  readonly _type!: T | undefined\n  override readonly isOptional: true = true\n  private inner: Validator<T>\n\n  constructor(inner: Validator<T>) {\n    super()\n    this.inner = inner\n  }\n\n  parse(value: unknown): T | undefined {\n    if (value === undefined) {\n      return undefined\n    }\n    return this.inner.parse(value)\n  }\n\n  describe(): string {\n    return `${this.inner.describe()} | undefined`\n  }\n\n  override optional(): OptionalValidator<T | undefined> {\n    return this as unknown as OptionalValidator<T | undefined>\n  }\n\n  /**\n   * Returns a new validator that provides a default value when undefined.\n   */\n  default(defaultValue: T): DefaultValidator<T> {\n    return new DefaultValidator(this.inner, defaultValue)\n  }\n}\n\nclass DefaultValidator<T> extends BaseValidator<T, true> {\n  readonly _type!: T\n  override readonly isOptional: true = true\n  private inner: Validator<T>\n  private defaultValue: T\n\n  constructor(inner: Validator<T>, defaultValue: T) {\n    super()\n    this.inner = inner\n    this.defaultValue = defaultValue\n  }\n\n  parse(value: unknown): T {\n    if (value === undefined) {\n      return this.defaultValue\n    }\n    return this.inner.parse(value)\n  }\n\n  describe(): string {\n    return `${this.inner.describe()} (default: ${JSON.stringify(this.defaultValue)})`\n  }\n}\n\nclass LiteralValidator<T extends string | number | boolean> extends BaseValidator<T> {\n  readonly _type!: T\n  private literal: T\n\n  constructor(literal: T) {\n    super()\n    this.literal = literal\n  }\n\n  parse(value: unknown): T {\n    if (value !== this.literal) {\n      throw new Error(`Expected literal ${JSON.stringify(this.literal)}, got ${JSON.stringify(value)}`)\n    }\n    return value as T\n  }\n\n  describe(): string {\n    return JSON.stringify(this.literal)\n  }\n}\n\nclass RecordValidator<K extends Validator<string>, V extends Validator> extends BaseValidator<Record<Infer<K>, Infer<V>>> {\n  readonly _type!: Record<Infer<K>, Infer<V>>\n  private keys: K\n  private values: V\n\n  constructor(keys: K, values: V) {\n    super()\n    this.keys = keys\n    this.values = values\n  }\n\n  parse(value: unknown): Record<Infer<K>, Infer<V>> {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`Expected record/object, got ${value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value}`)\n    }\n\n    const result: Record<string, unknown> = {}\n    const obj = value as Record<string, unknown>\n\n    for (const [key, val] of Object.entries(obj)) {\n      try {\n        this.keys.parse(key)\n      } catch (e) {\n        throw new Error(`Invalid key \"${key}\": ${(e as Error).message}`)\n      }\n      try {\n        result[key] = this.values.parse(val)\n      } catch (e) {\n        throw new Error(`Invalid value for key \"${key}\": ${(e as Error).message}`)\n      }\n    }\n\n    return result as Record<Infer<K>, Infer<V>>\n  }\n\n  describe(): string {\n    return `Record<${this.keys.describe()}, ${this.values.describe()}>`\n  }\n}\n\nclass AnyValidator extends BaseValidator<unknown> {\n  readonly _type!: unknown\n\n  parse(value: unknown): unknown {\n    return value\n  }\n\n  describe(): string {\n    return 'any'\n  }\n}\n\nclass UnknownValidator extends BaseValidator<unknown> {\n  readonly _type!: unknown\n\n  parse(value: unknown): unknown {\n    return value\n  }\n\n  describe(): string {\n    return 'unknown'\n  }\n}\n\nclass NullableValidator<T> extends BaseValidator<T | null> {\n  readonly _type!: T | null\n  private inner: Validator<T>\n\n  constructor(inner: Validator<T>) {\n    super()\n    this.inner = inner\n  }\n\n  parse(value: unknown): T | null {\n    if (value === null) {\n      return null\n    }\n    return this.inner.parse(value)\n  }\n\n  describe(): string {\n    return `${this.inner.describe()} | null`\n  }\n}\n\nclass NullishValidator<T> extends BaseValidator<T | null | undefined, true> {\n  readonly _type!: T | null | undefined\n  override readonly isOptional: true = true\n  private inner: Validator<T>\n\n  constructor(inner: Validator<T>) {\n    super()\n    this.inner = inner\n  }\n\n  parse(value: unknown): T | null | undefined {\n    if (value === null) {\n      return null\n    }\n    if (value === undefined) {\n      return undefined\n    }\n    return this.inner.parse(value)\n  }\n\n  describe(): string {\n    return `${this.inner.describe()} | null | undefined`\n  }\n}\n\nclass DiscriminatedUnionValidator<T extends Validator[]> extends BaseValidator<InferUnion<T>> {\n  readonly _type!: InferUnion<T>\n  private discriminator: string\n  private validators: T\n\n  constructor(discriminator: string, validators: T) {\n    super()\n    this.discriminator = discriminator\n    this.validators = validators\n  }\n\n  parse(value: unknown): InferUnion<T> {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`Expected object with discriminator \"${this.discriminator}\", got ${value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value}`)\n    }\n\n    // Try each validator\n    const errors: string[] = []\n    for (const validator of this.validators) {\n      try {\n        return validator.parse(value) as InferUnion<T>\n      } catch (e) {\n        errors.push((e as Error).message)\n      }\n    }\n\n    throw new Error(`Value doesn't match any variant for discriminator \"${this.discriminator}\": ${errors.join('; ')}`)\n  }\n\n  describe(): string {\n    return this.validators.map(v => v.describe()).join(' | ')\n  }\n}\n\n// ============================================================================\n// Validator Factory (v namespace)\n// ============================================================================\n\n/**\n * The v namespace provides factory functions for creating validators.\n * This is 100% compatible with Convex's v validators.\n */\nexport const v = {\n  // Primitives\n  string: () => new StringValidator(),\n  number: () => new NumberValidator(),\n  boolean: () => new BooleanValidator(),\n  null: () => new NullValidator(),\n  int64: () => new Int64Validator(),\n  float64: () => new Float64Validator(),\n  bytes: () => new BytesValidator(),\n\n  // ID type\n  id: <T extends string>(tableName: T) => new IdValidator(tableName),\n\n  // Complex types\n  object: <T extends ObjectShape>(shape: T) => new ObjectValidator(shape),\n  array: <T extends Validator>(element: T) => new ArrayValidator(element),\n  union: <T extends Validator[]>(...validators: T) => new UnionValidator(validators),\n  optional: <T extends Validator>(validator: T) => new OptionalValidator(validator as Validator<Infer<T>>),\n  literal: <T extends string | number | boolean>(value: T) => new LiteralValidator(value),\n  record: <K extends Validator<string>, V extends Validator>(keys: K | V, values?: V) => {\n    // Support both v.record(keyValidator, valueValidator) and v.record(valueValidator) syntaxes\n    if (values === undefined) {\n      // Shorthand: v.record(valueValidator) - keys are implicitly strings\n      return new RecordValidator(new StringValidator(), keys as V)\n    }\n    return new RecordValidator(keys as K, values)\n  },\n  any: () => new AnyValidator(),\n  unknown: () => new UnknownValidator(),\n  nullable: <T extends Validator>(validator: T) => new NullableValidator(validator as Validator<Infer<T>>),\n  nullish: <T extends Validator>(validator: T) => new NullishValidator(validator as Validator<Infer<T>>),\n  discriminatedUnion: <T extends Validator[]>(discriminator: string, validators: T) => new DiscriminatedUnionValidator(discriminator, validators),\n} as const\n\n// ============================================================================\n// Type utilities\n// ============================================================================\n\n/**\n * Args validator type for function definitions.\n */\nexport type ArgsValidator = Validator<Record<string, unknown>> | Record<string, Validator>\n\n/**\n * Infer args type from an args validator.\n */\nexport type InferArgs<T extends ArgsValidator> = T extends Validator<infer U>\n  ? U\n  : T extends Record<string, Validator>\n  ? { [K in keyof T]: Infer<T[K]> }\n  : never\n\n","/**\n * Query function builder\n *\n * Creates read-only, deterministic query functions.\n */\n\nimport type { Validator, Infer, ArgsValidator } from '../values'\nimport type { QueryCtx } from './context'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Configuration for a query function.\n */\nexport interface QueryConfig<\n  Args extends ArgsValidator | undefined,\n  Returns\n> {\n  /** Argument validators (optional) */\n  args?: Args\n  /** Return type validator (optional) */\n  returns?: Validator<Returns>\n  /** The query handler function */\n  handler: (\n    ctx: QueryCtx,\n    args: Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>\n  ) => Returns | Promise<Returns>\n}\n\n/**\n * A registered query function.\n */\nexport interface RegisteredQuery<\n  Args extends ArgsValidator | undefined,\n  Returns\n> {\n  /** Internal marker for query type */\n  readonly _type: 'query'\n  /** Internal marker for args type */\n  readonly _args: Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>\n  /** Internal marker for return type */\n  readonly _returns: Returns\n  /** Visibility: public or internal */\n  readonly _visibility: 'public' | 'internal'\n  /** The configuration */\n  readonly _config: QueryConfig<Args, Returns>\n}\n\n// Helper type for inferring args from validator\ntype InferArgs<T extends ArgsValidator> = T extends Validator<infer U>\n  ? U\n  : T extends Record<string, Validator>\n  ? { [K in keyof T]: Infer<T[K]> }\n  : never\n\n// ============================================================================\n// Query Builder\n// ============================================================================\n\n/**\n * Create a public query function.\n *\n * Queries are read-only, deterministic functions that can read from the database.\n * They automatically participate in real-time subscriptions.\n *\n * @example\n * ```typescript\n * import { query } from \"convex.do/server\";\n * import { v } from \"convex.do/values\";\n *\n * export const listMessages = query({\n *   args: { channel: v.id(\"channels\") },\n *   handler: async (ctx, args) => {\n *     return await ctx.db\n *       .query(\"messages\")\n *       .withIndex(\"by_channel\", (q) => q.eq(\"channel\", args.channel))\n *       .collect();\n *   },\n * });\n * ```\n */\nexport function query<\n  Args extends ArgsValidator | undefined = undefined,\n  Returns = unknown\n>(\n  config: QueryConfig<Args, Returns>\n): RegisteredQuery<Args, Returns> {\n  return {\n    _type: 'query',\n    _args: undefined as unknown as Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>,\n    _returns: undefined as unknown as Returns,\n    _visibility: 'public',\n    _config: config,\n  }\n}\n\n/**\n * Create an internal query function.\n *\n * Internal queries can only be called from other functions, not from clients.\n *\n * @example\n * ```typescript\n * import { internalQuery } from \"convex.do/server\";\n *\n * export const getUser = internalQuery({\n *   args: { userId: v.id(\"users\") },\n *   handler: async (ctx, args) => {\n *     return await ctx.db.get(args.userId);\n *   },\n * });\n * ```\n */\nexport function internalQuery<\n  Args extends ArgsValidator | undefined = undefined,\n  Returns = unknown\n>(\n  config: QueryConfig<Args, Returns>\n): RegisteredQuery<Args, Returns> {\n  return {\n    _type: 'query',\n    _args: undefined as unknown as Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>,\n    _returns: undefined as unknown as Returns,\n    _visibility: 'internal',\n    _config: config,\n  }\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Extract the args type from a registered query.\n */\nexport type QueryArgs<Q extends RegisteredQuery<ArgsValidator | undefined, unknown>> =\n  Q['_args']\n\n/**\n * Extract the return type from a registered query.\n */\nexport type QueryReturns<Q extends RegisteredQuery<ArgsValidator | undefined, unknown>> =\n  Q['_returns']\n","/**\n * Mutation function builder\n *\n * Creates functions that can read and write to the database.\n */\n\nimport type { Validator, Infer, ArgsValidator } from '../values'\nimport type { MutationCtx } from './context'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Configuration for a mutation function.\n */\nexport interface MutationConfig<\n  Args extends ArgsValidator | undefined,\n  Returns\n> {\n  /** Argument validators (optional) */\n  args?: Args\n  /** Return type validator (optional) */\n  returns?: Validator<Returns>\n  /** The mutation handler function */\n  handler: (\n    ctx: MutationCtx,\n    args: Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>\n  ) => Returns | Promise<Returns>\n}\n\n/**\n * A registered mutation function.\n */\nexport interface RegisteredMutation<\n  Args extends ArgsValidator | undefined,\n  Returns\n> {\n  /** Internal marker for mutation type */\n  readonly _type: 'mutation'\n  /** Internal marker for args type */\n  readonly _args: Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>\n  /** Internal marker for return type */\n  readonly _returns: Returns\n  /** Visibility: public or internal */\n  readonly _visibility: 'public' | 'internal'\n  /** The configuration */\n  readonly _config: MutationConfig<Args, Returns>\n}\n\n// Helper type for inferring args from validator\ntype InferArgs<T extends ArgsValidator> = T extends Validator<infer U>\n  ? U\n  : T extends Record<string, Validator>\n  ? { [K in keyof T]: Infer<T[K]> }\n  : never\n\n// ============================================================================\n// Mutation Builder\n// ============================================================================\n\n/**\n * Create a public mutation function.\n *\n * Mutations can read and write to the database. They run in a transaction\n * and are automatically retried on conflicts.\n *\n * @example\n * ```typescript\n * import { mutation } from \"convex.do/server\";\n * import { v } from \"convex.do/values\";\n *\n * export const sendMessage = mutation({\n *   args: {\n *     channel: v.id(\"channels\"),\n *     body: v.string(),\n *   },\n *   handler: async (ctx, args) => {\n *     const identity = await ctx.auth.getUserIdentity();\n *     if (!identity) throw new Error(\"Not authenticated\");\n *\n *     return await ctx.db.insert(\"messages\", {\n *       channel: args.channel,\n *       body: args.body,\n *       author: identity.tokenIdentifier,\n *     });\n *   },\n * });\n * ```\n */\nexport function mutation<\n  Args extends ArgsValidator | undefined = undefined,\n  Returns = unknown\n>(\n  config: MutationConfig<Args, Returns>\n): RegisteredMutation<Args, Returns> {\n  return {\n    _type: 'mutation',\n    _args: undefined as unknown as Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>,\n    _returns: undefined as unknown as Returns,\n    _visibility: 'public',\n    _config: config,\n  }\n}\n\n/**\n * Create an internal mutation function.\n *\n * Internal mutations can only be called from other functions, not from clients.\n *\n * @example\n * ```typescript\n * import { internalMutation } from \"convex.do/server\";\n *\n * export const updateUserStats = internalMutation({\n *   args: { userId: v.id(\"users\"), increment: v.number() },\n *   handler: async (ctx, args) => {\n *     const user = await ctx.db.get(args.userId);\n *     if (!user) throw new Error(\"User not found\");\n *\n *     await ctx.db.patch(args.userId, {\n *       messageCount: (user.messageCount ?? 0) + args.increment,\n *     });\n *   },\n * });\n * ```\n */\nexport function internalMutation<\n  Args extends ArgsValidator | undefined = undefined,\n  Returns = unknown\n>(\n  config: MutationConfig<Args, Returns>\n): RegisteredMutation<Args, Returns> {\n  return {\n    _type: 'mutation',\n    _args: undefined as unknown as Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>,\n    _returns: undefined as unknown as Returns,\n    _visibility: 'internal',\n    _config: config,\n  }\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Extract the args type from a registered mutation.\n */\nexport type MutationArgs<M extends RegisteredMutation<ArgsValidator | undefined, unknown>> =\n  M['_args']\n\n/**\n * Extract the return type from a registered mutation.\n */\nexport type MutationReturns<M extends RegisteredMutation<ArgsValidator | undefined, unknown>> =\n  M['_returns']\n","/**\n * Action function builder\n *\n * Creates functions that can perform arbitrary operations including external API calls.\n */\n\nimport type { Validator, Infer, ArgsValidator } from '../values'\nimport type { ActionCtx } from './context'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Configuration for an action function.\n */\nexport interface ActionConfig<\n  Args extends ArgsValidator | undefined,\n  Returns\n> {\n  /** Argument validators (optional) */\n  args?: Args\n  /** Return type validator (optional) */\n  returns?: Validator<Returns>\n  /** The action handler function */\n  handler: (\n    ctx: ActionCtx,\n    args: Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>\n  ) => Returns | Promise<Returns>\n}\n\n/**\n * A registered action function.\n */\nexport interface RegisteredAction<\n  Args extends ArgsValidator | undefined,\n  Returns\n> {\n  /** Internal marker for action type */\n  readonly _type: 'action'\n  /** Internal marker for args type */\n  readonly _args: Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>\n  /** Internal marker for return type */\n  readonly _returns: Returns\n  /** Visibility: public or internal */\n  readonly _visibility: 'public' | 'internal'\n  /** The configuration */\n  readonly _config: ActionConfig<Args, Returns>\n}\n\n// Helper type for inferring args from validator\ntype InferArgs<T extends ArgsValidator> = T extends Validator<infer U>\n  ? U\n  : T extends Record<string, Validator>\n  ? { [K in keyof T]: Infer<T[K]> }\n  : never\n\n// ============================================================================\n// Action Builder\n// ============================================================================\n\n/**\n * Create a public action function.\n *\n * Actions can perform arbitrary operations including:\n * - External API calls (fetch)\n * - Non-deterministic operations\n * - Long-running computations\n *\n * Actions cannot directly access the database but can call queries and mutations.\n *\n * @example\n * ```typescript\n * import { action } from \"convex.do/server\";\n * import { v } from \"convex.do/values\";\n * import { api } from \"./_generated/api\";\n *\n * export const sendEmail = action({\n *   args: {\n *     to: v.string(),\n *     subject: v.string(),\n *     body: v.string(),\n *   },\n *   handler: async (ctx, args) => {\n *     // Call external API\n *     const response = await fetch(\"https://api.sendgrid.com/v3/mail/send\", {\n *       method: \"POST\",\n *       headers: {\n *         \"Content-Type\": \"application/json\",\n *         \"Authorization\": `Bearer ${process.env.SENDGRID_API_KEY}`,\n *       },\n *       body: JSON.stringify({\n *         personalizations: [{ to: [{ email: args.to }] }],\n *         from: { email: \"noreply@example.com\" },\n *         subject: args.subject,\n *         content: [{ type: \"text/plain\", value: args.body }],\n *       }),\n *     });\n *\n *     if (!response.ok) {\n *       throw new Error(`Failed to send email: ${response.statusText}`);\n *     }\n *\n *     // Record the email in the database\n *     await ctx.runMutation(api.emails.record, {\n *       to: args.to,\n *       subject: args.subject,\n *       sentAt: Date.now(),\n *     });\n *\n *     return { success: true };\n *   },\n * });\n * ```\n */\nexport function action<\n  Args extends ArgsValidator | undefined = undefined,\n  Returns = unknown\n>(\n  config: ActionConfig<Args, Returns>\n): RegisteredAction<Args, Returns> {\n  return {\n    _type: 'action',\n    _args: undefined as unknown as Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>,\n    _returns: undefined as unknown as Returns,\n    _visibility: 'public',\n    _config: config,\n  }\n}\n\n/**\n * Create an internal action function.\n *\n * Internal actions can only be called from other functions, not from clients.\n *\n * @example\n * ```typescript\n * import { internalAction } from \"convex.do/server\";\n *\n * export const processWebhook = internalAction({\n *   args: { payload: v.any() },\n *   handler: async (ctx, args) => {\n *     // Process webhook payload\n *     const result = await processPayload(args.payload);\n *\n *     // Update database\n *     await ctx.runMutation(api.webhooks.record, {\n *       payload: args.payload,\n *       result,\n *     });\n *\n *     return result;\n *   },\n * });\n * ```\n */\nexport function internalAction<\n  Args extends ArgsValidator | undefined = undefined,\n  Returns = unknown\n>(\n  config: ActionConfig<Args, Returns>\n): RegisteredAction<Args, Returns> {\n  return {\n    _type: 'action',\n    _args: undefined as unknown as Args extends ArgsValidator ? InferArgs<Args> : Record<string, never>,\n    _returns: undefined as unknown as Returns,\n    _visibility: 'internal',\n    _config: config,\n  }\n}\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Extract the args type from a registered action.\n */\nexport type ActionArgs<A extends RegisteredAction<ArgsValidator | undefined, unknown>> =\n  A['_args']\n\n/**\n * Extract the return type from a registered action.\n */\nexport type ActionReturns<A extends RegisteredAction<ArgsValidator | undefined, unknown>> =\n  A['_returns']\n","/**\n * HTTP Router for custom HTTP endpoints\n *\n * Allows defining custom HTTP routes that can handle webhooks, APIs, etc.\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * HTTP methods supported by the router.\n */\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD'\n\n/**\n * Context for HTTP action handlers.\n */\nexport interface HttpActionCtx {\n  /** Run a query */\n  runQuery<T>(query: unknown, args: unknown): Promise<T>\n  /** Run a mutation */\n  runMutation<T>(mutation: unknown, args: unknown): Promise<T>\n  /** Run an action */\n  runAction<T>(action: unknown, args: unknown): Promise<T>\n  /** Storage operations */\n  storage: {\n    getUrl(storageId: string): Promise<string | null>\n    generateUploadUrl(): Promise<string>\n  }\n}\n\n/**\n * Enhanced Request with path parameters.\n */\nexport interface HttpRequest extends Request {\n  /** Extracted path parameters from the route pattern */\n  params: Record<string, string>\n}\n\n/**\n * HTTP action handler function.\n */\nexport type HttpActionHandler = (\n  ctx: HttpActionCtx,\n  request: Request & { params?: Record<string, string> }\n) => Promise<Response>\n\n/**\n * HTTP action configuration.\n */\nexport interface HttpActionConfig {\n  /** Path pattern (e.g., \"/webhooks/stripe\") */\n  path: string\n  /** HTTP method */\n  method: HttpMethod\n  /** Handler function */\n  handler: HttpActionHandler\n}\n\n/**\n * A registered HTTP action.\n */\nexport interface RegisteredHttpAction {\n  readonly _type: 'httpAction'\n  readonly _config: HttpActionConfig\n}\n\n/**\n * Route definition in the router.\n */\nexport interface RouteDefinition {\n  path: string\n  method: HttpMethod\n  handler: HttpActionHandler\n}\n\n// ============================================================================\n// HTTP Router\n// ============================================================================\n\n/**\n * HTTP Router class for managing routes.\n */\nexport class HttpRouter {\n  private routes: RouteDefinition[] = []\n\n  /**\n   * Add a route for any HTTP method.\n   */\n  route(config: {\n    path: string\n    method: HttpMethod\n    handler: RegisteredHttpAction\n  }): this {\n    this.routes.push({\n      path: config.path,\n      method: config.method,\n      handler: config.handler._config.handler,\n    })\n    return this\n  }\n\n  /**\n   * Add a GET route.\n   */\n  get(path: string, handler: RegisteredHttpAction): this {\n    return this.route({ path, method: 'GET', handler })\n  }\n\n  /**\n   * Add a POST route.\n   */\n  post(path: string, handler: RegisteredHttpAction): this {\n    return this.route({ path, method: 'POST', handler })\n  }\n\n  /**\n   * Add a PUT route.\n   */\n  put(path: string, handler: RegisteredHttpAction): this {\n    return this.route({ path, method: 'PUT', handler })\n  }\n\n  /**\n   * Add a PATCH route.\n   */\n  patch(path: string, handler: RegisteredHttpAction): this {\n    return this.route({ path, method: 'PATCH', handler })\n  }\n\n  /**\n   * Add a DELETE route.\n   */\n  delete(path: string, handler: RegisteredHttpAction): this {\n    return this.route({ path, method: 'DELETE', handler })\n  }\n\n  /**\n   * Add an OPTIONS route.\n   */\n  options(path: string, handler: RegisteredHttpAction): this {\n    return this.route({ path, method: 'OPTIONS', handler })\n  }\n\n  /**\n   * Add a HEAD route.\n   */\n  head(path: string, handler: RegisteredHttpAction): this {\n    return this.route({ path, method: 'HEAD', handler })\n  }\n\n  /**\n   * Get all registered routes.\n   */\n  getRoutes(): readonly RouteDefinition[] {\n    return this.routes\n  }\n\n  /**\n   * Match a request to a route.\n   */\n  match(request: Request): RouteDefinition | null {\n    const url = new URL(request.url)\n    const method = request.method as HttpMethod\n    const path = url.pathname\n\n    for (const route of this.routes) {\n      if (route.method === method && this.pathMatches(route.path, path)) {\n        return route\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Handle an incoming HTTP request.\n   * Matches the request to a route and executes the handler.\n   *\n   * @param ctx - The HTTP action context\n   * @param request - The incoming request\n   * @returns The response from the handler, or null if no route matches\n   */\n  async handle(ctx: HttpActionCtx, request: Request): Promise<Response | null> {\n    const route = this.match(request)\n    if (!route) {\n      return null\n    }\n\n    const enhancedRequest = this.createRequest(request, route.path)\n    return route.handler(ctx, enhancedRequest)\n  }\n\n  /**\n   * Create an enhanced request with path parameters extracted.\n   *\n   * @param request - The original request\n   * @param pattern - The route pattern to extract params from\n   * @returns An enhanced request with params property\n   */\n  createRequest(request: Request, pattern: string): Request & { params: Record<string, string> } {\n    const url = new URL(request.url)\n    const params = this.extractParams(pattern, url.pathname)\n\n    // Create a proxy that adds params to the request\n    const enhancedRequest = Object.assign(request, { params }) as Request & {\n      params: Record<string, string>\n    }\n\n    return enhancedRequest\n  }\n\n  /**\n   * Check if a path matches a route pattern.\n   * Supports simple patterns like \"/api/users/:id\" and wildcards like \"/api/*\"\n   */\n  private pathMatches(pattern: string, path: string): boolean {\n    // Exact match\n    if (pattern === path) return true\n\n    // Pattern matching with path parameters\n    const patternParts = pattern.split('/')\n    const pathParts = path.split('/')\n\n    // Check for wildcard at the end\n    const lastPatternPart = patternParts[patternParts.length - 1]\n    if (lastPatternPart?.startsWith('*')) {\n      // Wildcard matches any remaining path segments\n      // Check that all parts before the wildcard match\n      for (let i = 0; i < patternParts.length - 1; i++) {\n        const patternPart = patternParts[i]\n        const pathPart = pathParts[i]\n\n        if (patternPart?.startsWith(':')) continue\n        if (patternPart !== pathPart) return false\n      }\n\n      // Wildcard matches if there are remaining path parts\n      return pathParts.length >= patternParts.length\n    }\n\n    // Non-wildcard: lengths must match\n    if (patternParts.length !== pathParts.length) return false\n\n    for (let i = 0; i < patternParts.length; i++) {\n      const patternPart = patternParts[i]\n      const pathPart = pathParts[i]\n\n      // Path parameter (e.g., \":id\")\n      if (patternPart?.startsWith(':')) continue\n\n      // Exact match required\n      if (patternPart !== pathPart) return false\n    }\n\n    return true\n  }\n\n  /**\n   * Extract path parameters from a request.\n   * Supports named parameters (e.g., \":id\") and wildcards (e.g., \"*path\").\n   */\n  extractParams(pattern: string, path: string): Record<string, string> {\n    const params: Record<string, string> = {}\n    const patternParts = pattern.split('/')\n    const pathParts = path.split('/')\n\n    for (let i = 0; i < patternParts.length; i++) {\n      const patternPart = patternParts[i]\n      const pathPart = pathParts[i]\n\n      if (patternPart?.startsWith(':') && pathPart) {\n        // Named parameter (e.g., \":id\")\n        const paramName = patternPart.slice(1)\n        params[paramName] = pathPart\n      } else if (patternPart?.startsWith('*')) {\n        // Wildcard parameter (e.g., \"*path\")\n        const paramName = patternPart.slice(1) || 'wildcard'\n        // Capture all remaining path segments\n        params[paramName] = pathParts.slice(i).join('/')\n        break\n      }\n    }\n\n    return params\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\n/**\n * Create an HTTP router.\n *\n * @example\n * ```typescript\n * // convex/http.ts\n * import { httpRouter, httpAction } from \"convex.do/server\";\n * import { api } from \"./_generated/api\";\n *\n * const http = httpRouter();\n *\n * http.route({\n *   path: \"/webhooks/stripe\",\n *   method: \"POST\",\n *   handler: stripeWebhook,\n * });\n *\n * export default http;\n * ```\n */\nexport function httpRouter(): HttpRouter {\n  return new HttpRouter()\n}\n\n/**\n * Create an HTTP action handler.\n *\n * @example\n * ```typescript\n * import { httpAction } from \"convex.do/server\";\n * import { api } from \"./_generated/api\";\n *\n * export const stripeWebhook = httpAction(async (ctx, request) => {\n *   const body = await request.text();\n *   const signature = request.headers.get(\"stripe-signature\");\n *\n *   // Verify and process webhook\n *   await ctx.runMutation(api.payments.processWebhook, {\n *     body,\n *     signature,\n *   });\n *\n *   return new Response(\"OK\", { status: 200 });\n * });\n * ```\n */\nexport function httpAction(handler: HttpActionHandler): RegisteredHttpAction {\n  return {\n    _type: 'httpAction',\n    _config: {\n      path: '',\n      method: 'GET',\n      handler,\n    },\n  }\n}\n\n// ============================================================================\n// Export Types\n// ============================================================================\n\nexport type { HttpActionCtx, HttpActionHandler, HttpActionConfig, RouteDefinition }\n","/**\n * Schema definition system\n *\n * Provides defineSchema and defineTable for defining the database schema.\n */\n\nimport type { Validator, Infer } from '../values'\nimport { v } from '../values'\n\n/**\n * Validation error with path information.\n */\nexport interface ValidationError {\n  path: string\n  message: string\n}\n\n/**\n * Validation result for document validation.\n */\nexport interface ValidationResult {\n  valid: boolean\n  errors: Array<string | ValidationError>\n}\n\n// ============================================================================\n// Index Validation Helpers\n// ============================================================================\n\n/** Reserved index names that cannot be used */\nconst RESERVED_INDEX_NAMES = new Set(['by_creation_time', 'by_id'])\n\n/** Pattern for valid index names: must start with letter, contain only letters, numbers, underscores */\nconst VALID_INDEX_NAME_PATTERN = /^[a-zA-Z][a-zA-Z0-9_]*$/\n\n/** Pattern to detect array element access like tags[0] */\nconst ARRAY_ELEMENT_ACCESS_PATTERN = /\\[\\d+\\]/\n\n/**\n * Validates an index name.\n * @throws Error if the name is invalid\n */\nfunction validateIndexName(name: string): void {\n  // Reject empty string\n  if (name === '') {\n    throw new Error('Invalid index name: name cannot be empty')\n  }\n\n  // Reject whitespace-only names\n  if (name.trim() === '') {\n    throw new Error('Invalid index name: name cannot be whitespace-only')\n  }\n\n  // Reject names starting with underscore\n  if (name.startsWith('_')) {\n    throw new Error(`Index name \"${name}\" cannot start with an underscore`)\n  }\n\n  // Reject names starting with numbers\n  if (/^\\d/.test(name)) {\n    throw new Error(`Index name \"${name}\" cannot start with a number`)\n  }\n\n  // Reject names with special characters (hyphens, dots, spaces, @, #, $, !)\n  if (!VALID_INDEX_NAME_PATTERN.test(name)) {\n    throw new Error(`Index name \"${name}\" contains invalid characters. Only letters, numbers, and underscores are allowed`)\n  }\n\n  // Reject reserved names\n  if (RESERVED_INDEX_NAMES.has(name)) {\n    throw new Error(`Index name \"${name}\" is reserved and cannot be used`)\n  }\n}\n\n/**\n * Validates a field path exists in the document schema.\n * Supports dot notation for nested objects.\n * @throws Error if the field path is invalid or does not exist\n */\nfunction validateFieldPath(fieldPath: string, documentSchema: Record<string, Validator>): void {\n  // Reject empty string\n  if (fieldPath === '') {\n    throw new Error('Index field name cannot be empty')\n  }\n\n  // Reject whitespace-only\n  if (fieldPath.trim() === '') {\n    throw new Error('Index field name cannot be whitespace-only')\n  }\n\n  // Reject array element access (e.g., tags[0])\n  if (ARRAY_ELEMENT_ACCESS_PATTERN.test(fieldPath)) {\n    throw new Error(`Array element access is not supported in index fields: \"${fieldPath}\"`)\n  }\n\n  // Split the path by dots for nested fields\n  const pathParts = fieldPath.split('.')\n  let currentSchema: Record<string, Validator> | null = documentSchema\n\n  for (let i = 0; i < pathParts.length; i++) {\n    const part = pathParts[i]\n\n    if (!currentSchema || !(part in currentSchema)) {\n      const fullPath = pathParts.slice(0, i + 1).join('.')\n      throw new Error(`Field \"${fullPath}\" does not exist in document schema`)\n    }\n\n    const validator = currentSchema[part]\n\n    // If this is not the last part, we need to check if it's an object\n    if (i < pathParts.length - 1) {\n      // Check if the validator is an object validator by looking for shape property\n      // We need to access the internal shape of ObjectValidator\n      const validatorAny = validator as unknown as { shape?: Record<string, Validator> }\n\n      // Also handle optional fields that wrap an object\n      let innerShape: Record<string, Validator> | undefined = validatorAny.shape\n\n      // Check if it's an optional wrapping an object\n      if (!innerShape && 'isOptional' in validator && validator.isOptional) {\n        const optionalInner = (validator as unknown as { inner?: Validator }).inner\n        if (optionalInner) {\n          innerShape = (optionalInner as unknown as { shape?: Record<string, Validator> }).shape\n        }\n      }\n\n      if (!innerShape) {\n        throw new Error(`Cannot access nested field \"${pathParts[i + 1]}\" on non-object field \"${pathParts.slice(0, i + 1).join('.')}\"`)\n      }\n\n      currentSchema = innerShape\n    }\n  }\n}\n\n/**\n * Validates an array of index fields.\n * @throws Error if any field is invalid\n */\nfunction validateIndexFields(\n  fields: Array<string | { field: string; order: 'asc' | 'desc' }>,\n  documentSchema: Record<string, Validator>\n): void {\n  // Reject empty fields array\n  if (fields.length === 0) {\n    throw new Error('Index must have at least one field')\n  }\n\n  // Check for duplicates and validate each field\n  const seenFields = new Set<string>()\n  for (const field of fields) {\n    // Extract field name from string or object format\n    const fieldName = typeof field === 'string' ? field : field.field\n\n    if (seenFields.has(fieldName)) {\n      throw new Error(`Duplicate field \"${fieldName}\" in index`)\n    }\n    seenFields.add(fieldName)\n\n    // Validate the field exists\n    validateFieldPath(fieldName, documentSchema)\n  }\n}\n\n// ============================================================================\n// Table Definition Types\n// ============================================================================\n\n/**\n * Document shape definition using validators.\n */\nexport type DocumentDefinition = Record<string, Validator>\n\n/**\n * Index configuration.\n */\nexport interface IndexConfig {\n  /** Fields to index, in order */\n  fields: Array<string | { field: string; order: 'asc' | 'desc' }>\n  /** Whether this index enforces uniqueness */\n  unique?: boolean\n  /** Whether this is a sparse index (only indexes documents where field exists) */\n  sparse?: boolean\n}\n\n/**\n * Index options for advanced configuration.\n */\nexport interface IndexOptions {\n  /** Whether this index enforces uniqueness */\n  unique?: boolean\n  /** Whether this is a sparse index */\n  sparse?: boolean\n}\n\n/**\n * Search index configuration for full-text search.\n */\nexport interface SearchIndexConfig {\n  /** The field to search */\n  searchField: string\n  /** Additional fields to filter by */\n  filterFields?: string[]\n}\n\n/**\n * Vector index configuration for similarity search.\n */\nexport interface VectorIndexConfig {\n  /** The field containing the vector */\n  vectorField: string\n  /** Number of dimensions in the vector */\n  dimensions: number\n  /** Additional fields to filter by */\n  filterFields?: string[]\n}\n\n/**\n * A table definition with document schema and indexes.\n */\nexport interface TableDefinition<Doc extends DocumentDefinition = DocumentDefinition> {\n  /** Document field validators */\n  readonly document: Doc\n  /** Indexes defined on this table */\n  readonly indexes: Record<string, IndexConfig>\n  /** Search indexes defined on this table */\n  readonly searchIndexes: Record<string, SearchIndexConfig>\n  /** Vector indexes defined on this table */\n  readonly vectorIndexes: Record<string, VectorIndexConfig>\n}\n\n/**\n * Infer the document type from a table definition.\n */\nexport type InferDocument<T extends TableDefinition> = {\n  [K in keyof T['document']]: Infer<T['document'][K]>\n}\n\n// ============================================================================\n// Table Builder\n// ============================================================================\n\n/**\n * Builder for table definitions with fluent index API.\n */\nexport class TableBuilder<Doc extends DocumentDefinition> implements TableDefinition<Doc> {\n  readonly document: Doc\n  readonly indexes: Record<string, IndexConfig> = {}\n  readonly searchIndexes: Record<string, SearchIndexConfig> = {}\n  readonly vectorIndexes: Record<string, VectorIndexConfig> = {}\n\n  constructor(document: Doc) {\n    this.document = document\n    this.initConfig()\n  }\n\n  /**\n   * Define an index on the table.\n   *\n   * @example\n   * ```typescript\n   * defineTable({\n   *   channel: v.id(\"channels\"),\n   *   body: v.string(),\n   *   author: v.id(\"users\"),\n   * })\n   *   .index(\"by_channel\", [\"channel\"])\n   *   .index(\"by_author\", [\"author\", \"channel\"])\n   * ```\n   */\n  index(\n    name: string,\n    fields: Array<string | { field: string; order: 'asc' | 'desc' }>,\n    options?: IndexOptions\n  ): this {\n    // Validate index name\n    validateIndexName(name)\n\n    // Check for duplicate index name\n    if (name in this.indexes) {\n      throw new Error(`Duplicate index: \"${name}\" already exists on this table`)\n    }\n\n    // Validate fields array\n    validateIndexFields(fields, this.document)\n\n    // Build the index config\n    const indexConfig: IndexConfig = {\n      fields: fields,\n    }\n\n    // Add options if provided\n    if (options?.unique !== undefined) {\n      indexConfig.unique = options.unique\n    }\n    if (options?.sparse !== undefined) {\n      indexConfig.sparse = options.sparse\n    }\n\n    this.indexes[name] = indexConfig\n    return this\n  }\n\n  /**\n   * Define a search index for full-text search.\n   *\n   * @example\n   * ```typescript\n   * defineTable({\n   *   title: v.string(),\n   *   body: v.string(),\n   *   category: v.string(),\n   * })\n   *   .searchIndex(\"search_body\", {\n   *     searchField: \"body\",\n   *     filterFields: [\"category\"],\n   *   })\n   * ```\n   */\n  searchIndex(name: string, config: SearchIndexConfig): this {\n    // Validate index name\n    if (!name || name.trim() === '') {\n      throw new Error('Search index name is required and cannot be empty')\n    }\n\n    // Validate index name format (alphanumeric and underscore only)\n    if (!/^[a-zA-Z0-9_]+$/.test(name)) {\n      throw new Error(`Invalid search index name \"${name}\": name must contain only alphanumeric characters and underscores`)\n    }\n\n    // Check for duplicate search index names\n    if (this.searchIndexes[name]) {\n      throw new Error(`Duplicate search index name \"${name}\": a search index with this name already exists`)\n    }\n\n    // Validate searchField is present\n    if (!config || config.searchField === undefined || config.searchField === null) {\n      throw new Error('searchField is required for search index configuration')\n    }\n\n    // Validate searchField is a non-empty string\n    if (typeof config.searchField !== 'string' || config.searchField.trim() === '') {\n      throw new Error('searchField must be a non-empty string')\n    }\n\n    const searchField = config.searchField\n\n    // Validate searchField exists in schema and get the validator\n    const fieldValidator = this.resolveFieldPathForSearch(searchField)\n\n    // Check if the field is a string type\n    if (!this.isStringType(fieldValidator)) {\n      throw new Error(`searchField \"${searchField}\" must reference a string type field, got ${fieldValidator.describe()}`)\n    }\n\n    // Validate filterFields if present\n    if (config.filterFields) {\n      for (const filterField of config.filterFields) {\n        // Check if filterField is the same as searchField\n        if (filterField === searchField) {\n          throw new Error(`searchField \"${searchField}\" cannot also be in filterFields`)\n        }\n\n        // Validate filterField exists in schema\n        this.resolveFieldPathForSearch(filterField)\n      }\n    }\n\n    this.searchIndexes[name] = config\n    return this\n  }\n\n  /**\n   * Resolve a field path (including dot notation for nested fields) to a validator.\n   * @throws Error if the path doesn't exist or goes through non-object types\n   */\n  private resolveFieldPathForSearch(fieldPath: string): Validator {\n    const pathParts = fieldPath.split('.')\n    let currentSchema: Record<string, Validator> | null = this.document\n\n    for (let i = 0; i < pathParts.length; i++) {\n      const part = pathParts[i]\n\n      if (!currentSchema || !(part in currentSchema)) {\n        const fullPath = pathParts.slice(0, i + 1).join('.')\n        throw new Error(`Field \"${fullPath}\" does not exist in the document schema`)\n      }\n\n      const validator = currentSchema[part]\n\n      // If this is the last part, return the validator\n      if (i === pathParts.length - 1) {\n        return validator\n      }\n\n      // For intermediate parts, we need to check if it's an object and get its shape\n      const validatorAny = validator as unknown as { shape?: Record<string, Validator> }\n      let innerShape: Record<string, Validator> | undefined = validatorAny.shape\n\n      // Check if it's an optional wrapping an object\n      if (!innerShape && 'isOptional' in validator && validator.isOptional) {\n        const optionalInner = (validator as unknown as { inner?: Validator }).inner\n        if (optionalInner) {\n          innerShape = (optionalInner as unknown as { shape?: Record<string, Validator> }).shape\n        }\n      }\n\n      if (!innerShape) {\n        throw new Error(`Cannot access nested property \"${pathParts.slice(i + 1).join('.')}\" on non-object field \"${pathParts.slice(0, i + 1).join('.')}\"`)\n      }\n\n      currentSchema = innerShape\n    }\n\n    // Should never get here\n    throw new Error(`Field \"${fieldPath}\" does not exist in the document schema`)\n  }\n\n  /**\n   * Check if a validator represents a string type (including optional<string>).\n   */\n  private isStringType(validator: Validator): boolean {\n    const desc = validator.describe()\n\n    // Direct string type\n    if (desc === 'string') {\n      return true\n    }\n\n    // Optional string type: \"string | undefined\"\n    if (desc === 'string | undefined') {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Check if a validator represents an array type (including optional<array>).\n   */\n  private isArrayType(validator: Validator): boolean {\n    const desc = validator.describe()\n\n    // Check for array notation: type[]\n    if (desc.includes('[]')) {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Define a vector index for similarity search.\n   *\n   * @example\n   * ```typescript\n   * defineTable({\n   *   text: v.string(),\n   *   embedding: v.array(v.float64()),\n   *   category: v.string(),\n   * })\n   *   .vectorIndex(\"by_embedding\", {\n   *     vectorField: \"embedding\",\n   *     dimensions: 1536,\n   *     filterFields: [\"category\"],\n   *   })\n   * ```\n   */\n  vectorIndex(name: string, config: VectorIndexConfig): this {\n    // Validate index name\n    if (!name || name.trim() === '') {\n      throw new Error('Vector index name is required and cannot be empty')\n    }\n\n    // Check for duplicate vector index names\n    if (this.vectorIndexes[name]) {\n      throw new Error(`Duplicate vector index: \"${name}\" already exists on this table`)\n    }\n\n    // Validate vectorField exists in schema\n    if (!(config.vectorField in this.document)) {\n      throw new Error(`Field \"${config.vectorField}\" does not exist in the document schema`)\n    }\n\n    // Validate vectorField is an array type\n    const vectorFieldValidator = this.document[config.vectorField]\n    if (!this.isArrayType(vectorFieldValidator)) {\n      throw new Error(`Vector field \"${config.vectorField}\" must be an array type, got ${vectorFieldValidator.describe()}`)\n    }\n\n    // Validate dimensions is positive\n    if (config.dimensions <= 0) {\n      throw new Error(`Invalid dimensions: must be a positive number, got ${config.dimensions}`)\n    }\n\n    // Validate filterFields if present\n    if (config.filterFields) {\n      for (const filterField of config.filterFields) {\n        if (!(filterField in this.document)) {\n          throw new Error(`Filter field \"${filterField}\" does not exist in the document schema`)\n        }\n      }\n    }\n\n    this.vectorIndexes[name] = config\n    return this\n  }\n\n  /**\n   * Validate a document against the table schema.\n   */\n  validate(doc: unknown): ValidationResult {\n    const errors: Array<string | ValidationError> = []\n\n    if (typeof doc !== 'object' || doc === null) {\n      return {\n        valid: false,\n        errors: ['Document must be an object'],\n      }\n    }\n\n    const docObj = doc as Record<string, unknown>\n\n    // Helper function to validate nested objects\n    const validateNested = (\n      obj: Record<string, unknown>,\n      schema: Record<string, Validator>,\n      path: string = ''\n    ): void => {\n      for (const [key, validator] of Object.entries(schema)) {\n        const currentPath = path ? `${path}.${key}` : key\n        const value = obj[key]\n\n        // Check required fields\n        if (value === undefined) {\n          if (!validator.isOptional) {\n            errors.push(`Missing required field: ${currentPath}`)\n          }\n          continue\n        }\n\n        // Try to parse the value\n        try {\n          validator.parse(value)\n        } catch (e) {\n          const message = e instanceof Error ? e.message : String(e)\n          errors.push({ path: currentPath, message })\n        }\n      }\n    }\n\n    validateNested(docObj, this.document)\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    }\n  }\n\n  /**\n   * Return table definition with system fields included.\n   */\n  withSystemFields(): TableBuilder<Doc & { _id: Validator; _creationTime: Validator }> {\n    const systemFields = {\n      _id: v.string(),\n      _creationTime: v.number(),\n    }\n\n    const newDocument = {\n      ...this.document,\n      ...systemFields,\n    } as Doc & { _id: Validator; _creationTime: Validator }\n\n    const builder = new TableBuilder(newDocument)\n    Object.assign(builder.indexes, this.indexes)\n    Object.assign(builder.searchIndexes, this.searchIndexes)\n    Object.assign(builder.vectorIndexes, this.vectorIndexes)\n\n    return builder\n  }\n\n  /**\n   * Convert table definition to JSON representation.\n   */\n  toJSON(): {\n    document: Record<string, { type: string }>\n    indexes: Record<string, IndexConfig>\n    searchIndexes: Record<string, SearchIndexConfig>\n    vectorIndexes: Record<string, VectorIndexConfig>\n  } {\n    const documentJson: Record<string, { type: string }> = {}\n\n    for (const [key, validator] of Object.entries(this.document)) {\n      const desc = validator.describe().toLowerCase()\n      let type = 'unknown'\n\n      if (desc === 'string') type = 'string'\n      else if (desc === 'number') type = 'number'\n      else if (desc === 'boolean') type = 'boolean'\n      else if (desc === 'null') type = 'null'\n      else if (desc === 'int64') type = 'int64'\n      else if (desc === 'float64') type = 'float64'\n      else if (desc === 'bytes') type = 'bytes'\n      else if (desc.includes('[]')) type = 'array'\n      else if (desc.startsWith('{')) type = 'object'\n      else if (desc.startsWith('v.id')) type = 'id'\n      else type = desc\n\n      documentJson[key] = { type }\n    }\n\n    return {\n      document: documentJson,\n      indexes: { ...this.indexes },\n      searchIndexes: { ...this.searchIndexes },\n      vectorIndexes: { ...this.vectorIndexes },\n    }\n  }\n\n  /**\n   * Export schema definition compatible with Convex.\n   */\n  export(): {\n    document: Doc\n    indexes: Record<string, IndexConfig>\n    searchIndexes: Record<string, SearchIndexConfig>\n    vectorIndexes: Record<string, VectorIndexConfig>\n  } {\n    return {\n      document: this.document,\n      indexes: { ...this.indexes },\n      searchIndexes: { ...this.searchIndexes },\n      vectorIndexes: { ...this.vectorIndexes },\n    }\n  }\n\n  /**\n   * Generate code string representation.\n   */\n  toCode(): string {\n    const lines: string[] = ['defineTable({']\n\n    for (const [key, validator] of Object.entries(this.document)) {\n      const desc = validator.describe()\n      let typeStr = 'v.unknown()'\n\n      if (desc === 'string') typeStr = 'v.string()'\n      else if (desc === 'number') typeStr = 'v.number()'\n      else if (desc === 'boolean') typeStr = 'v.boolean()'\n      else if (desc === 'null') typeStr = 'v.null()'\n      else if (desc === 'int64') typeStr = 'v.int64()'\n      else if (desc === 'float64') typeStr = 'v.float64()'\n      else if (desc === 'bytes') typeStr = 'v.bytes()'\n      else if (desc.includes('[]')) {\n        const innerType = desc.replace('[]', '')\n        typeStr = `v.array(v.${innerType}())`\n      }\n      else if (desc.startsWith('v.id')) typeStr = desc\n      else typeStr = `v.${desc}()`\n\n      lines.push(`  ${key}: ${typeStr},`)\n    }\n\n    lines.push('})')\n\n    // Add indexes\n    for (const [name, config] of Object.entries(this.indexes)) {\n      const fieldsStr = JSON.stringify(config.fields)\n      lines[lines.length - 1] = lines[lines.length - 1] + `\\n  .index('${name}', ${fieldsStr})`\n    }\n\n    // Add search indexes\n    for (const [name, config] of Object.entries(this.searchIndexes)) {\n      lines[lines.length - 1] = lines[lines.length - 1] + `\\n  .searchIndex('${name}', ${JSON.stringify(config)})`\n    }\n\n    // Add vector indexes\n    for (const [name, config] of Object.entries(this.vectorIndexes)) {\n      lines[lines.length - 1] = lines[lines.length - 1] + `\\n  .vectorIndex('${name}', ${JSON.stringify(config)})`\n    }\n\n    return lines.join('\\n')\n  }\n\n  /**\n   * Clone this table definition.\n   */\n  clone(): TableBuilder<Doc> {\n    // Create a shallow copy of the document (validators are immutable)\n    const clonedDoc = { ...this.document }\n    const cloned = new TableBuilder(clonedDoc)\n\n    // Deep copy indexes\n    for (const [name, config] of Object.entries(this.indexes)) {\n      cloned.indexes[name] = { fields: [...config.fields] }\n    }\n\n    // Deep copy search indexes\n    for (const [name, config] of Object.entries(this.searchIndexes)) {\n      cloned.searchIndexes[name] = {\n        searchField: config.searchField,\n        filterFields: config.filterFields ? [...config.filterFields] : undefined,\n      }\n    }\n\n    // Deep copy vector indexes\n    for (const [name, config] of Object.entries(this.vectorIndexes)) {\n      cloned.vectorIndexes[name] = {\n        vectorField: config.vectorField,\n        dimensions: config.dimensions,\n        filterFields: config.filterFields ? [...config.filterFields] : undefined,\n      }\n    }\n\n    // Copy metadata if present\n    if (this.metadata) {\n      cloned.metadata = { ...this.metadata }\n    }\n\n    // Copy config if present\n    if (this._tableConfig) {\n      cloned.config(this._tableConfig)\n    }\n\n    return cloned\n  }\n\n  // Internal storage for metadata\n  metadata?: { description?: string }\n\n  // Internal storage for table config\n  private _tableConfig?: Record<string, unknown>\n\n  // Callable config that also acts as a property getter\n  // This is a bit of a hack to satisfy the test's expectation of both\n  // `table.config({...})` and `table.config.ttl`\n  config: ((cfg: Record<string, unknown>) => this) & Record<string, unknown>\n\n  /**\n   * Set table description.\n   */\n  description(desc: string): this {\n    this.metadata = this.metadata || {}\n    this.metadata.description = desc\n    return this\n  }\n\n  /**\n   * Initialize config on construction.\n   */\n  private initConfig(): void {\n    const self = this\n    const configFn = function (cfg: Record<string, unknown>): TableBuilder<Doc> {\n      self._tableConfig = cfg\n      // Copy config properties to the function itself\n      Object.assign(configFn, cfg)\n      return self\n    }\n    this.config = configFn as ((cfg: Record<string, unknown>) => this) & Record<string, unknown>\n  }\n}\n\n/**\n * Create a table definition.\n *\n * @example\n * ```typescript\n * const messages = defineTable({\n *   channel: v.id(\"channels\"),\n *   body: v.string(),\n *   author: v.id(\"users\"),\n * })\n *   .index(\"by_channel\", [\"channel\"])\n *   .index(\"by_author\", [\"author\"])\n * ```\n */\nexport function defineTable<Doc extends DocumentDefinition>(\n  document: Doc\n): TableBuilder<Doc> {\n  return new TableBuilder(document)\n}\n\n// ============================================================================\n// Schema Definition\n// ============================================================================\n\n/**\n * Schema definition mapping table names to table definitions.\n */\nexport type SchemaDefinition = Record<string, TableDefinition>\n\n/**\n * Schema options for defineSchema.\n */\nexport interface SchemaOptions {\n  /** Whether to enable schema validation (default: true) */\n  schemaValidation?: boolean\n  /** Whether to enforce strict table name types (default: true) */\n  strictTableNameTypes?: boolean\n  /** Legacy option for backward compatibility */\n  strict?: boolean\n}\n\n/**\n * A compiled schema.\n */\nexport interface Schema<T extends SchemaDefinition = SchemaDefinition> {\n  /** Table definitions */\n  readonly tables: T\n  /** Whether to enforce strict mode (reject unknown tables) */\n  readonly strictMode: boolean\n  /** Whether schema validation is enabled */\n  readonly schemaValidation: boolean\n  /** Whether strict table name types are enabled */\n  readonly strictTableNameTypes: boolean\n  /** Convert schema to JSON representation */\n  toJSON?(): unknown\n}\n\n/**\n * Schema builder with configuration options.\n */\nexport class SchemaBuilder<T extends SchemaDefinition> implements Schema<T> {\n  readonly tables: T\n  readonly strictMode: boolean = true\n  readonly schemaValidation: boolean = true\n  readonly strictTableNameTypes: boolean = true\n\n  constructor(tables: T, options?: SchemaOptions) {\n    // Handle options\n    if (options?.schemaValidation !== undefined) {\n      (this as { schemaValidation: boolean }).schemaValidation = options.schemaValidation\n    }\n    if (options?.strictTableNameTypes !== undefined) {\n      (this as { strictTableNameTypes: boolean }).strictTableNameTypes = options.strictTableNameTypes\n    }\n    if (options?.strict !== undefined) {\n      (this as { strictMode: boolean }).strictMode = options.strict\n    }\n\n    this.tables = tables\n  }\n\n  /**\n   * Allow documents in tables not defined in the schema.\n   * By default, strict mode is enabled and unknown tables are rejected.\n   */\n  strict(enabled: boolean): this {\n    (this as { strictMode: boolean }).strictMode = enabled\n    return this\n  }\n\n  /**\n   * Convert schema to JSON representation.\n   */\n  toJSON(): unknown {\n    return {\n      tables: this.tables,\n      schemaValidation: this.schemaValidation,\n      strictTableNameTypes: this.strictTableNameTypes,\n      strictMode: this.strictMode\n    }\n  }\n}\n\n/**\n * Valid table name pattern: starts with letter, contains only alphanumeric and underscore\n * (but not starting with underscore)\n */\nconst VALID_TABLE_NAME_PATTERN = /^[a-zA-Z][a-zA-Z0-9_]*$/\n\n/**\n * Validate table name\n */\nfunction validateTableName(name: string): void {\n  if (name === '') {\n    throw new Error('Table name cannot be empty')\n  }\n  if (name.startsWith('_')) {\n    throw new Error(`Table name \"${name}\" cannot start with underscore (reserved for system tables)`)\n  }\n  if (/^[0-9]/.test(name)) {\n    throw new Error(`Table name \"${name}\" cannot start with a number`)\n  }\n  if (!VALID_TABLE_NAME_PATTERN.test(name)) {\n    throw new Error(`Table name \"${name}\" contains invalid characters (only letters, numbers, and underscores allowed)`)\n  }\n}\n\n/**\n * Validate table definition\n */\nfunction validateTableDefinition(name: string, definition: unknown): void {\n  if (definition === null) {\n    throw new Error(`Table \"${name}\" has null definition. Use defineTable() to create a valid table definition.`)\n  }\n  if (definition === undefined) {\n    throw new Error(`Table \"${name}\" has undefined definition. Use defineTable() to create a valid table definition.`)\n  }\n  if (typeof definition === 'string') {\n    throw new Error(`Table \"${name}\" has string definition. Use defineTable() to create a valid table definition.`)\n  }\n  if (typeof definition === 'number' || typeof definition === 'boolean') {\n    throw new Error(`Table \"${name}\" has primitive definition. Use defineTable() to create a valid table definition.`)\n  }\n  if (Array.isArray(definition)) {\n    throw new Error(`Table \"${name}\" has array definition. Use defineTable() to create a valid table definition.`)\n  }\n  if (!(definition instanceof TableBuilder)) {\n    throw new Error(`Table \"${name}\" has invalid definition. Use defineTable() to create a valid table definition.`)\n  }\n}\n\n/**\n * Validate schema options\n */\nfunction validateSchemaOptions(options: SchemaOptions): void {\n  if (options.schemaValidation !== undefined && typeof options.schemaValidation !== 'boolean') {\n    throw new Error('schemaValidation option must be a boolean')\n  }\n  if (options.strictTableNameTypes !== undefined && typeof options.strictTableNameTypes !== 'boolean') {\n    throw new Error('strictTableNameTypes option must be a boolean')\n  }\n  if (options.strict !== undefined && typeof options.strict !== 'boolean') {\n    throw new Error('strict option must be a boolean')\n  }\n}\n\n/**\n * Define the database schema.\n *\n * @example\n * ```typescript\n * // convex/schema.ts\n * import { defineSchema, defineTable } from \"convex.do/server\";\n * import { v } from \"convex.do/values\";\n *\n * export default defineSchema({\n *   messages: defineTable({\n *     channel: v.id(\"channels\"),\n *     body: v.string(),\n *     author: v.id(\"users\"),\n *   })\n *     .index(\"by_channel\", [\"channel\"])\n *     .index(\"by_author\", [\"author\"]),\n *\n *   channels: defineTable({\n *     name: v.string(),\n *     description: v.optional(v.string()),\n *   }),\n *\n *   users: defineTable({\n *     name: v.string(),\n *     email: v.string(),\n *     tokenIdentifier: v.string(),\n *   })\n *     .index(\"by_token\", [\"tokenIdentifier\"]),\n * });\n * ```\n */\nexport function defineSchema<T extends SchemaDefinition>(\n  tables: T,\n  options?: SchemaOptions\n): SchemaBuilder<T> {\n  // Validate options if provided\n  if (options) {\n    validateSchemaOptions(options)\n  }\n\n  // Validate each table name and definition\n  for (const [tableName, tableDefinition] of Object.entries(tables)) {\n    validateTableName(tableName)\n    validateTableDefinition(tableName, tableDefinition)\n  }\n\n  const schema = new SchemaBuilder(tables, options)\n\n  // Freeze the tables object and schema to make them immutable\n  Object.freeze(tables)\n  for (const tableDefinition of Object.values(tables)) {\n    Object.freeze(tableDefinition)\n    if ('document' in tableDefinition) {\n      Object.freeze(tableDefinition.document)\n    }\n    if ('indexes' in tableDefinition) {\n      Object.freeze(tableDefinition.indexes)\n    }\n    if ('searchIndexes' in tableDefinition) {\n      Object.freeze(tableDefinition.searchIndexes)\n    }\n    if ('vectorIndexes' in tableDefinition) {\n      Object.freeze(tableDefinition.vectorIndexes)\n    }\n  }\n  Object.freeze(schema)\n\n  return schema\n}\n\n// ============================================================================\n// Data Model Types\n// ============================================================================\n\n/**\n * Generate the data model type from a schema.\n */\nexport type DataModel<S extends Schema> = {\n  [TableName in keyof S['tables']]: InferDocument<S['tables'][TableName]>\n}\n\n/**\n * Get the document type for a table.\n */\nexport type Doc<S extends Schema, TableName extends keyof S['tables']> =\n  InferDocument<S['tables'][TableName]> & {\n    _id: string & { __tableName: TableName }\n    _creationTime: number\n  }\n","/**\n * Query Builder for database queries (Layer 4)\n *\n * Provides a fluent API for building database queries with index support.\n */\n\nimport type { Id, PaginationOptions, PaginationResult } from '../../types'\n\n// ============================================================================\n// Index Range Types\n// ============================================================================\n\n/**\n * Builder for index range expressions.\n */\nexport interface IndexRangeBuilder<IndexFields extends string[]> {\n  /**\n   * Filter for equality on the current index field.\n   */\n  eq<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n\n  /**\n   * Filter for less than on the current index field.\n   */\n  lt<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n\n  /**\n   * Filter for less than or equal on the current index field.\n   */\n  lte<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n\n  /**\n   * Filter for greater than on the current index field.\n   */\n  gt<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n\n  /**\n   * Filter for greater than or equal on the current index field.\n   */\n  gte<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n}\n\n/**\n * Index range expression for withIndex.\n */\nexport type IndexRange<IndexFields extends string[]> =\n  | IndexRangeBuilder<IndexFields>\n  | ((q: IndexRangeBuilder<IndexFields>) => IndexRangeBuilder<IndexFields>)\n\n// ============================================================================\n// Filter Expression Types\n// ============================================================================\n\n/**\n * Filter expression builder.\n */\nexport interface FilterBuilder<Doc> {\n  /**\n   * Equality filter.\n   */\n  eq<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Not equal filter.\n   */\n  neq<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Less than filter.\n   */\n  lt<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Less than or equal filter.\n   */\n  lte<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Greater than filter.\n   */\n  gt<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Greater than or equal filter.\n   */\n  gte<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Logical AND of filters.\n   */\n  and(...filters: FilterExpression[]): FilterExpression\n\n  /**\n   * Logical OR of filters.\n   */\n  or(...filters: FilterExpression[]): FilterExpression\n\n  /**\n   * Logical NOT of a filter.\n   */\n  not(filter: FilterExpression): FilterExpression\n}\n\n/**\n * A filter expression.\n */\nexport interface FilterExpression {\n  readonly _brand: 'FilterExpression'\n}\n\n// ============================================================================\n// Query Builder\n// ============================================================================\n\n/**\n * Initial query state - can use withIndex or proceed to filtering.\n */\nexport interface QueryInitializer<TableName extends string> {\n  /**\n   * Use a specific index for the query.\n   */\n  withIndex<IndexName extends string>(\n    indexName: IndexName,\n    indexRange?: (q: IndexRangeBuilder<string[]>) => IndexRangeBuilder<string[]>\n  ): QueryBuilder<TableName>\n\n  /**\n   * Use a search index for full-text search.\n   */\n  withSearchIndex<IndexName extends string>(\n    indexName: IndexName,\n    searchFilter: (q: SearchFilterBuilder) => SearchFilterBuilder\n  ): QueryBuilder<TableName>\n\n  /**\n   * Filter the query results.\n   */\n  filter(\n    predicate: (q: FilterBuilder<Record<string, unknown>>) => FilterExpression\n  ): QueryBuilder<TableName>\n\n  /**\n   * Order results by _creationTime.\n   */\n  order(order: 'asc' | 'desc'): QueryBuilder<TableName>\n\n  /**\n   * Collect all results.\n   */\n  collect(): Promise<Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>>\n\n  /**\n   * Get the first result.\n   */\n  first(): Promise<(Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }) | null>\n\n  /**\n   * Get exactly one result (throws if not exactly one).\n   */\n  unique(): Promise<(Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }) | null>\n\n  /**\n   * Take a limited number of results.\n   */\n  take(n: number): Promise<Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>>\n\n  /**\n   * Paginate results.\n   */\n  paginate(\n    paginationOpts: PaginationOptions\n  ): Promise<PaginationResult<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>>\n}\n\n/**\n * Query builder with all operations available.\n */\nexport interface QueryBuilder<TableName extends string> extends QueryInitializer<TableName> {\n  // Inherits all methods from QueryInitializer\n}\n\n// ============================================================================\n// Search Filter Types\n// ============================================================================\n\n/**\n * Search filter builder for full-text search.\n */\nexport interface SearchFilterBuilder {\n  /**\n   * Search for text in the search field.\n   */\n  search(field: string, query: string): SearchFilterBuilder\n\n  /**\n   * Filter by equality on a filter field.\n   */\n  eq(field: string, value: unknown): SearchFilterBuilder\n}\n\n// ============================================================================\n// Implementation\n// ============================================================================\n\n/**\n * Internal implementation of the query builder.\n */\nexport class QueryBuilderImpl<TableName extends string> implements QueryBuilder<TableName> {\n  private tableName: TableName\n  private indexName?: string\n  private indexFilters: Array<{ field: string; op: string; value: unknown }> = []\n  private filterExpressions: FilterExpression[] = []\n  private orderDirection: 'asc' | 'desc' = 'asc'\n  private limitCount?: number\n\n  // Database reference for execution\n  private dbFetch: (query: QueryBuilderImpl<TableName>) => Promise<unknown[]>\n\n  constructor(\n    tableName: TableName,\n    dbFetch: (query: QueryBuilderImpl<TableName>) => Promise<unknown[]>\n  ) {\n    this.tableName = tableName\n    this.dbFetch = dbFetch\n  }\n\n  withIndex<IndexName extends string>(\n    indexName: IndexName,\n    indexRange?: (q: IndexRangeBuilder<string[]>) => IndexRangeBuilder<string[]>\n  ): QueryBuilder<TableName> {\n    this.indexName = indexName\n\n    if (indexRange) {\n      const builder = new IndexRangeBuilderImpl()\n      indexRange(builder)\n      this.indexFilters = builder.getFilters()\n    }\n\n    return this\n  }\n\n  withSearchIndex<IndexName extends string>(\n    _indexName: IndexName,\n    _searchFilter: (q: SearchFilterBuilder) => SearchFilterBuilder\n  ): QueryBuilder<TableName> {\n    // TODO: Implement search index support\n    throw new Error('Search indexes not yet implemented')\n  }\n\n  filter(\n    predicate: (q: FilterBuilder<Record<string, unknown>>) => FilterExpression\n  ): QueryBuilder<TableName> {\n    const builder = new FilterBuilderImpl()\n    const expression = predicate(builder)\n    this.filterExpressions.push(expression)\n    return this\n  }\n\n  order(order: 'asc' | 'desc'): QueryBuilder<TableName> {\n    this.orderDirection = order\n    return this\n  }\n\n  async collect(): Promise<Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>> {\n    const results = await this.dbFetch(this)\n    return results as Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>\n  }\n\n  async first(): Promise<(Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }) | null> {\n    this.limitCount = 1\n    const results = await this.collect()\n    return results[0] || null\n  }\n\n  async unique(): Promise<(Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }) | null> {\n    this.limitCount = 2\n    const results = await this.collect()\n\n    if (results.length > 1) {\n      throw new Error(`Expected at most one result, got ${results.length}`)\n    }\n\n    return results[0] || null\n  }\n\n  async take(n: number): Promise<Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>> {\n    this.limitCount = n\n    return this.collect()\n  }\n\n  async paginate(\n    paginationOpts: PaginationOptions\n  ): Promise<PaginationResult<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>> {\n    // Fetch one extra to determine if there are more pages\n    this.limitCount = paginationOpts.numItems + 1\n    const results = await this.collect()\n\n    const isDone = results.length <= paginationOpts.numItems\n    const page = results.slice(0, paginationOpts.numItems)\n    const lastItem = page[page.length - 1]\n    const continueCursor = lastItem ? btoa(JSON.stringify({ id: lastItem._id })) : ''\n\n    return {\n      page,\n      isDone,\n      continueCursor,\n    }\n  }\n\n  // Internal getters for execution\n  getTableName(): TableName {\n    return this.tableName\n  }\n\n  getIndexName(): string | undefined {\n    return this.indexName\n  }\n\n  getIndexFilters(): Array<{ field: string; op: string; value: unknown }> {\n    return this.indexFilters\n  }\n\n  getFilterExpressions(): FilterExpression[] {\n    return this.filterExpressions\n  }\n\n  getOrder(): 'asc' | 'desc' {\n    return this.orderDirection\n  }\n\n  getLimit(): number | undefined {\n    return this.limitCount\n  }\n}\n\n/**\n * Index range builder implementation.\n */\nclass IndexRangeBuilderImpl implements IndexRangeBuilder<string[]> {\n  private filters: Array<{ field: string; op: string; value: unknown }> = []\n\n  eq<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'eq', value })\n    return this\n  }\n\n  lt<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'lt', value })\n    return this\n  }\n\n  lte<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'lte', value })\n    return this\n  }\n\n  gt<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'gt', value })\n    return this\n  }\n\n  gte<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'gte', value })\n    return this\n  }\n\n  getFilters(): Array<{ field: string; op: string; value: unknown }> {\n    return this.filters\n  }\n}\n\n/**\n * Filter builder implementation.\n */\nclass FilterBuilderImpl implements FilterBuilder<Record<string, unknown>> {\n  eq<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'eq', field, value } as unknown as FilterExpression\n  }\n\n  neq<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'neq', field, value } as unknown as FilterExpression\n  }\n\n  lt<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'lt', field, value } as unknown as FilterExpression\n  }\n\n  lte<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'lte', field, value } as unknown as FilterExpression\n  }\n\n  gt<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'gt', field, value } as unknown as FilterExpression\n  }\n\n  gte<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'gte', field, value } as unknown as FilterExpression\n  }\n\n  and(...filters: FilterExpression[]): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'and', filters } as unknown as FilterExpression\n  }\n\n  or(...filters: FilterExpression[]): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'or', filters } as unknown as FilterExpression\n  }\n\n  not(filter: FilterExpression): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'not', filter } as unknown as FilterExpression\n  }\n}\n","/**\n * Query Builder for database queries\n *\n * Re-exports from database/QueryBuilder.ts for backward compatibility.\n * @deprecated Import from './database/QueryBuilder' instead\n */\n\nexport * from './database/QueryBuilder'\n\n// Legacy compatibility exports below (will be removed in future version)\n\nimport type { Id, PaginationOptions, PaginationResult } from '../types'\n\n// ============================================================================\n// Index Range Types\n// ============================================================================\n\n/**\n * Builder for index range expressions.\n */\nexport interface IndexRangeBuilder<IndexFields extends string[]> {\n  /**\n   * Filter for equality on the current index field.\n   */\n  eq<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n\n  /**\n   * Filter for less than on the current index field.\n   */\n  lt<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n\n  /**\n   * Filter for less than or equal on the current index field.\n   */\n  lte<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n\n  /**\n   * Filter for greater than on the current index field.\n   */\n  gt<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n\n  /**\n   * Filter for greater than or equal on the current index field.\n   */\n  gte<F extends IndexFields[number]>(\n    field: F,\n    value: unknown\n  ): IndexRangeBuilder<IndexFields>\n}\n\n/**\n * Index range expression for withIndex.\n */\nexport type IndexRange<IndexFields extends string[]> =\n  | IndexRangeBuilder<IndexFields>\n  | ((q: IndexRangeBuilder<IndexFields>) => IndexRangeBuilder<IndexFields>)\n\n// ============================================================================\n// Filter Expression Types\n// ============================================================================\n\n/**\n * Filter expression builder.\n */\nexport interface FilterBuilder<Doc> {\n  /**\n   * Equality filter.\n   */\n  eq<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Not equal filter.\n   */\n  neq<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Less than filter.\n   */\n  lt<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Less than or equal filter.\n   */\n  lte<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Greater than filter.\n   */\n  gt<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Greater than or equal filter.\n   */\n  gte<K extends keyof Doc>(field: K, value: Doc[K]): FilterExpression\n\n  /**\n   * Logical AND of filters.\n   */\n  and(...filters: FilterExpression[]): FilterExpression\n\n  /**\n   * Logical OR of filters.\n   */\n  or(...filters: FilterExpression[]): FilterExpression\n\n  /**\n   * Logical NOT of a filter.\n   */\n  not(filter: FilterExpression): FilterExpression\n}\n\n/**\n * A filter expression.\n */\nexport interface FilterExpression {\n  readonly _brand: 'FilterExpression'\n}\n\n// ============================================================================\n// Query Builder\n// ============================================================================\n\n/**\n * Initial query state - can use withIndex or proceed to filtering.\n */\nexport interface QueryInitializer<TableName extends string> {\n  /**\n   * Use a specific index for the query.\n   */\n  withIndex<IndexName extends string>(\n    indexName: IndexName,\n    indexRange?: (q: IndexRangeBuilder<string[]>) => IndexRangeBuilder<string[]>\n  ): QueryBuilder<TableName>\n\n  /**\n   * Use a search index for full-text search.\n   */\n  withSearchIndex<IndexName extends string>(\n    indexName: IndexName,\n    searchFilter: (q: SearchFilterBuilder) => SearchFilterBuilder\n  ): QueryBuilder<TableName>\n\n  /**\n   * Filter the query results.\n   */\n  filter(\n    predicate: (q: FilterBuilder<Record<string, unknown>>) => FilterExpression\n  ): QueryBuilder<TableName>\n\n  /**\n   * Order results by _creationTime.\n   */\n  order(order: 'asc' | 'desc'): QueryBuilder<TableName>\n\n  /**\n   * Collect all results.\n   */\n  collect(): Promise<Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>>\n\n  /**\n   * Get the first result.\n   */\n  first(): Promise<(Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }) | null>\n\n  /**\n   * Get exactly one result (throws if not exactly one).\n   */\n  unique(): Promise<(Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }) | null>\n\n  /**\n   * Take a limited number of results.\n   */\n  take(n: number): Promise<Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>>\n\n  /**\n   * Paginate results.\n   */\n  paginate(\n    paginationOpts: PaginationOptions\n  ): Promise<PaginationResult<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>>\n}\n\n/**\n * Query builder with all operations available.\n */\nexport interface QueryBuilder<TableName extends string> extends QueryInitializer<TableName> {\n  // Inherits all methods from QueryInitializer\n}\n\n// ============================================================================\n// Search Filter Types\n// ============================================================================\n\n/**\n * Search filter builder for full-text search.\n */\nexport interface SearchFilterBuilder {\n  /**\n   * Search for text in the search field.\n   */\n  search(field: string, query: string): SearchFilterBuilder\n\n  /**\n   * Filter by equality on a filter field.\n   */\n  eq(field: string, value: unknown): SearchFilterBuilder\n}\n\n// ============================================================================\n// Implementation\n// ============================================================================\n\n/**\n * Internal implementation of the query builder.\n */\nexport class QueryBuilderImpl<TableName extends string> implements QueryBuilder<TableName> {\n  private tableName: TableName\n  private indexName?: string\n  private indexFilters: Array<{ field: string; op: string; value: unknown }> = []\n  private filterExpressions: FilterExpression[] = []\n  private orderDirection: 'asc' | 'desc' = 'asc'\n  private limitCount?: number\n\n  // Database reference for execution\n  private dbFetch: (query: QueryBuilderImpl<TableName>) => Promise<unknown[]>\n\n  constructor(\n    tableName: TableName,\n    dbFetch: (query: QueryBuilderImpl<TableName>) => Promise<unknown[]>\n  ) {\n    this.tableName = tableName\n    this.dbFetch = dbFetch\n  }\n\n  withIndex<IndexName extends string>(\n    indexName: IndexName,\n    indexRange?: (q: IndexRangeBuilder<string[]>) => IndexRangeBuilder<string[]>\n  ): QueryBuilder<TableName> {\n    this.indexName = indexName\n\n    if (indexRange) {\n      const builder = new IndexRangeBuilderImpl()\n      indexRange(builder)\n      this.indexFilters = builder.getFilters()\n    }\n\n    return this\n  }\n\n  withSearchIndex<IndexName extends string>(\n    _indexName: IndexName,\n    _searchFilter: (q: SearchFilterBuilder) => SearchFilterBuilder\n  ): QueryBuilder<TableName> {\n    // TODO: Implement search index support\n    throw new Error('Search indexes not yet implemented')\n  }\n\n  filter(\n    predicate: (q: FilterBuilder<Record<string, unknown>>) => FilterExpression\n  ): QueryBuilder<TableName> {\n    const builder = new FilterBuilderImpl()\n    const expression = predicate(builder)\n    this.filterExpressions.push(expression)\n    return this\n  }\n\n  order(order: 'asc' | 'desc'): QueryBuilder<TableName> {\n    this.orderDirection = order\n    return this\n  }\n\n  async collect(): Promise<Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>> {\n    const results = await this.dbFetch(this)\n    return results as Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>\n  }\n\n  async first(): Promise<(Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }) | null> {\n    this.limitCount = 1\n    const results = await this.collect()\n    return results[0] || null\n  }\n\n  async unique(): Promise<(Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }) | null> {\n    this.limitCount = 2\n    const results = await this.collect()\n\n    if (results.length > 1) {\n      throw new Error(`Expected at most one result, got ${results.length}`)\n    }\n\n    return results[0] || null\n  }\n\n  async take(n: number): Promise<Array<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>> {\n    this.limitCount = n\n    return this.collect()\n  }\n\n  async paginate(\n    paginationOpts: PaginationOptions\n  ): Promise<PaginationResult<Record<string, unknown> & { _id: Id<TableName>; _creationTime: number }>> {\n    // Fetch one extra to determine if there are more pages\n    this.limitCount = paginationOpts.numItems + 1\n    const results = await this.collect()\n\n    const isDone = results.length <= paginationOpts.numItems\n    const page = results.slice(0, paginationOpts.numItems)\n    const lastItem = page[page.length - 1]\n    const continueCursor = lastItem ? btoa(JSON.stringify({ id: lastItem._id })) : ''\n\n    return {\n      page,\n      isDone,\n      continueCursor,\n    }\n  }\n\n  // Internal getters for execution\n  getTableName(): TableName {\n    return this.tableName\n  }\n\n  getIndexName(): string | undefined {\n    return this.indexName\n  }\n\n  getIndexFilters(): Array<{ field: string; op: string; value: unknown }> {\n    return this.indexFilters\n  }\n\n  getOrder(): 'asc' | 'desc' {\n    return this.orderDirection\n  }\n\n  getLimit(): number | undefined {\n    return this.limitCount\n  }\n\n  getFilterExpressions(): FilterExpression[] {\n    return this.filterExpressions\n  }\n}\n\n/**\n * Index range builder implementation.\n */\nclass IndexRangeBuilderImpl implements IndexRangeBuilder<string[]> {\n  private filters: Array<{ field: string; op: string; value: unknown }> = []\n\n  eq<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'eq', value })\n    return this\n  }\n\n  lt<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'lt', value })\n    return this\n  }\n\n  lte<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'lte', value })\n    return this\n  }\n\n  gt<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'gt', value })\n    return this\n  }\n\n  gte<F extends string>(field: F, value: unknown): IndexRangeBuilder<string[]> {\n    this.filters.push({ field, op: 'gte', value })\n    return this\n  }\n\n  getFilters(): Array<{ field: string; op: string; value: unknown }> {\n    return this.filters\n  }\n}\n\n/**\n * Filter builder implementation.\n */\nclass FilterBuilderImpl implements FilterBuilder<Record<string, unknown>> {\n  eq<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'eq', field, value } as unknown as FilterExpression\n  }\n\n  neq<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'neq', field, value } as unknown as FilterExpression\n  }\n\n  lt<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'lt', field, value } as unknown as FilterExpression\n  }\n\n  lte<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'lte', field, value } as unknown as FilterExpression\n  }\n\n  gt<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'gt', field, value } as unknown as FilterExpression\n  }\n\n  gte<K extends string>(field: K, value: unknown): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'gte', field, value } as unknown as FilterExpression\n  }\n\n  and(...filters: FilterExpression[]): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'and', filters } as unknown as FilterExpression\n  }\n\n  or(...filters: FilterExpression[]): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'or', filters } as unknown as FilterExpression\n  }\n\n  not(filter: FilterExpression): FilterExpression {\n    return { _brand: 'FilterExpression', type: 'not', filter } as unknown as FilterExpression\n  }\n}\n","/**\n * DatabaseReader Implementation - Layer 4\n *\n * Provides read-only database access for Convex queries.\n * Implements the DatabaseReader interface defined in context.ts\n *\n * Features:\n * - get(id): Get a document by ID\n * - query(table): Start a query builder for a table\n * - normalizeId(table, id): Normalize an ID to canonical form\n */\n\nimport type { Id } from '../../types'\nimport { QueryBuilderImpl, type QueryBuilder } from '../queryBuilder'\nimport type { FilterExpression } from '../queryBuilder'\n\n// ============================================================================\n// Storage Interface\n// ============================================================================\n\n/**\n * Storage backend interface for DatabaseReader\n * This abstracts the actual storage implementation (could be Durable Object, etc.)\n */\nexport interface StorageBackend {\n  /**\n   * Get a single document by ID\n   */\n  getDocument(id: string): Promise<Record<string, unknown> | null>\n\n  /**\n   * Query documents from a table with optional filters\n   */\n  queryDocuments(\n    tableName: string,\n    options?: QueryOptions\n  ): Promise<Array<Record<string, unknown> & { _id: string; _creationTime: number }>>\n}\n\n/**\n * Query options for storage backend\n */\nexport interface QueryOptions {\n  indexName?: string\n  indexFilters?: Array<{ field: string; op: string; value: unknown }>\n  filters?: FilterExpression[]\n  order?: 'asc' | 'desc'\n  limit?: number\n}\n\n// ============================================================================\n// DatabaseReader Implementation\n// ============================================================================\n\n/**\n * DatabaseReader provides read-only access to the database\n */\nexport class DatabaseReader {\n  private storage: StorageBackend\n\n  constructor(storage: StorageBackend) {\n    this.storage = storage\n  }\n\n  /**\n   * Get a document by ID\n   */\n  async get<TableName extends string>(\n    id: Id<TableName>\n  ): Promise<Record<string, unknown> | null> {\n    return this.storage.getDocument(id as string)\n  }\n\n  /**\n   * Start building a query for a table\n   */\n  query<TableName extends string>(tableName: TableName): QueryBuilder<TableName> {\n    // Create a query builder with a fetch function that uses our storage\n    const dbFetch = async (query: QueryBuilderImpl<TableName>) => {\n      const options: QueryOptions = {\n        indexName: query.getIndexName(),\n        indexFilters: query.getIndexFilters(),\n        filters: query.getFilterExpressions(),\n        order: query.getOrder(),\n        limit: query.getLimit(),\n      }\n\n      return this.storage.queryDocuments(tableName, options)\n    }\n\n    return new QueryBuilderImpl(tableName, dbFetch)\n  }\n\n  /**\n   * Normalize a string to a valid ID for a table\n   * Returns null if the string is not a valid ID format\n   */\n  normalizeId<TableName extends string>(\n    tableName: TableName,\n    id: string\n  ): Id<TableName> | null {\n    // Validate input type\n    if (typeof id !== 'string') {\n      return null\n    }\n\n    // Empty string is not valid\n    if (id === '' || id.trim() === '') {\n      return null\n    }\n\n    // Check for valid characters (base64-url safe: alphanumeric, underscore, hyphen)\n    const VALID_ID_PATTERN = /^[a-zA-Z0-9_-]+$/\n    if (!VALID_ID_PATTERN.test(id)) {\n      return null\n    }\n\n    // Check for maximum length (128 characters is reasonable for Convex IDs)\n    const MAX_ID_LENGTH = 128\n    if (id.length > MAX_ID_LENGTH) {\n      return null\n    }\n\n    // Return as typed ID\n    return id as Id<TableName>\n  }\n}\n\n// ============================================================================\n// In-Memory Storage Backend (for testing)\n// ============================================================================\n\n/**\n * In-memory storage backend for testing and development\n */\nexport class InMemoryStorage implements StorageBackend {\n  private documents = new Map<string, Record<string, unknown> & { _id: string; _creationTime: number }>()\n\n  async getDocument(id: string): Promise<Record<string, unknown> | null> {\n    return this.documents.get(id) || null\n  }\n\n  async queryDocuments(\n    tableName: string,\n    options?: QueryOptions\n  ): Promise<Array<Record<string, unknown> & { _id: string; _creationTime: number }>> {\n    // Get all documents for this table\n    let results: Array<Record<string, unknown> & { _id: string; _creationTime: number }> = []\n\n    for (const [id, doc] of this.documents) {\n      if (id.startsWith(`${tableName}_`)) {\n        results.push(doc)\n      }\n    }\n\n    // Apply index filters\n    if (options?.indexFilters && options.indexFilters.length > 0) {\n      results = results.filter((doc) => {\n        return options.indexFilters!.every((filter) => {\n          const value = doc[filter.field]\n          return this.evaluateFilter(value, filter.op, filter.value)\n        })\n      })\n    }\n\n    // Apply filters (from .filter() calls)\n    if (options?.filters && options.filters.length > 0) {\n      for (const filter of options.filters) {\n        results = results.filter((doc) => this.evaluateFilterExpression(doc, filter))\n      }\n    }\n\n    // Apply ordering\n    const order = options?.order || 'asc'\n    results.sort((a, b) => {\n      if (order === 'asc') {\n        return a._creationTime - b._creationTime\n      } else {\n        return b._creationTime - a._creationTime\n      }\n    })\n\n    // Apply limit\n    if (options?.limit !== undefined) {\n      results = results.slice(0, options.limit)\n    }\n\n    return results\n  }\n\n  /**\n   * Evaluate a filter operation\n   */\n  private evaluateFilter(value: unknown, op: string, target: unknown): boolean {\n    switch (op) {\n      case 'eq':\n        return value === target\n      case 'neq':\n        return value !== target\n      case 'lt':\n        return (value as number) < (target as number)\n      case 'lte':\n        return (value as number) <= (target as number)\n      case 'gt':\n        return (value as number) > (target as number)\n      case 'gte':\n        return (value as number) >= (target as number)\n      default:\n        return false\n    }\n  }\n\n  /**\n   * Evaluate a filter expression\n   */\n  private evaluateFilterExpression(doc: Record<string, unknown>, filter: FilterExpression): boolean {\n    const filterObj = filter as unknown as {\n      type: string\n      field?: string\n      value?: unknown\n      filters?: FilterExpression[]\n      filter?: FilterExpression\n    }\n\n    switch (filterObj.type) {\n      case 'eq':\n        return doc[filterObj.field!] === filterObj.value\n      case 'neq':\n        return doc[filterObj.field!] !== filterObj.value\n      case 'lt':\n        return (doc[filterObj.field!] as number) < (filterObj.value as number)\n      case 'lte':\n        return (doc[filterObj.field!] as number) <= (filterObj.value as number)\n      case 'gt':\n        return (doc[filterObj.field!] as number) > (filterObj.value as number)\n      case 'gte':\n        return (doc[filterObj.field!] as number) >= (filterObj.value as number)\n      case 'and':\n        return filterObj.filters!.every((f) => this.evaluateFilterExpression(doc, f))\n      case 'or':\n        return filterObj.filters!.some((f) => this.evaluateFilterExpression(doc, f))\n      case 'not':\n        return !this.evaluateFilterExpression(doc, filterObj.filter!)\n      default:\n        return true\n    }\n  }\n\n  /**\n   * Add a document to storage (for testing)\n   */\n  addDocument(id: string, doc: Record<string, unknown> & { _id: string; _creationTime: number }) {\n    this.documents.set(id, doc)\n  }\n\n  /**\n   * Clear all documents (for testing)\n   */\n  clear() {\n    this.documents.clear()\n  }\n}\n","/**\n * DatabaseWriter implementation for Layer 4\n *\n * Extends DatabaseReader and provides write operations:\n * - insert(): Insert a new document\n * - patch(): Partially update a document\n * - replace(): Replace a document entirely\n * - delete(): Delete a document\n *\n * All operations validate input and protect system fields (_id, _creationTime)\n */\n\nimport type { Id } from '../../types'\nimport { DatabaseReader, type Storage as BaseStorage } from './DatabaseReader'\n\n/**\n * Extended storage interface with write operations\n */\nexport interface Storage extends BaseStorage {\n  saveDocument(table: string, id: string, doc: Record<string, unknown>): void\n  deleteDocument(table: string, id: string): void\n}\n\n/**\n * System field names that cannot be modified by users\n */\nconst SYSTEM_FIELDS = ['_id', '_creationTime'] as const\n\n/**\n * DatabaseWriter extends DatabaseReader with write operations\n */\nexport class DatabaseWriter extends DatabaseReader {\n  protected storage: Storage\n\n  constructor(storage: Storage) {\n    super(storage)\n    this.storage = storage\n  }\n\n  /**\n   * Override get() to work with our storage implementation\n   */\n  async get<TableName extends string>(\n    id: Id<TableName>\n  ): Promise<Record<string, unknown> | null> {\n    // Extract table name from ID (format: tableName_randomPart)\n    const tableName = this.extractTableFromId(id)\n    const doc = this.storage.getDocument(tableName, id)\n    return doc\n  }\n\n  /**\n   * Insert a new document into a table.\n   * Returns the generated document ID.\n   *\n   * @throws {Error} If document contains system fields or invalid values\n   */\n  async insert<TableName extends string>(\n    tableName: TableName,\n    document: Record<string, unknown>\n  ): Promise<Id<TableName>> {\n    // Validate that no system fields are provided\n    this.validateNoSystemFields(document, 'insert')\n\n    // Validate document values\n    this.validateDocumentValues(document)\n\n    // Generate a unique ID\n    const id = this.generateId(tableName)\n\n    // Add system fields\n    const fullDocument = {\n      ...document,\n      _id: id,\n      _creationTime: Date.now(),\n    }\n\n    // Save to storage\n    this.storage.saveDocument(tableName, id, fullDocument)\n\n    return id\n  }\n\n  /**\n   * Update specific fields of a document.\n   * Merges the provided fields with the existing document.\n   *\n   * @throws {Error} If document not found, no fields provided, or attempting to modify system fields\n   */\n  async patch<TableName extends string>(\n    id: Id<TableName>,\n    fields: Partial<Record<string, unknown>>\n  ): Promise<void> {\n    // Validate at least one field is provided\n    if (Object.keys(fields).length === 0) {\n      throw new Error('patch() requires at least one field to update')\n    }\n\n    // Validate that no system fields are being modified\n    this.validateNoSystemFields(fields, 'patch')\n\n    // Validate field values\n    this.validateDocumentValues(fields)\n\n    // Get existing document\n    const tableName = this.extractTableFromId(id)\n    const existingDoc = this.storage.getDocument(tableName, id)\n\n    if (!existingDoc) {\n      throw new Error(`Document with ID ${id} not found`)\n    }\n\n    // Merge fields\n    const updatedDoc = {\n      ...existingDoc,\n      ...fields,\n    }\n\n    // Save updated document\n    this.storage.saveDocument(tableName, id, updatedDoc)\n  }\n\n  /**\n   * Replace a document entirely.\n   * All old fields except system fields are removed.\n   *\n   * @throws {Error} If document not found or attempting to modify system fields\n   */\n  async replace<TableName extends string>(\n    id: Id<TableName>,\n    document: Record<string, unknown>\n  ): Promise<void> {\n    // Validate that no system fields are being replaced\n    this.validateNoSystemFields(document, 'replace')\n\n    // Validate document values\n    this.validateDocumentValues(document)\n\n    // Get existing document to preserve system fields\n    const tableName = this.extractTableFromId(id)\n    const existingDoc = this.storage.getDocument(tableName, id)\n\n    if (!existingDoc) {\n      throw new Error(`Document with ID ${id} not found`)\n    }\n\n    // Create new document with preserved system fields\n    const newDoc = {\n      ...document,\n      _id: existingDoc._id,\n      _creationTime: existingDoc._creationTime,\n    }\n\n    // Save replaced document\n    this.storage.saveDocument(tableName, id, newDoc)\n  }\n\n  /**\n   * Delete a document.\n   * This operation is idempotent - deleting a non-existent document does not throw.\n   */\n  async delete(id: Id<string>): Promise<void> {\n    const tableName = this.extractTableFromId(id)\n    this.storage.deleteDocument(tableName, id)\n  }\n\n  /**\n   * Validate that document doesn't contain system fields\n   */\n  private validateNoSystemFields(\n    document: Record<string, unknown>,\n    operation: string\n  ): void {\n    for (const field of SYSTEM_FIELDS) {\n      if (field in document) {\n        throw new Error(\n          `System field '${field}' cannot be modified. System fields are auto-generated and read-only.`\n        )\n      }\n    }\n  }\n\n  /**\n   * Validate document values according to Convex value system\n   */\n  private validateDocumentValues(document: Record<string, unknown>): void {\n    for (const [key, value] of Object.entries(document)) {\n      this.validateValue(value, key)\n    }\n  }\n\n  /**\n   * Recursively validate a value\n   */\n  private validateValue(value: unknown, path: string): void {\n    // Check for undefined\n    if (value === undefined) {\n      throw new Error(\n        `Invalid value at '${path}': undefined is not allowed. Use null for optional fields.`\n      )\n    }\n\n    // Check for NaN\n    if (typeof value === 'number' && isNaN(value)) {\n      throw new Error(\n        `Invalid value at '${path}': NaN is not allowed.`\n      )\n    }\n\n    // Check for Infinity\n    if (value === Infinity || value === -Infinity) {\n      throw new Error(\n        `Invalid value at '${path}': Infinity is not allowed.`\n      )\n    }\n\n    // Check for functions\n    if (typeof value === 'function') {\n      throw new Error(\n        `Invalid value at '${path}': function is not allowed.`\n      )\n    }\n\n    // Check for symbols\n    if (typeof value === 'symbol') {\n      throw new Error(\n        `Invalid value at '${path}': symbol is not allowed.`\n      )\n    }\n\n    // Recursively validate arrays\n    if (Array.isArray(value)) {\n      value.forEach((item, index) => {\n        this.validateValue(item, `${path}[${index}]`)\n      })\n    }\n\n    // Recursively validate objects (but not null, Date, etc.)\n    if (value !== null && typeof value === 'object' && value.constructor === Object) {\n      for (const [key, val] of Object.entries(value)) {\n        this.validateValue(val, `${path}.${key}`)\n      }\n    }\n  }\n\n  /**\n   * Generate a unique ID for a document\n   */\n  private generateId<TableName extends string>(tableName: TableName): Id<TableName> {\n    // Generate a unique ID using crypto random and base64url encoding\n    const randomBytes = new Uint8Array(16)\n    crypto.getRandomValues(randomBytes)\n\n    // Convert to base64url (URL-safe base64)\n    const base64 = this.arrayBufferToBase64Url(randomBytes.buffer)\n\n    // Include table name in ID for easy extraction\n    const id = `${tableName}_${base64}`\n\n    return id as Id<TableName>\n  }\n\n  /**\n   * Convert ArrayBuffer to base64url string\n   */\n  private arrayBufferToBase64Url(buffer: ArrayBuffer): string {\n    const bytes = new Uint8Array(buffer)\n    let binary = ''\n    for (let i = 0; i < bytes.length; i++) {\n      binary += String.fromCharCode(bytes[i])\n    }\n    // Convert to base64 and make URL-safe\n    return btoa(binary)\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=/g, '')\n  }\n\n  /**\n   * Extract table name from document ID\n   */\n  private extractTableFromId(id: string): string {\n    const parts = id.split('_')\n    if (parts.length < 2) {\n      throw new Error(`Invalid document ID format: ${id}`)\n    }\n    return parts[0]\n  }\n}\n","/**\n * QueryCtx Implementation\n *\n * Provides the context object for Convex query functions with read-only access\n * to database, authentication, and storage.\n *\n * Layer 4: Server Context Objects\n */\n\nimport type { QueryCtx, DatabaseReader, Auth, StorageReader } from '../context'\nimport type { Id, UserIdentity, StorageId, ScheduledFunctionId } from '../../types'\nimport { QueryBuilderImpl, type QueryBuilder } from '../queryBuilder'\n\n// ============================================================================\n// DatabaseReader Implementation\n// ============================================================================\n\n/**\n * Implementation of read-only database operations.\n */\nexport class DatabaseReaderImpl implements DatabaseReader {\n  /**\n   * Get a document by ID.\n   */\n  async get<TableName extends string>(\n    id: Id<TableName>\n  ): Promise<Record<string, unknown> | null> {\n    // In a real implementation, this would fetch from the database\n    // For now, this is a placeholder that should be overridden\n    throw new Error('DatabaseReader.get() must be implemented by runtime')\n  }\n\n  /**\n   * Start building a query for a table.\n   */\n  query<TableName extends string>(\n    tableName: TableName\n  ): QueryBuilder<TableName> {\n    // Create a query builder with a fetch function\n    // In a real implementation, the fetch function would be provided by the runtime\n    return new QueryBuilderImpl(tableName, async (query) => {\n      throw new Error('Query execution must be implemented by runtime')\n    })\n  }\n\n  /**\n   * Normalize a string to a valid ID for a table.\n   * Returns null if the string is not a valid ID.\n   */\n  normalizeId<TableName extends string>(\n    tableName: TableName,\n    id: string\n  ): Id<TableName> | null {\n    // In a real implementation, this would validate and normalize the ID\n    // For now, this is a placeholder\n    throw new Error('DatabaseReader.normalizeId() must be implemented by runtime')\n  }\n\n  /**\n   * System table access for scheduled functions.\n   */\n  system = {\n    get: async (id: ScheduledFunctionId): Promise<{\n      _id: ScheduledFunctionId\n      _creationTime: number\n      name: string\n      args: unknown[]\n      scheduledTime: number\n      state: { kind: 'pending' } | { kind: 'inProgress' } | { kind: 'success' } | { kind: 'failed'; error: string } | { kind: 'canceled' }\n    } | null> => {\n      throw new Error('DatabaseReader.system.get() must be implemented by runtime')\n    },\n    query: (tableName: '_scheduled_functions'): QueryBuilder<'_scheduled_functions'> => {\n      return new QueryBuilderImpl(tableName, async (query) => {\n        throw new Error('Query execution must be implemented by runtime')\n      })\n    },\n  }\n}\n\n// ============================================================================\n// Auth Implementation\n// ============================================================================\n\n/**\n * Implementation of authentication context.\n */\nexport class AuthImpl implements Auth {\n  /**\n   * Get the identity of the authenticated user.\n   * Returns null if not authenticated.\n   */\n  async getUserIdentity(): Promise<UserIdentity | null> {\n    // In a real implementation, this would fetch from the auth provider\n    // For now, this is a placeholder that should be overridden\n    throw new Error('Auth.getUserIdentity() must be implemented by runtime')\n  }\n}\n\n// ============================================================================\n// StorageReader Implementation\n// ============================================================================\n\n/**\n * Implementation of read-only storage operations.\n */\nexport class StorageReaderImpl implements StorageReader {\n  /**\n   * Get a URL for downloading a file.\n   */\n  async getUrl(storageId: StorageId): Promise<string | null> {\n    // In a real implementation, this would generate a signed URL\n    // For now, this is a placeholder that should be overridden\n    throw new Error('StorageReader.getUrl() must be implemented by runtime')\n  }\n\n  /**\n   * Get metadata for a stored file.\n   */\n  async getMetadata(storageId: StorageId): Promise<{\n    storageId: StorageId\n    sha256: string\n    size: number\n    contentType?: string\n  } | null> {\n    // In a real implementation, this would fetch metadata from storage\n    // For now, this is a placeholder that should be overridden\n    throw new Error('StorageReader.getMetadata() must be implemented by runtime')\n  }\n}\n\n// ============================================================================\n// QueryCtx Implementation\n// ============================================================================\n\n/**\n * Implementation of the QueryCtx context object.\n */\nexport class QueryCtxImpl implements QueryCtx {\n  /** Read-only database access */\n  db: DatabaseReader\n\n  /** Authentication context */\n  auth: Auth\n\n  /** Read-only storage access */\n  storage: StorageReader\n\n  constructor(\n    db?: DatabaseReader,\n    auth?: Auth,\n    storage?: StorageReader\n  ) {\n    this.db = db || new DatabaseReaderImpl()\n    this.auth = auth || new AuthImpl()\n    this.storage = storage || new StorageReaderImpl()\n  }\n}\n\n// ============================================================================\n// Factory Functions\n// ============================================================================\n\n/**\n * Create a new QueryCtx with the provided implementations.\n * This is typically called by the Convex runtime.\n */\nexport function createQueryCtx(\n  db: DatabaseReader,\n  auth: Auth,\n  storage: StorageReader\n): QueryCtx {\n  return new QueryCtxImpl(db, auth, storage)\n}\n\n/**\n * Create a default QueryCtx (for testing or development).\n * The runtime should override the methods before use.\n */\nexport function createDefaultQueryCtx(): QueryCtx {\n  return new QueryCtxImpl()\n}\n","/**\n * MutationCtx Implementation\n *\n * Concrete implementation of the MutationCtx context object.\n * This provides the context passed to mutation function handlers.\n *\n * MutationCtx provides:\n * - db: DatabaseWriter (extends DatabaseReader with write operations)\n * - auth: Auth for checking authentication\n * - storage: StorageWriter for file access\n * - scheduler: Scheduler for scheduling functions\n */\n\nimport type {\n  MutationCtx,\n  DatabaseWriter,\n  Auth,\n  StorageWriter,\n  Scheduler,\n} from '../context'\n\n// ============================================================================\n// Factory Function\n// ============================================================================\n\n/**\n * Create a MutationCtx instance.\n *\n * This factory function creates a context object with all the required\n * properties for mutation functions.\n *\n * @param db - DatabaseWriter instance for database operations\n * @param auth - Auth instance for authentication\n * @param storage - StorageWriter instance for file storage\n * @param scheduler - Scheduler instance for delayed execution\n * @returns MutationCtx instance\n *\n * @example\n * ```typescript\n * const ctx = createMutationCtx(db, auth, storage, scheduler);\n * // Use in mutation handler\n * const result = await mutationHandler(ctx, args);\n * ```\n */\nexport function createMutationCtx(\n  db: DatabaseWriter,\n  auth: Auth,\n  storage: StorageWriter,\n  scheduler: Scheduler\n): MutationCtx {\n  return {\n    db,\n    auth,\n    storage,\n    scheduler,\n  }\n}\n\n// ============================================================================\n// Validation Utilities\n// ============================================================================\n\n/**\n * Validate that a context object implements the MutationCtx interface.\n *\n * @param ctx - The context object to validate\n * @returns True if valid, throws error otherwise\n */\nexport function validateMutationCtx(ctx: unknown): ctx is MutationCtx {\n  if (!ctx || typeof ctx !== 'object') {\n    throw new Error('MutationCtx must be an object')\n  }\n\n  const mutationCtx = ctx as Record<string, unknown>\n\n  if (!mutationCtx.db || typeof mutationCtx.db !== 'object') {\n    throw new Error('MutationCtx.db is required and must be a DatabaseWriter')\n  }\n\n  if (!mutationCtx.auth || typeof mutationCtx.auth !== 'object') {\n    throw new Error('MutationCtx.auth is required and must be an Auth instance')\n  }\n\n  if (!mutationCtx.storage || typeof mutationCtx.storage !== 'object') {\n    throw new Error('MutationCtx.storage is required and must be a StorageWriter')\n  }\n\n  if (!mutationCtx.scheduler || typeof mutationCtx.scheduler !== 'object') {\n    throw new Error('MutationCtx.scheduler is required and must be a Scheduler')\n  }\n\n  return true\n}\n\n/**\n * Ensure all required methods are present on DatabaseWriter.\n *\n * @param db - The database object to validate\n */\nexport function validateDatabaseWriter(db: unknown): db is DatabaseWriter {\n  if (!db || typeof db !== 'object') {\n    throw new Error('DatabaseWriter must be an object')\n  }\n\n  const dbWriter = db as Record<string, unknown>\n\n  // Check read methods (from DatabaseReader)\n  if (typeof dbWriter.get !== 'function') {\n    throw new Error('DatabaseWriter.get must be a function')\n  }\n\n  if (typeof dbWriter.query !== 'function') {\n    throw new Error('DatabaseWriter.query must be a function')\n  }\n\n  if (typeof dbWriter.normalizeId !== 'function') {\n    throw new Error('DatabaseWriter.normalizeId must be a function')\n  }\n\n  // Check write methods\n  if (typeof dbWriter.insert !== 'function') {\n    throw new Error('DatabaseWriter.insert must be a function')\n  }\n\n  if (typeof dbWriter.patch !== 'function') {\n    throw new Error('DatabaseWriter.patch must be a function')\n  }\n\n  if (typeof dbWriter.replace !== 'function') {\n    throw new Error('DatabaseWriter.replace must be a function')\n  }\n\n  if (typeof dbWriter.delete !== 'function') {\n    throw new Error('DatabaseWriter.delete must be a function')\n  }\n\n  return true\n}\n\n/**\n * Ensure all required methods are present on StorageWriter.\n *\n * @param storage - The storage object to validate\n */\nexport function validateStorageWriter(storage: unknown): storage is StorageWriter {\n  if (!storage || typeof storage !== 'object') {\n    throw new Error('StorageWriter must be an object')\n  }\n\n  const storageWriter = storage as Record<string, unknown>\n\n  // Check read methods (from StorageReader)\n  if (typeof storageWriter.getUrl !== 'function') {\n    throw new Error('StorageWriter.getUrl must be a function')\n  }\n\n  if (typeof storageWriter.getMetadata !== 'function') {\n    throw new Error('StorageWriter.getMetadata must be a function')\n  }\n\n  // Check write methods\n  if (typeof storageWriter.generateUploadUrl !== 'function') {\n    throw new Error('StorageWriter.generateUploadUrl must be a function')\n  }\n\n  if (typeof storageWriter.store !== 'function') {\n    throw new Error('StorageWriter.store must be a function')\n  }\n\n  if (typeof storageWriter.delete !== 'function') {\n    throw new Error('StorageWriter.delete must be a function')\n  }\n\n  return true\n}\n\n/**\n * Ensure all required methods are present on Scheduler.\n *\n * @param scheduler - The scheduler object to validate\n */\nexport function validateScheduler(scheduler: unknown): scheduler is Scheduler {\n  if (!scheduler || typeof scheduler !== 'object') {\n    throw new Error('Scheduler must be an object')\n  }\n\n  const schedulerObj = scheduler as Record<string, unknown>\n\n  if (typeof schedulerObj.runAfter !== 'function') {\n    throw new Error('Scheduler.runAfter must be a function')\n  }\n\n  if (typeof schedulerObj.runAt !== 'function') {\n    throw new Error('Scheduler.runAt must be a function')\n  }\n\n  if (typeof schedulerObj.cancel !== 'function') {\n    throw new Error('Scheduler.cancel must be a function')\n  }\n\n  return true\n}\n\n/**\n * Ensure all required methods are present on Auth.\n *\n * @param auth - The auth object to validate\n */\nexport function validateAuth(auth: unknown): auth is Auth {\n  if (!auth || typeof auth !== 'object') {\n    throw new Error('Auth must be an object')\n  }\n\n  const authObj = auth as Record<string, unknown>\n\n  if (typeof authObj.getUserIdentity !== 'function') {\n    throw new Error('Auth.getUserIdentity must be a function')\n  }\n\n  return true\n}\n\n/**\n * Create a validated MutationCtx instance.\n *\n * This function creates a MutationCtx and validates all components\n * to ensure they implement the required interfaces.\n *\n * @param db - DatabaseWriter instance\n * @param auth - Auth instance\n * @param storage - StorageWriter instance\n * @param scheduler - Scheduler instance\n * @returns Validated MutationCtx instance\n * @throws Error if any component is invalid\n */\nexport function createValidatedMutationCtx(\n  db: DatabaseWriter,\n  auth: Auth,\n  storage: StorageWriter,\n  scheduler: Scheduler\n): MutationCtx {\n  // Validate all components\n  validateDatabaseWriter(db)\n  validateAuth(auth)\n  validateStorageWriter(storage)\n  validateScheduler(scheduler)\n\n  // Create and return the context\n  return createMutationCtx(db, auth, storage, scheduler)\n}\n","/**\n * ActionCtx Implementation for Layer 4\n *\n * Provides the context object for action functions in Convex.\n * Actions can perform arbitrary operations including external API calls.\n *\n * ActionCtx provides:\n * - auth: Auth for checking authentication\n * - storage: StorageReader for file access\n * - scheduler: Scheduler for scheduling functions\n * - runQuery: Execute query functions\n * - runMutation: Execute mutation functions\n * - runAction: Execute other actions\n * - vectorSearch: Perform vector similarity search\n */\n\nimport type {\n  ActionCtx,\n  Auth,\n  StorageReader,\n  Scheduler,\n} from '../context'\nimport type {\n  FunctionReference,\n  Id,\n} from '../../types'\n\n// ============================================================================\n// Factory Function\n// ============================================================================\n\n/**\n * Create an ActionCtx instance.\n *\n * This factory function creates a context object with all the required\n * properties and methods for action functions.\n *\n * @param auth - Auth instance for authentication\n * @param storage - StorageReader instance for file storage\n * @param scheduler - Scheduler instance for delayed execution\n * @param runQuery - Function to execute query functions\n * @param runMutation - Function to execute mutation functions\n * @param runAction - Function to execute other action functions\n * @param vectorSearch - Function to perform vector search\n * @returns ActionCtx instance\n *\n * @example\n * ```typescript\n * const ctx = createActionCtx(\n *   auth,\n *   storage,\n *   scheduler,\n *   queryRunner,\n *   mutationRunner,\n *   actionRunner,\n *   vectorSearchRunner\n * );\n * // Use in action handler\n * const result = await actionHandler(ctx, args);\n * ```\n */\nexport function createActionCtx(\n  auth: Auth,\n  storage: StorageReader,\n  scheduler: Scheduler,\n  runQuery: <F extends FunctionReference<'query'>>(\n    query: F,\n    args: F['_args']\n  ) => Promise<F['_returns']>,\n  runMutation: <F extends FunctionReference<'mutation'>>(\n    mutation: F,\n    args: F['_args']\n  ) => Promise<F['_returns']>,\n  runAction: <F extends FunctionReference<'action'>>(\n    action: F,\n    args: F['_args']\n  ) => Promise<F['_returns']>,\n  vectorSearch: <TableName extends string>(\n    tableName: TableName,\n    indexName: string,\n    query: {\n      vector: number[]\n      limit?: number\n      filter?: (q: unknown) => unknown\n    }\n  ) => Promise<Array<{ _id: Id<TableName>; _score: number }>>\n): ActionCtx {\n  return {\n    auth,\n    storage,\n    scheduler,\n    runQuery,\n    runMutation,\n    runAction,\n    vectorSearch,\n  }\n}\n\n// ============================================================================\n// Validation Utilities\n// ============================================================================\n\n/**\n * Validate that a context object implements the ActionCtx interface.\n *\n * @param ctx - The context object to validate\n * @returns True if valid, throws error otherwise\n */\nexport function validateActionCtx(ctx: unknown): ctx is ActionCtx {\n  if (!ctx || typeof ctx !== 'object') {\n    throw new Error('ActionCtx must be an object')\n  }\n\n  const actionCtx = ctx as Record<string, unknown>\n\n  if (!actionCtx.auth || typeof actionCtx.auth !== 'object') {\n    throw new Error('ActionCtx.auth is required and must be an Auth instance')\n  }\n\n  if (!actionCtx.storage || typeof actionCtx.storage !== 'object') {\n    throw new Error('ActionCtx.storage is required and must be a StorageReader')\n  }\n\n  if (!actionCtx.scheduler || typeof actionCtx.scheduler !== 'object') {\n    throw new Error('ActionCtx.scheduler is required and must be a Scheduler')\n  }\n\n  if (typeof actionCtx.runQuery !== 'function') {\n    throw new Error('ActionCtx.runQuery is required and must be a function')\n  }\n\n  if (typeof actionCtx.runMutation !== 'function') {\n    throw new Error('ActionCtx.runMutation is required and must be a function')\n  }\n\n  if (typeof actionCtx.runAction !== 'function') {\n    throw new Error('ActionCtx.runAction is required and must be a function')\n  }\n\n  if (typeof actionCtx.vectorSearch !== 'function') {\n    throw new Error('ActionCtx.vectorSearch is required and must be a function')\n  }\n\n  return true\n}\n\n/**\n * Ensure all required methods are present on Auth.\n *\n * @param auth - The auth object to validate\n */\nexport function validateAuth(auth: unknown): auth is Auth {\n  if (!auth || typeof auth !== 'object') {\n    throw new Error('Auth must be an object')\n  }\n\n  const authObj = auth as Record<string, unknown>\n\n  if (typeof authObj.getUserIdentity !== 'function') {\n    throw new Error('Auth.getUserIdentity must be a function')\n  }\n\n  return true\n}\n\n/**\n * Ensure all required methods are present on StorageReader.\n *\n * @param storage - The storage object to validate\n */\nexport function validateStorageReader(storage: unknown): storage is StorageReader {\n  if (!storage || typeof storage !== 'object') {\n    throw new Error('StorageReader must be an object')\n  }\n\n  const storageReader = storage as Record<string, unknown>\n\n  if (typeof storageReader.getUrl !== 'function') {\n    throw new Error('StorageReader.getUrl must be a function')\n  }\n\n  if (typeof storageReader.getMetadata !== 'function') {\n    throw new Error('StorageReader.getMetadata must be a function')\n  }\n\n  return true\n}\n\n/**\n * Ensure all required methods are present on Scheduler.\n *\n * @param scheduler - The scheduler object to validate\n */\nexport function validateScheduler(scheduler: unknown): scheduler is Scheduler {\n  if (!scheduler || typeof scheduler !== 'object') {\n    throw new Error('Scheduler must be an object')\n  }\n\n  const schedulerObj = scheduler as Record<string, unknown>\n\n  if (typeof schedulerObj.runAfter !== 'function') {\n    throw new Error('Scheduler.runAfter must be a function')\n  }\n\n  if (typeof schedulerObj.runAt !== 'function') {\n    throw new Error('Scheduler.runAt must be a function')\n  }\n\n  if (typeof schedulerObj.cancel !== 'function') {\n    throw new Error('Scheduler.cancel must be a function')\n  }\n\n  return true\n}\n\n/**\n * Create a validated ActionCtx instance.\n *\n * This function creates an ActionCtx and validates all components\n * to ensure they implement the required interfaces.\n *\n * @param auth - Auth instance\n * @param storage - StorageReader instance\n * @param scheduler - Scheduler instance\n * @param runQuery - Function to execute query functions\n * @param runMutation - Function to execute mutation functions\n * @param runAction - Function to execute other action functions\n * @param vectorSearch - Function to perform vector search\n * @returns Validated ActionCtx instance\n * @throws Error if any component is invalid\n */\nexport function createValidatedActionCtx(\n  auth: Auth,\n  storage: StorageReader,\n  scheduler: Scheduler,\n  runQuery: <F extends FunctionReference<'query'>>(\n    query: F,\n    args: F['_args']\n  ) => Promise<F['_returns']>,\n  runMutation: <F extends FunctionReference<'mutation'>>(\n    mutation: F,\n    args: F['_args']\n  ) => Promise<F['_returns']>,\n  runAction: <F extends FunctionReference<'action'>>(\n    action: F,\n    args: F['_args']\n  ) => Promise<F['_returns']>,\n  vectorSearch: <TableName extends string>(\n    tableName: TableName,\n    indexName: string,\n    query: {\n      vector: number[]\n      limit?: number\n      filter?: (q: unknown) => unknown\n    }\n  ) => Promise<Array<{ _id: Id<TableName>; _score: number }>>\n): ActionCtx {\n  // Validate all components\n  validateAuth(auth)\n  validateStorageReader(storage)\n  validateScheduler(scheduler)\n\n  // Validate function arguments\n  if (typeof runQuery !== 'function') {\n    throw new Error('runQuery must be a function')\n  }\n  if (typeof runMutation !== 'function') {\n    throw new Error('runMutation must be a function')\n  }\n  if (typeof runAction !== 'function') {\n    throw new Error('runAction must be a function')\n  }\n  if (typeof vectorSearch !== 'function') {\n    throw new Error('vectorSearch must be a function')\n  }\n\n  // Create and return the context\n  return createActionCtx(\n    auth,\n    storage,\n    scheduler,\n    runQuery,\n    runMutation,\n    runAction,\n    vectorSearch\n  )\n}\n","/**\n * Registered Function Types and Utilities\n *\n * This module provides types and utilities for working with registered\n * Convex functions (queries, mutations, and actions).\n *\n * @module\n */\n\nimport type { Validator, ArgsValidator, Infer } from '../../values'\nimport type { RegisteredQuery, QueryConfig } from '../query'\nimport type { RegisteredMutation, MutationConfig } from '../mutation'\nimport type { RegisteredAction, ActionConfig } from '../action'\n\n// ============================================================================\n// Re-export Types from Individual Modules\n// ============================================================================\n\nexport type { RegisteredQuery } from '../query'\nexport type { RegisteredMutation } from '../mutation'\nexport type { RegisteredAction } from '../action'\n\n// ============================================================================\n// Union and Generic Types\n// ============================================================================\n\n/**\n * A union type representing any registered function (query, mutation, or action).\n */\nexport type AnyRegisteredFunction =\n  | RegisteredQuery<ArgsValidator | undefined, unknown>\n  | RegisteredMutation<ArgsValidator | undefined, unknown>\n  | RegisteredAction<ArgsValidator | undefined, unknown>\n\n/**\n * Function type literals.\n */\nexport type FunctionType = 'query' | 'mutation' | 'action'\n\n/**\n * Function visibility literals.\n */\nexport type FunctionVisibility = 'public' | 'internal'\n\n/**\n * Generic registered function type parameterized by function type.\n */\nexport type GenericRegisteredFunction<T extends FunctionType = FunctionType> =\n  T extends 'query'\n    ? RegisteredQuery<ArgsValidator | undefined, unknown>\n    : T extends 'mutation'\n    ? RegisteredMutation<ArgsValidator | undefined, unknown>\n    : T extends 'action'\n    ? RegisteredAction<ArgsValidator | undefined, unknown>\n    : never\n\n// ============================================================================\n// Type Extraction Utilities\n// ============================================================================\n\n/**\n * Extract the args type from a registered function.\n */\nexport type FunctionArgs<F extends AnyRegisteredFunction> = F['_args']\n\n/**\n * Extract the return type from a registered function.\n */\nexport type FunctionReturns<F extends AnyRegisteredFunction> = F['_returns']\n\n// ============================================================================\n// Type Guards\n// ============================================================================\n\n/**\n * Check if a value is a RegisteredQuery.\n *\n * @param fn - The value to check\n * @returns True if the value is a RegisteredQuery\n *\n * @example\n * ```typescript\n * const fn = query({ handler: async (ctx) => 'hello' })\n * if (isQuery(fn)) {\n *   // fn is typed as RegisteredQuery\n * }\n * ```\n */\nexport function isQuery(fn: unknown): fn is RegisteredQuery<ArgsValidator | undefined, unknown> {\n  return (\n    fn !== null &&\n    fn !== undefined &&\n    typeof fn === 'object' &&\n    '_type' in fn &&\n    fn._type === 'query'\n  )\n}\n\n/**\n * Check if a value is a RegisteredMutation.\n *\n * @param fn - The value to check\n * @returns True if the value is a RegisteredMutation\n *\n * @example\n * ```typescript\n * const fn = mutation({ handler: async (ctx) => 'created' })\n * if (isMutation(fn)) {\n *   // fn is typed as RegisteredMutation\n * }\n * ```\n */\nexport function isMutation(fn: unknown): fn is RegisteredMutation<ArgsValidator | undefined, unknown> {\n  return (\n    fn !== null &&\n    fn !== undefined &&\n    typeof fn === 'object' &&\n    '_type' in fn &&\n    fn._type === 'mutation'\n  )\n}\n\n/**\n * Check if a value is a RegisteredAction.\n *\n * @param fn - The value to check\n * @returns True if the value is a RegisteredAction\n *\n * @example\n * ```typescript\n * const fn = action({ handler: async (ctx) => 'done' })\n * if (isAction(fn)) {\n *   // fn is typed as RegisteredAction\n * }\n * ```\n */\nexport function isAction(fn: unknown): fn is RegisteredAction<ArgsValidator | undefined, unknown> {\n  return (\n    fn !== null &&\n    fn !== undefined &&\n    typeof fn === 'object' &&\n    '_type' in fn &&\n    fn._type === 'action'\n  )\n}\n\n/**\n * Check if a value is any type of registered function.\n *\n * @param fn - The value to check\n * @returns True if the value is a RegisteredQuery, RegisteredMutation, or RegisteredAction\n *\n * @example\n * ```typescript\n * if (isRegisteredFunction(fn)) {\n *   console.log(fn._type) // 'query' | 'mutation' | 'action'\n * }\n * ```\n */\nexport function isRegisteredFunction(fn: unknown): fn is AnyRegisteredFunction {\n  return isQuery(fn) || isMutation(fn) || isAction(fn)\n}\n\n/**\n * Check if a registered function is public (callable from clients).\n *\n * @param fn - The value to check\n * @returns True if the value is a public registered function\n *\n * @example\n * ```typescript\n * const q = query({ handler: async (ctx) => 'hello' })\n * console.log(isPublicFunction(q)) // true\n *\n * const internal = internalQuery({ handler: async (ctx) => 'hello' })\n * console.log(isPublicFunction(internal)) // false\n * ```\n */\nexport function isPublicFunction(fn: unknown): fn is AnyRegisteredFunction {\n  return isRegisteredFunction(fn) && fn._visibility === 'public'\n}\n\n/**\n * Check if a registered function is internal (only callable from other functions).\n *\n * @param fn - The value to check\n * @returns True if the value is an internal registered function\n *\n * @example\n * ```typescript\n * const q = internalQuery({ handler: async (ctx) => 'hello' })\n * console.log(isInternalFunction(q)) // true\n * ```\n */\nexport function isInternalFunction(fn: unknown): fn is AnyRegisteredFunction {\n  return isRegisteredFunction(fn) && fn._visibility === 'internal'\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Get the type of a registered function ('query', 'mutation', or 'action').\n *\n * @param fn - The registered function\n * @returns The function type\n *\n * @example\n * ```typescript\n * const q = query({ handler: async (ctx) => 'hello' })\n * console.log(getFunctionType(q)) // 'query'\n * ```\n */\nexport function getFunctionType(fn: AnyRegisteredFunction): FunctionType {\n  return fn._type\n}\n\n/**\n * Get the visibility of a registered function ('public' or 'internal').\n *\n * @param fn - The registered function\n * @returns The function visibility\n *\n * @example\n * ```typescript\n * const q = query({ handler: async (ctx) => 'hello' })\n * console.log(getFunctionVisibility(q)) // 'public'\n *\n * const internal = internalQuery({ handler: async (ctx) => 'hello' })\n * console.log(getFunctionVisibility(internal)) // 'internal'\n * ```\n */\nexport function getFunctionVisibility(fn: AnyRegisteredFunction): FunctionVisibility {\n  return fn._visibility\n}\n\n/**\n * Get the args validator from a registered function.\n *\n * @param fn - The registered function\n * @returns The args validator, or undefined if not defined\n *\n * @example\n * ```typescript\n * const q = query({\n *   args: { id: v.string() },\n *   handler: async (ctx, args) => args.id\n * })\n * const validator = getArgsValidator(q) // { id: v.string() }\n * ```\n */\nexport function getArgsValidator(fn: AnyRegisteredFunction): ArgsValidator | undefined {\n  return fn._config.args\n}\n\n/**\n * Get the returns validator from a registered function.\n *\n * @param fn - The registered function\n * @returns The returns validator, or undefined if not defined\n *\n * @example\n * ```typescript\n * const q = query({\n *   returns: v.string(),\n *   handler: async (ctx) => 'hello'\n * })\n * const validator = getReturnsValidator(q) // v.string()\n * ```\n */\nexport function getReturnsValidator(fn: AnyRegisteredFunction): Validator | undefined {\n  return fn._config.returns\n}\n\n/**\n * Get the handler function from a registered function.\n *\n * @param fn - The registered function\n * @returns The handler function\n *\n * @example\n * ```typescript\n * const q = query({ handler: async (ctx) => 'hello' })\n * const handler = getFunctionHandler(q)\n * ```\n */\nexport function getFunctionHandler<F extends AnyRegisteredFunction>(\n  fn: F\n): F['_config']['handler'] {\n  return fn._config.handler\n}\n","/**\n * Function Registry for convex.do\n *\n * Provides a singleton registry for storing and looking up registered Convex functions\n * (queries, mutations, actions) and HTTP endpoints.\n *\n * The registry supports:\n * - Registration of functions with path validation\n * - Lookup of functions by path\n * - Listing functions by type and visibility\n * - HTTP endpoint registration with path parameter matching\n * - Module-based bulk registration\n *\n * Bead: convex-2pb - Function Registration and Lookup System\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Function types supported by the registry.\n */\nexport type FunctionType = 'query' | 'mutation' | 'action'\n\n/**\n * Function visibility levels.\n */\nexport type FunctionVisibility = 'public' | 'internal'\n\n/**\n * HTTP methods supported by the registry.\n */\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD'\n\n/**\n * A registered function (query, mutation, or action).\n */\nexport interface RegisteredFunction {\n  readonly _type: FunctionType\n  readonly _visibility: FunctionVisibility\n  readonly _config: {\n    handler: (...args: unknown[]) => unknown | Promise<unknown>\n    args?: unknown\n    returns?: unknown\n  }\n}\n\n/**\n * A registered HTTP endpoint.\n */\nexport interface RegisteredHttpEndpoint {\n  readonly _type: 'httpAction'\n  readonly _config: {\n    path: string\n    method: HttpMethod\n    handler: (ctx: unknown, request: Request) => Promise<Response>\n  }\n}\n\n/**\n * Entry for a registered function in the registry.\n */\nexport interface FunctionEntry {\n  /** The registration path */\n  path: string\n  /** The function type */\n  type: FunctionType\n  /** The function visibility */\n  visibility: FunctionVisibility\n  /** The registered function */\n  fn: RegisteredFunction\n}\n\n/**\n * Entry for a registered HTTP endpoint in the registry.\n */\nexport interface HttpEndpointEntry {\n  /** The HTTP path pattern */\n  path: string\n  /** The HTTP method */\n  method: HttpMethod\n  /** The registered endpoint */\n  endpoint: RegisteredHttpEndpoint\n}\n\n/**\n * Match result for HTTP endpoint with extracted parameters.\n */\nexport interface HttpEndpointMatch extends HttpEndpointEntry {\n  /** Extracted path parameters */\n  params: Record<string, string>\n}\n\n/**\n * Options for registration methods.\n */\nexport interface RegistrationOptions {\n  /** Force overwrite existing registration */\n  force?: boolean\n}\n\n// ============================================================================\n// Error Class\n// ============================================================================\n\n/**\n * Error class for function registry errors.\n */\nexport class FunctionRegistryError extends Error {\n  public readonly code?: string\n\n  constructor(message: string, code?: string) {\n    super(message)\n    this.name = 'FunctionRegistryError'\n    this.code = code\n\n    // Maintains proper stack trace for where error was thrown (V8 only)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, FunctionRegistryError)\n    }\n  }\n}\n\n// ============================================================================\n// Path Validation\n// ============================================================================\n\n/**\n * Regex for validating function paths.\n * Allows alphanumeric characters, underscores, colons, and slashes.\n * Must not start or end with separators, and no consecutive separators.\n */\nconst FUNCTION_PATH_REGEX = /^[a-zA-Z0-9_]+([:/][a-zA-Z0-9_]+)*$/\n\n/**\n * Regex for validating HTTP paths.\n * Must start with / and can contain path parameters like :id.\n */\nconst HTTP_PATH_REGEX = /^\\/[a-zA-Z0-9_/:.-]*$/\n\n/**\n * Validate a function path.\n */\nfunction validateFunctionPath(path: string): void {\n  if (!path || path.trim() === '') {\n    throw new FunctionRegistryError('Function path cannot be empty', 'INVALID_PATH')\n  }\n\n  const trimmedPath = path.trim()\n\n  if (!FUNCTION_PATH_REGEX.test(trimmedPath)) {\n    throw new FunctionRegistryError(\n      `Invalid function path: \"${path}\". Paths must be alphanumeric with underscores, separated by colons or slashes.`,\n      'INVALID_PATH'\n    )\n  }\n}\n\n/**\n * Validate an HTTP path.\n */\nfunction validateHttpPath(path: string): void {\n  if (!path || path.trim() === '') {\n    throw new FunctionRegistryError('HTTP path cannot be empty', 'INVALID_PATH')\n  }\n\n  if (!path.startsWith('/')) {\n    throw new FunctionRegistryError(\n      `Invalid HTTP path: \"${path}\". HTTP paths must start with \"/\".`,\n      'INVALID_PATH'\n    )\n  }\n\n  if (!HTTP_PATH_REGEX.test(path)) {\n    throw new FunctionRegistryError(\n      `Invalid HTTP path: \"${path}\". HTTP paths must be valid URL paths.`,\n      'INVALID_PATH'\n    )\n  }\n}\n\n// ============================================================================\n// Function Registry\n// ============================================================================\n\n/**\n * Singleton registry for Convex functions and HTTP endpoints.\n *\n * @example\n * ```typescript\n * const registry = FunctionRegistry.getInstance()\n *\n * // Register functions\n * registry.register('users:get', getUserQuery)\n * registry.register('users:create', createUserMutation)\n *\n * // Lookup functions\n * const fn = registry.getFunction('users:get')\n * const queries = registry.listFunctions('query')\n *\n * // HTTP endpoints\n * registry.registerHttpEndpoint('/api/users', 'GET', listUsersEndpoint)\n * const endpoint = registry.getHttpEndpoint('/api/users', 'GET')\n * ```\n */\nexport class FunctionRegistry implements Iterable<FunctionEntry> {\n  private static instance: FunctionRegistry | null = null\n\n  private readonly functionMap: Map<string, FunctionEntry> = new Map()\n  private readonly httpEndpoints: Map<string, HttpEndpointEntry> = new Map()\n\n  /**\n   * Private constructor to enforce singleton pattern.\n   */\n  private constructor() {}\n\n  /**\n   * Get the singleton instance of the registry.\n   */\n  public static getInstance(): FunctionRegistry {\n    if (!FunctionRegistry.instance) {\n      FunctionRegistry.instance = new FunctionRegistry()\n    }\n    return FunctionRegistry.instance\n  }\n\n  /**\n   * Reset the singleton instance (for testing purposes).\n   */\n  public static resetInstance(): void {\n    FunctionRegistry.instance = null\n  }\n\n  // ==========================================================================\n  // Function Registration\n  // ==========================================================================\n\n  /**\n   * Register a function with the given path.\n   *\n   * @param path - The function path (e.g., \"users:get\" or \"users/get\")\n   * @param fn - The registered function\n   * @param options - Registration options\n   * @returns The registry instance for chaining\n   * @throws FunctionRegistryError if path is invalid or already registered\n   */\n  public register(\n    path: string,\n    fn: RegisteredFunction,\n    options: RegistrationOptions = {}\n  ): this {\n    validateFunctionPath(path)\n\n    if (this.functionMap.has(path) && !options.force) {\n      throw new FunctionRegistryError(\n        `Function already registered at path: \"${path}\". Use { force: true } to overwrite.`,\n        'DUPLICATE_PATH'\n      )\n    }\n\n    const entry: FunctionEntry = {\n      path,\n      type: fn._type,\n      visibility: fn._visibility,\n      fn,\n    }\n\n    this.functionMap.set(path, entry)\n    return this\n  }\n\n  /**\n   * Get a registered function by path.\n   *\n   * @param path - The function path\n   * @returns The function entry or undefined if not found\n   */\n  public getFunction(path: string): FunctionEntry | undefined {\n    return this.functionMap.get(path)\n  }\n\n  /**\n   * Check if a function is registered at the given path.\n   *\n   * @param path - The function path\n   * @returns True if a function is registered at the path\n   */\n  public has(path: string): boolean {\n    return this.functionMap.has(path)\n  }\n\n  /**\n   * Unregister a function at the given path.\n   *\n   * @param path - The function path\n   * @returns True if a function was removed, false if not found\n   */\n  public unregister(path: string): boolean {\n    return this.functionMap.delete(path)\n  }\n\n  /**\n   * List all registered functions, optionally filtered by type and/or visibility.\n   *\n   * @param type - Optional function type filter\n   * @param visibility - Optional visibility filter\n   * @returns Array of function entries\n   */\n  public listFunctions(type?: FunctionType, visibility?: FunctionVisibility): FunctionEntry[] {\n    const entries = Array.from(this.functionMap.values())\n\n    return entries.filter(entry => {\n      if (type !== undefined && entry.type !== type) {\n        return false\n      }\n      if (visibility !== undefined && entry.visibility !== visibility) {\n        return false\n      }\n      return true\n    })\n  }\n\n  // ==========================================================================\n  // HTTP Endpoint Registration\n  // ==========================================================================\n\n  /**\n   * Generate a key for HTTP endpoint storage.\n   */\n  private httpEndpointKey(path: string, method: HttpMethod): string {\n    return `${method}:${path}`\n  }\n\n  /**\n   * Register an HTTP endpoint.\n   *\n   * @param path - The HTTP path pattern (e.g., \"/api/users/:id\")\n   * @param method - The HTTP method\n   * @param endpoint - The registered HTTP endpoint\n   * @param options - Registration options\n   * @returns The registry instance for chaining\n   * @throws FunctionRegistryError if path is invalid or already registered\n   */\n  public registerHttpEndpoint(\n    path: string,\n    method: HttpMethod,\n    endpoint: RegisteredHttpEndpoint,\n    options: RegistrationOptions = {}\n  ): this {\n    validateHttpPath(path)\n\n    const key = this.httpEndpointKey(path, method)\n\n    if (this.httpEndpoints.has(key) && !options.force) {\n      throw new FunctionRegistryError(\n        `HTTP endpoint already registered at ${method} ${path}. Use { force: true } to overwrite.`,\n        'DUPLICATE_ENDPOINT'\n      )\n    }\n\n    const entry: HttpEndpointEntry = {\n      path,\n      method,\n      endpoint,\n    }\n\n    this.httpEndpoints.set(key, entry)\n    return this\n  }\n\n  /**\n   * Get a registered HTTP endpoint by exact path and method.\n   *\n   * @param path - The HTTP path\n   * @param method - The HTTP method\n   * @returns The endpoint entry or undefined if not found\n   */\n  public getHttpEndpoint(path: string, method: HttpMethod): HttpEndpointEntry | undefined {\n    const key = this.httpEndpointKey(path, method)\n    return this.httpEndpoints.get(key)\n  }\n\n  /**\n   * Check if an HTTP endpoint is registered at the given path and method.\n   *\n   * @param path - The HTTP path\n   * @param method - The HTTP method\n   * @returns True if an endpoint is registered\n   */\n  public hasHttpEndpoint(path: string, method: HttpMethod): boolean {\n    const key = this.httpEndpointKey(path, method)\n    return this.httpEndpoints.has(key)\n  }\n\n  /**\n   * Unregister an HTTP endpoint at the given path and method.\n   *\n   * @param path - The HTTP path\n   * @param method - The HTTP method\n   * @returns True if an endpoint was removed, false if not found\n   */\n  public unregisterHttpEndpoint(path: string, method: HttpMethod): boolean {\n    const key = this.httpEndpointKey(path, method)\n    return this.httpEndpoints.delete(key)\n  }\n\n  /**\n   * List all registered HTTP endpoints, optionally filtered by method.\n   *\n   * @param method - Optional HTTP method filter\n   * @returns Array of HTTP endpoint entries\n   */\n  public listHttpEndpoints(method?: HttpMethod): HttpEndpointEntry[] {\n    const entries = Array.from(this.httpEndpoints.values())\n\n    if (method === undefined) {\n      return entries\n    }\n\n    return entries.filter(entry => entry.method === method)\n  }\n\n  /**\n   * Match an HTTP request path and method to a registered endpoint.\n   * Supports path parameters (e.g., \"/api/users/:id\" matches \"/api/users/123\").\n   *\n   * @param requestPath - The actual request path\n   * @param method - The HTTP method\n   * @returns The matched endpoint with extracted parameters, or undefined if no match\n   */\n  public matchHttpEndpoint(requestPath: string, method: HttpMethod): HttpEndpointMatch | undefined {\n    // First, try exact match\n    const exactKey = this.httpEndpointKey(requestPath, method)\n    const exactMatch = this.httpEndpoints.get(exactKey)\n    if (exactMatch) {\n      return {\n        ...exactMatch,\n        params: {},\n      }\n    }\n\n    // Then, try pattern matching\n    const methodEndpoints = this.listHttpEndpoints(method)\n\n    for (const entry of methodEndpoints) {\n      const params = this.matchPath(entry.path, requestPath)\n      if (params !== null) {\n        return {\n          ...entry,\n          params,\n        }\n      }\n    }\n\n    return undefined\n  }\n\n  /**\n   * Match a request path against a pattern path, extracting parameters.\n   *\n   * @param pattern - The pattern path (e.g., \"/api/users/:id\")\n   * @param requestPath - The actual request path (e.g., \"/api/users/123\")\n   * @returns Extracted parameters or null if no match\n   */\n  private matchPath(pattern: string, requestPath: string): Record<string, string> | null {\n    const patternParts = pattern.split('/').filter(Boolean)\n    const requestParts = requestPath.split('/').filter(Boolean)\n\n    if (patternParts.length !== requestParts.length) {\n      return null\n    }\n\n    const params: Record<string, string> = {}\n\n    for (let i = 0; i < patternParts.length; i++) {\n      const patternPart = patternParts[i]\n      const requestPart = requestParts[i]\n\n      if (patternPart.startsWith(':')) {\n        // Path parameter\n        const paramName = patternPart.slice(1)\n        params[paramName] = requestPart\n      } else if (patternPart !== requestPart) {\n        // Static part doesn't match\n        return null\n      }\n    }\n\n    return params\n  }\n\n  // ==========================================================================\n  // Module Registration\n  // ==========================================================================\n\n  /**\n   * Register multiple functions from a module object.\n   *\n   * @param prefix - The path prefix for all functions in the module\n   * @param module - An object containing registered functions\n   * @returns The registry instance for chaining\n   */\n  public registerModule(\n    prefix: string,\n    module: Record<string, unknown>\n  ): this {\n    for (const [name, value] of Object.entries(module)) {\n      // Check if value is a registered function\n      if (this.isRegisteredFunction(value)) {\n        const path = `${prefix}:${name}`\n        this.register(path, value)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Check if a value is a registered function.\n   */\n  private isRegisteredFunction(value: unknown): value is RegisteredFunction {\n    if (!value || typeof value !== 'object') {\n      return false\n    }\n\n    const obj = value as Record<string, unknown>\n    return (\n      obj._type === 'query' ||\n      obj._type === 'mutation' ||\n      obj._type === 'action'\n    ) && (\n      obj._visibility === 'public' ||\n      obj._visibility === 'internal'\n    ) && (\n      typeof obj._config === 'object' &&\n      obj._config !== null &&\n      typeof (obj._config as Record<string, unknown>).handler === 'function'\n    )\n  }\n\n  // ==========================================================================\n  // Utility Methods\n  // ==========================================================================\n\n  /**\n   * Get the number of registered functions.\n   */\n  public size(): number {\n    return this.functionMap.size\n  }\n\n  /**\n   * Get the number of registered HTTP endpoints.\n   */\n  public httpEndpointCount(): number {\n    return this.httpEndpoints.size\n  }\n\n  /**\n   * Clear all registered functions and HTTP endpoints.\n   */\n  public clear(): void {\n    this.functionMap.clear()\n    this.httpEndpoints.clear()\n  }\n\n  // ==========================================================================\n  // Iteration Support\n  // ==========================================================================\n\n  /**\n   * Iterate over all registered functions.\n   */\n  public [Symbol.iterator](): Iterator<FunctionEntry> {\n    return this.functionMap.values()\n  }\n\n  /**\n   * Get entries as [path, entry] pairs.\n   */\n  public entries(): IterableIterator<[string, FunctionEntry]> {\n    return this.functionMap.entries()\n  }\n\n  /**\n   * Get all registered paths.\n   */\n  public paths(): IterableIterator<string> {\n    return this.functionMap.keys()\n  }\n\n  /**\n   * Get all registered functions (without path information).\n   */\n  public *functions(): IterableIterator<RegisteredFunction> {\n    for (const entry of this.functionMap.values()) {\n      yield entry.fn\n    }\n  }\n}\n","/**\n * FunctionReference Types and api() Generation\n *\n * This module provides:\n * - FunctionReference<Type, Args, Returns> type\n * - api object generation\n * - Type-safe function references\n * - makeFunctionReference helper\n * - Function path resolution\n * - Nested module references (api.users.get)\n *\n * 100% compatible with Convex's convex/server exports.\n */\n\n// ============================================================================\n// Core Types\n// ============================================================================\n\n/**\n * Function types supported by Convex.\n */\nexport type FunctionType = 'query' | 'mutation' | 'action'\n\n/**\n * Visibility levels for functions.\n */\nexport type FunctionVisibility = 'public' | 'internal'\n\n/**\n * A reference to a registered function.\n * This is the core type for type-safe function calls.\n *\n * @typeParam Type - The function type ('query' | 'mutation' | 'action')\n * @typeParam Args - The argument type for the function\n * @typeParam Returns - The return type of the function\n * @typeParam Visibility - The visibility level ('public' | 'internal')\n */\nexport interface FunctionReference<\n  Type extends FunctionType = FunctionType,\n  Args = unknown,\n  Returns = unknown,\n  Visibility extends FunctionVisibility = 'public'\n> {\n  /** The function type */\n  _type: Type\n  /** The argument type (phantom type for type inference) */\n  _args: Args\n  /** The return type (phantom type for type inference) */\n  _returns: Returns\n  /** The full path to the function (e.g., 'users:get' or 'admin/users:list') */\n  _path: string\n  /** The visibility level */\n  _visibility: Visibility\n}\n\n/**\n * A generic function reference with unknown args and returns.\n * Useful when you need to accept any function reference of a specific type.\n */\nexport type GenericFunctionReference<\n  Type extends FunctionType = FunctionType,\n  Visibility extends FunctionVisibility = FunctionVisibility\n> = FunctionReference<Type, unknown, unknown, Visibility>\n\n/**\n * Any function reference (query, mutation, or action).\n */\nexport type AnyFunctionReference = FunctionReference<FunctionType, unknown, unknown, FunctionVisibility>\n\n/**\n * Shorthand for query function references.\n */\nexport type QueryReference<Args = unknown, Returns = unknown> = FunctionReference<'query', Args, Returns>\n\n/**\n * Shorthand for mutation function references.\n */\nexport type MutationReference<Args = unknown, Returns = unknown> = FunctionReference<'mutation', Args, Returns>\n\n/**\n * Shorthand for action function references.\n */\nexport type ActionReference<Args = unknown, Returns = unknown> = FunctionReference<'action', Args, Returns>\n\n/**\n * A function reference that can be scheduled (mutations and actions only).\n * Queries cannot be scheduled because they are read-only.\n */\nexport type SchedulableFunctionReference = FunctionReference<'mutation' | 'action', unknown, unknown, FunctionVisibility>\n\n// ============================================================================\n// Type Helpers\n// ============================================================================\n\n/**\n * Extract the args type from a function reference.\n */\nexport type FunctionArgs<F extends AnyFunctionReference> = F['_args']\n\n/**\n * Extract the return type from a function reference.\n */\nexport type FunctionReturnType<F extends AnyFunctionReference> = F['_returns']\n\n/**\n * Filter an API object to only include functions of a specific type.\n */\nexport type FilterByFunctionType<\n  API,\n  Type extends FunctionType\n> = {\n  [K in keyof API]: API[K] extends FunctionReference<Type, infer A, infer R>\n    ? FunctionReference<Type, A, R>\n    : API[K] extends Record<string, unknown>\n    ? FilterByFunctionType<API[K], Type>\n    : never\n}\n\n/**\n * Optional rest args for functions with empty args.\n * When args is an empty object, the args parameter becomes optional.\n */\nexport type OptionalRestArgs<F extends AnyFunctionReference> =\n  FunctionArgs<F> extends Record<string, never>\n    ? [] | [Record<string, never>]\n    : [FunctionArgs<F>]\n\n/**\n * Args and options combined for function calls with additional options.\n */\nexport type ArgsAndOptions<\n  F extends AnyFunctionReference,\n  Options\n> = FunctionArgs<F> extends Record<string, never>\n  ? [] | [Record<string, never>] | [Record<string, never>, Options]\n  : [FunctionArgs<F>] | [FunctionArgs<F>, Options]\n\n// ============================================================================\n// Registered Function Type\n// ============================================================================\n\n/**\n * A registered function with metadata.\n * Used internally for building the api and internal objects.\n */\nexport interface RegisteredFunction {\n  _type: FunctionType\n  _visibility: FunctionVisibility\n  _args?: unknown\n  _returns?: unknown\n}\n\n// ============================================================================\n// Function Path Utilities\n// ============================================================================\n\n/**\n * Parsed function path result.\n */\nexport interface ParsedFunctionPath {\n  /** The module path (e.g., 'users' or 'admin/users') */\n  module: string\n  /** The function name (e.g., 'get' or 'list') */\n  functionName: string\n  /** The full path (e.g., 'users:get' or 'admin/users:list') */\n  fullPath: string\n}\n\n/**\n * Parse a function path into its components.\n *\n * @param path - The function path (e.g., 'users:get' or 'admin/users:list')\n * @returns The parsed path components\n *\n * @example\n * ```typescript\n * parseFunctionPath('users:get')\n * // => { module: 'users', functionName: 'get', fullPath: 'users:get' }\n *\n * parseFunctionPath('admin/users:list')\n * // => { module: 'admin/users', functionName: 'list', fullPath: 'admin/users:list' }\n * ```\n */\nexport function parseFunctionPath(path: string): ParsedFunctionPath {\n  const colonIndex = path.lastIndexOf(':')\n\n  if (colonIndex === -1) {\n    // No colon, treat the whole path as function name\n    return {\n      module: '',\n      functionName: path,\n      fullPath: path,\n    }\n  }\n\n  return {\n    module: path.substring(0, colonIndex),\n    functionName: path.substring(colonIndex + 1),\n    fullPath: path,\n  }\n}\n\n// ============================================================================\n// makeFunctionReference Helper\n// ============================================================================\n\n/**\n * Internal helper to create function references with explicit type.\n */\nfunction createFunctionRef<\n  Type extends FunctionType,\n  Args = unknown,\n  Returns = unknown,\n  Visibility extends FunctionVisibility = 'public'\n>(\n  type: Type,\n  path: string,\n  visibility: Visibility\n): FunctionReference<Type, Args, Returns, Visibility> {\n  return {\n    _type: type,\n    _args: undefined as unknown as Args,\n    _returns: undefined as unknown as Returns,\n    _path: path,\n    _visibility: visibility,\n  }\n}\n\n/**\n * Create a function reference from a path.\n *\n * This function uses TypeScript's generic type parameter to determine the function type.\n * Since generics are erased at runtime, this function uses a mapping approach where\n * the first type parameter determines the runtime type.\n *\n * @typeParam Type - The function type\n * @typeParam Args - The argument type\n * @typeParam Returns - The return type\n * @typeParam Visibility - The visibility level\n *\n * @param path - The function path (e.g., 'users:get')\n * @param visibility - The visibility level (default: 'public')\n * @returns A typed function reference\n *\n * @example\n * ```typescript\n * const ref = makeFunctionReference<'query', { id: string }, User | null>(\n *   'users:get'\n * )\n * // Use with ctx.runQuery(ref, { id: userId })\n * ```\n */\nexport function makeFunctionReference<\n  Type extends FunctionType,\n  Args = unknown,\n  Returns = unknown,\n  Visibility extends FunctionVisibility = 'public'\n>(\n  path: string,\n  visibility?: Visibility\n): FunctionReference<Type, Args, Returns, Visibility>\n\n// Overloads for better type inference with explicit types\nexport function makeFunctionReference<\n  Args = unknown,\n  Returns = unknown,\n  Visibility extends FunctionVisibility = 'public'\n>(\n  path: string,\n  visibility?: Visibility\n): FunctionReference<'query', Args, Returns, Visibility>\n\nexport function makeFunctionReference<\n  Type extends FunctionType = 'query',\n  Args = unknown,\n  Returns = unknown,\n  Visibility extends FunctionVisibility = 'public'\n>(\n  path: string,\n  visibility: Visibility = 'public' as Visibility\n): FunctionReference<Type, Args, Returns, Visibility> {\n  // Since TypeScript generics are erased at runtime, we need to determine\n  // the function type from context. The createApi/createInternalApi functions\n  // provide the runtime type when creating references from registered functions.\n  //\n  // For makeFunctionReference, the type is primarily for compile-time safety.\n  // The runtime type defaults to 'query' but is overridden when used with\n  // the specialized factory functions below.\n  return createFunctionRef('query' as Type, path, visibility)\n}\n\n/**\n * Create a query function reference.\n */\nexport function makeQueryReference<\n  Args = unknown,\n  Returns = unknown,\n  Visibility extends FunctionVisibility = 'public'\n>(\n  path: string,\n  visibility: Visibility = 'public' as Visibility\n): FunctionReference<'query', Args, Returns, Visibility> {\n  return createFunctionRef('query', path, visibility)\n}\n\n/**\n * Create a mutation function reference.\n */\nexport function makeMutationReference<\n  Args = unknown,\n  Returns = unknown,\n  Visibility extends FunctionVisibility = 'public'\n>(\n  path: string,\n  visibility: Visibility = 'public' as Visibility\n): FunctionReference<'mutation', Args, Returns, Visibility> {\n  return createFunctionRef('mutation', path, visibility)\n}\n\n/**\n * Create an action function reference.\n */\nexport function makeActionReference<\n  Args = unknown,\n  Returns = unknown,\n  Visibility extends FunctionVisibility = 'public'\n>(\n  path: string,\n  visibility: Visibility = 'public' as Visibility\n): FunctionReference<'action', Args, Returns, Visibility> {\n  return createFunctionRef('action', path, visibility)\n}\n\n// ============================================================================\n// getFunctionName Helper\n// ============================================================================\n\n/**\n * Get the function name/path from a function reference.\n *\n * @param ref - The function reference\n * @returns The function path string\n *\n * @example\n * ```typescript\n * const ref = makeFunctionReference<'query', {}, void>('users:get')\n * getFunctionName(ref) // => 'users:get'\n * ```\n */\nexport function getFunctionName(ref: AnyFunctionReference): string {\n  return ref._path\n}\n\n// ============================================================================\n// functionName Template Literal\n// ============================================================================\n\n/**\n * Regular expression for valid function paths.\n * Allows: module:function, module/submodule:function, etc.\n */\nconst VALID_PATH_REGEX = /^[a-zA-Z0-9_/]+:[a-zA-Z0-9_]+$|^[a-zA-Z0-9_]+$/\n\n/**\n * Template literal tag for creating function name strings.\n * Validates the path format and returns a string.\n *\n * @example\n * ```typescript\n * const name = functionName`users:get`\n * // => 'users:get'\n *\n * const module = 'users'\n * const func = 'create'\n * const name2 = functionName`${module}:${func}`\n * // => 'users:create'\n * ```\n */\nexport function functionName(\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): string {\n  // Combine template literal parts\n  let result = strings[0]\n  for (let i = 0; i < values.length; i++) {\n    result += String(values[i]) + strings[i + 1]\n  }\n\n  // Validate the path format\n  if (!VALID_PATH_REGEX.test(result)) {\n    throw new Error(\n      `Invalid function path format: \"${result}\". Expected format: \"module:function\" or \"module/submodule:function\"`\n    )\n  }\n\n  return result\n}\n\n// ============================================================================\n// createFunctionHandle Helper\n// ============================================================================\n\n/**\n * Create a serializable function handle from a function reference.\n * Function handles can be stored in the database and used later.\n *\n * @param ref - The function reference\n * @returns A string handle that can be serialized\n *\n * @example\n * ```typescript\n * const ref = makeFunctionReference<'mutation', {}, void>('tasks:process')\n * const handle = createFunctionHandle(ref)\n * // Store handle in database, use later with scheduler\n * ```\n */\nexport function createFunctionHandle(ref: AnyFunctionReference): string {\n  return ref._path\n}\n\n// ============================================================================\n// API Object Generation\n// ============================================================================\n\n/**\n * Nested API structure type.\n * Represents the nested module structure of the api object.\n */\nexport type NestedApi = {\n  [key: string]: FunctionReference<FunctionType, unknown, unknown, FunctionVisibility> | NestedApi\n}\n\n/**\n * Set a value in a nested object by path.\n * Creates intermediate objects as needed.\n */\nfunction setNestedValue(obj: NestedApi, path: string[], value: AnyFunctionReference): void {\n  let current = obj\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i]\n    if (!(key in current)) {\n      current[key] = {}\n    }\n    current = current[key] as NestedApi\n  }\n  current[path[path.length - 1]] = value\n}\n\n/**\n * Build the path array from a function path string.\n * Converts 'admin/users:list' to ['admin', 'users', 'list']\n */\nfunction buildPathArray(functionPath: string): string[] {\n  const parsed = parseFunctionPath(functionPath)\n  const moduleParts = parsed.module ? parsed.module.split('/') : []\n  return [...moduleParts, parsed.functionName]\n}\n\n/**\n * Create an api object from registered functions.\n * Only includes public functions.\n *\n * @param registeredFunctions - Map of function paths to registered functions\n * @returns An api object with nested module structure\n *\n * @example\n * ```typescript\n * const registeredFunctions = {\n *   'users:get': { _type: 'query', _visibility: 'public' },\n *   'users:create': { _type: 'mutation', _visibility: 'public' },\n *   'admin/users:list': { _type: 'query', _visibility: 'public' },\n * }\n *\n * const api = createApi(registeredFunctions)\n * // api.users.get._path === 'users:get'\n * // api.admin.users.list._path === 'admin/users:list'\n * ```\n */\nexport function createApi(\n  registeredFunctions: Record<string, RegisteredFunction>\n): NestedApi {\n  const api: NestedApi = {}\n\n  for (const [path, func] of Object.entries(registeredFunctions)) {\n    // Only include public functions in the api object\n    if (func._visibility !== 'public') {\n      continue\n    }\n\n    const pathArray = buildPathArray(path)\n    const ref: AnyFunctionReference = {\n      _type: func._type,\n      _args: func._args,\n      _returns: func._returns,\n      _path: path,\n      _visibility: 'public',\n    }\n\n    setNestedValue(api, pathArray, ref)\n  }\n\n  return api\n}\n\n/**\n * Create an internal api object from registered functions.\n * Only includes internal functions.\n *\n * @param registeredFunctions - Map of function paths to registered functions\n * @returns An internal api object with nested module structure\n *\n * @example\n * ```typescript\n * const registeredFunctions = {\n *   'users:getSecret': { _type: 'query', _visibility: 'internal' },\n *   'admin/secrets:get': { _type: 'query', _visibility: 'internal' },\n * }\n *\n * const internal = createInternalApi(registeredFunctions)\n * // internal.users.getSecret._path === 'users:getSecret'\n * // internal.admin.secrets.get._path === 'admin/secrets:get'\n * ```\n */\nexport function createInternalApi(\n  registeredFunctions: Record<string, RegisteredFunction>\n): NestedApi {\n  const internal: NestedApi = {}\n\n  for (const [path, func] of Object.entries(registeredFunctions)) {\n    // Only include internal functions in the internal object\n    if (func._visibility !== 'internal') {\n      continue\n    }\n\n    const pathArray = buildPathArray(path)\n    const ref: AnyFunctionReference = {\n      _type: func._type,\n      _args: func._args,\n      _returns: func._returns,\n      _path: path,\n      _visibility: 'internal',\n    }\n\n    setNestedValue(internal, pathArray, ref)\n  }\n\n  return internal\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\n// Re-export all types and functions for convenient access\nexport type {\n  FunctionReference as FunctionRef,\n}\n"]}