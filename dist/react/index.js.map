{"version":3,"sources":["../../src/client/ConvexClient.ts","../../src/react/ConvexProvider.tsx","../../src/react/useQuery.ts","../../src/react/useMutation.ts","../../src/react/useAction.ts","../../src/react/usePaginatedQuery.ts","../../src/react/ConvexProviderWithAuth.tsx"],"names":["useCallback","useState","useRef","useEffect","createContext","useMemo","jsx"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * ConvexClient - WebSocket-based reactive client\n *\n * Provides real-time subscriptions and optimistic updates.\n */\n\nimport type { FunctionReference } from '../types'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Options for creating a ConvexClient.\n */\nexport interface ClientOptions {\n  /** Custom fetch implementation */\n  fetch?: typeof fetch\n  /** Custom WebSocket implementation */\n  WebSocket?: typeof WebSocket\n  /** Whether to automatically reconnect on disconnect */\n  autoReconnect?: boolean\n  /** Reconnection delay in milliseconds */\n  reconnectDelay?: number\n  /** Maximum reconnection attempts */\n  maxReconnectAttempts?: number\n}\n\n/**\n * Options for subscribing to a query.\n */\nexport interface SubscriptionOptions {\n  /** Called when the subscription is first established */\n  onConnect?: () => void\n  /** Called when the subscription is lost */\n  onDisconnect?: () => void\n  /** Called when an error occurs */\n  onError?: (error: Error) => void\n}\n\n/**\n * Callback for subscription updates.\n */\nexport type SubscriptionCallback<T> = (result: T) => void\n\n/**\n * Handle for managing a subscription.\n */\nexport interface SubscriptionHandle {\n  /** Unsubscribe from the query */\n  unsubscribe: () => void\n}\n\n/**\n * Internal subscription state.\n */\ninterface SubscriptionState {\n  id: string\n  queryPath: string\n  args: unknown\n  callback: SubscriptionCallback<unknown>\n  options?: SubscriptionOptions\n  lastResult?: unknown\n}\n\n/**\n * WebSocket message types.\n */\ntype WSMessage =\n  | { type: 'subscribe'; subscriptionId: string; queryPath: string; args: unknown }\n  | { type: 'unsubscribe'; subscriptionId: string }\n  | { type: 'authenticate'; token: string }\n  | { type: 'ping' }\n  | { type: 'subscribed'; subscriptionId: string }\n  | { type: 'update'; subscriptionId: string; data: unknown }\n  | { type: 'error'; subscriptionId?: string; message: string }\n  | { type: 'pong' }\n  | { type: 'authenticated' }\n\n// ============================================================================\n// ConvexClient Implementation\n// ============================================================================\n\n/**\n * WebSocket-based client for convex.do with real-time subscriptions.\n *\n * @example\n * ```typescript\n * import { ConvexClient } from \"convex.do/client\";\n *\n * const client = new ConvexClient(\"https://your-worker.workers.dev\");\n *\n * // Subscribe to a query\n * const unsubscribe = client.onUpdate(api.messages.list, { channel }, (messages) => {\n *   console.log(\"Messages:\", messages);\n * });\n *\n * // Run a mutation\n * await client.mutation(api.messages.send, { channel, body: \"Hello!\" });\n *\n * // Clean up\n * unsubscribe();\n * client.close();\n * ```\n */\nexport class ConvexClient {\n  private url: string\n  private wsUrl: string\n  private options: Required<ClientOptions>\n  private ws: WebSocket | null = null\n  private subscriptions: Map<string, SubscriptionState> = new Map()\n  private pendingSubscriptions: Map<string, SubscriptionState> = new Map()\n  private authToken: string | null = null\n  private isConnected = false\n  private reconnectAttempts = 0\n  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null\n  private pingInterval: ReturnType<typeof setInterval> | null = null\n  private idCounter = 0\n\n  constructor(url: string, options: ClientOptions = {}) {\n    this.url = url.replace(/\\/$/, '')\n    this.wsUrl = this.url.replace(/^http/, 'ws') + '/sync'\n\n    this.options = {\n      fetch: options.fetch ?? globalThis.fetch.bind(globalThis),\n      WebSocket: options.WebSocket ?? globalThis.WebSocket,\n      autoReconnect: options.autoReconnect ?? true,\n      reconnectDelay: options.reconnectDelay ?? 1000,\n      maxReconnectAttempts: options.maxReconnectAttempts ?? 10,\n    }\n\n    this.connect()\n  }\n\n  /**\n   * Set the authentication token.\n   */\n  setAuth(token: string): void {\n    this.authToken = token\n    if (this.ws && this.isConnected) {\n      this.send({ type: 'authenticate', token })\n    }\n  }\n\n  /**\n   * Clear the authentication token.\n   */\n  clearAuth(): void {\n    this.authToken = null\n  }\n\n  /**\n   * Subscribe to a query with real-time updates.\n   */\n  onUpdate<T>(\n    query: FunctionReference<'query', unknown, T>,\n    args: unknown,\n    callback: SubscriptionCallback<T>,\n    options?: SubscriptionOptions\n  ): () => void {\n    const id = this.generateId()\n    const state: SubscriptionState = {\n      id,\n      queryPath: query._path,\n      args,\n      callback: callback as SubscriptionCallback<unknown>,\n      ...(options !== undefined && { options }),\n    }\n\n    if (this.isConnected) {\n      this.subscriptions.set(id, state)\n      this.send({\n        type: 'subscribe',\n        subscriptionId: id,\n        queryPath: query._path,\n        args,\n      })\n    } else {\n      this.pendingSubscriptions.set(id, state)\n    }\n\n    return () => this.unsubscribe(id)\n  }\n\n  /**\n   * Run a query (one-time, non-reactive).\n   */\n  async query<T>(\n    query: FunctionReference<'query', unknown, T>,\n    args: unknown\n  ): Promise<T> {\n    const response = await this.options.fetch(`${this.url}/api/query`, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: JSON.stringify({\n        path: query._path,\n        args,\n        format: 'json',\n      }),\n    })\n\n    if (!response.ok) {\n      const error = await response.json() as { error?: string }\n      throw new Error(error.error || 'Query failed')\n    }\n\n    return response.json() as Promise<T>\n  }\n\n  /**\n   * Run a mutation.\n   */\n  async mutation<T>(\n    mutation: FunctionReference<'mutation', unknown, T>,\n    args: unknown\n  ): Promise<T> {\n    const response = await this.options.fetch(`${this.url}/api/mutation`, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: JSON.stringify({\n        path: mutation._path,\n        args,\n        format: 'json',\n      }),\n    })\n\n    if (!response.ok) {\n      const error = await response.json() as { error?: string }\n      throw new Error(error.error || 'Mutation failed')\n    }\n\n    return response.json() as Promise<T>\n  }\n\n  /**\n   * Run an action.\n   */\n  async action<T>(\n    action: FunctionReference<'action', unknown, T>,\n    args: unknown\n  ): Promise<T> {\n    const response = await this.options.fetch(`${this.url}/api/action`, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: JSON.stringify({\n        path: action._path,\n        args,\n        format: 'json',\n      }),\n    })\n\n    if (!response.ok) {\n      const error = await response.json() as { error?: string }\n      throw new Error(error.error || 'Action failed')\n    }\n\n    return response.json() as Promise<T>\n  }\n\n  /**\n   * Close the client connection.\n   */\n  close(): void {\n    this.options.autoReconnect = false\n\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout)\n      this.reconnectTimeout = null\n    }\n\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval)\n      this.pingInterval = null\n    }\n\n    if (this.ws) {\n      this.ws.close()\n      this.ws = null\n    }\n\n    this.subscriptions.clear()\n    this.pendingSubscriptions.clear()\n    this.isConnected = false\n  }\n\n  // ============================================================================\n  // Private Methods\n  // ============================================================================\n\n  private connect(): void {\n    try {\n      this.ws = new this.options.WebSocket(this.wsUrl)\n\n      this.ws.addEventListener('open', () => {\n        this.isConnected = true\n        this.reconnectAttempts = 0\n\n        // Authenticate if we have a token\n        if (this.authToken) {\n          this.send({ type: 'authenticate', token: this.authToken })\n        }\n\n        // Resubscribe to all subscriptions\n        for (const state of this.subscriptions.values()) {\n          this.send({\n            type: 'subscribe',\n            subscriptionId: state.id,\n            queryPath: state.queryPath,\n            args: state.args,\n          })\n          state.options?.onConnect?.()\n        }\n\n        // Subscribe pending subscriptions\n        for (const [id, state] of this.pendingSubscriptions) {\n          this.subscriptions.set(id, state)\n          this.send({\n            type: 'subscribe',\n            subscriptionId: state.id,\n            queryPath: state.queryPath,\n            args: state.args,\n          })\n          state.options?.onConnect?.()\n        }\n        this.pendingSubscriptions.clear()\n\n        // Start ping interval\n        this.pingInterval = setInterval(() => {\n          if (this.isConnected) {\n            this.send({ type: 'ping' })\n          }\n        }, 30000)\n      })\n\n      this.ws.addEventListener('message', (event: MessageEvent) => {\n        this.handleMessage(event.data as string)\n      })\n\n      this.ws.addEventListener('close', () => {\n        this.isConnected = false\n\n        if (this.pingInterval) {\n          clearInterval(this.pingInterval)\n          this.pingInterval = null\n        }\n\n        // Notify subscriptions of disconnect\n        for (const state of this.subscriptions.values()) {\n          state.options?.onDisconnect?.()\n        }\n\n        // Attempt reconnection\n        if (this.options.autoReconnect && this.reconnectAttempts < this.options.maxReconnectAttempts) {\n          this.reconnectAttempts++\n          const delay = this.options.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1)\n          this.reconnectTimeout = setTimeout(() => this.connect(), delay)\n        }\n      })\n\n      this.ws.addEventListener('error', (event: Event) => {\n        console.error('WebSocket error:', event)\n      })\n    } catch (error) {\n      console.error('Failed to connect:', error)\n      if (this.options.autoReconnect && this.reconnectAttempts < this.options.maxReconnectAttempts) {\n        this.reconnectAttempts++\n        const delay = this.options.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1)\n        this.reconnectTimeout = setTimeout(() => this.connect(), delay)\n      }\n    }\n  }\n\n  private handleMessage(data: string): void {\n    try {\n      const message = JSON.parse(data) as WSMessage\n\n      switch (message.type) {\n        case 'update': {\n          const state = this.subscriptions.get(message.subscriptionId)\n          if (state) {\n            state.lastResult = message.data\n            state.callback(message.data)\n          }\n          break\n        }\n\n        case 'error': {\n          if (message.subscriptionId) {\n            const state = this.subscriptions.get(message.subscriptionId)\n            if (state) {\n              state.options?.onError?.(new Error(message.message))\n            }\n          } else {\n            console.error('Server error:', message.message)\n          }\n          break\n        }\n\n        case 'subscribed':\n        case 'authenticated':\n        case 'pong':\n          // Acknowledgment messages\n          break\n\n        default:\n          console.warn('Unknown message type:', message)\n      }\n    } catch (error) {\n      console.error('Failed to parse message:', error)\n    }\n  }\n\n  private send(message: WSMessage): void {\n    if (this.ws && this.isConnected) {\n      this.ws.send(JSON.stringify(message))\n    }\n  }\n\n  private unsubscribe(id: string): void {\n    const state = this.subscriptions.get(id)\n    if (state) {\n      this.subscriptions.delete(id)\n      if (this.isConnected) {\n        this.send({ type: 'unsubscribe', subscriptionId: id })\n      }\n    }\n\n    this.pendingSubscriptions.delete(id)\n  }\n\n  private generateId(): string {\n    return `sub_${++this.idCounter}_${Date.now()}`\n  }\n\n  private getHeaders(): Record<string, string> {\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    }\n\n    if (this.authToken) {\n      headers['Authorization'] = `Bearer ${this.authToken}`\n    }\n\n    return headers\n  }\n}\n","/**\n * ConvexProvider - React context provider for convex.do\n */\n\nimport { createContext, useContext, useMemo, type ReactNode } from 'react'\nimport { ConvexClient, type ClientOptions } from '../client/ConvexClient'\n\n// ============================================================================\n// Context\n// ============================================================================\n\nconst ConvexContext = createContext<ConvexClient | null>(null)\n\n// ============================================================================\n// Provider\n// ============================================================================\n\n/**\n * Props for ConvexProvider.\n */\nexport interface ConvexProviderProps {\n  /** The convex.do deployment URL */\n  url: string\n  /** Client options */\n  options?: ClientOptions\n  /** Children to render */\n  children: ReactNode\n}\n\n/**\n * Provider component for convex.do React integration.\n *\n * @example\n * ```tsx\n * import { ConvexProvider } from \"convex.do/react\";\n *\n * function App() {\n *   return (\n *     <ConvexProvider url=\"https://your-worker.workers.dev\">\n *       <YourApp />\n *     </ConvexProvider>\n *   );\n * }\n * ```\n */\nexport function ConvexProvider({\n  url,\n  options,\n  children,\n}: ConvexProviderProps): ReactNode {\n  const client = useMemo(() => {\n    return new ConvexClient(url, options)\n  }, [url, options])\n\n  return (\n    <ConvexContext.Provider value={client}>\n      {children}\n    </ConvexContext.Provider>\n  )\n}\n\n// ============================================================================\n// Hook\n// ============================================================================\n\n/**\n * Hook to access the ConvexClient directly.\n *\n * @example\n * ```tsx\n * import { useConvex } from \"convex.do/react\";\n *\n * function MyComponent() {\n *   const client = useConvex();\n *\n *   const handleClick = async () => {\n *     await client.mutation(api.messages.send, { body: \"Hello!\" });\n *   };\n *\n *   return <button onClick={handleClick}>Send</button>;\n * }\n * ```\n */\nexport function useConvex(): ConvexClient {\n  const client = useContext(ConvexContext)\n\n  if (!client) {\n    throw new Error(\n      'useConvex must be used within a ConvexProvider. ' +\n      'Make sure to wrap your app with <ConvexProvider url=\"...\">.'\n    )\n  }\n\n  return client\n}\n","/**\n * useQuery - React hook for reactive queries\n */\n\nimport { useState, useEffect, useRef } from 'react'\nimport { useConvex } from './ConvexProvider'\nimport type { FunctionReference } from '../types'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Result state for useQuery.\n */\nexport type UseQueryResult<T> =\n  | T\n  | undefined\n\n/**\n * Skip token to conditionally disable a query.\n */\nexport const skip = Symbol('skip')\nexport type Skip = typeof skip\n\n// ============================================================================\n// Hook\n// ============================================================================\n\n/**\n * Subscribe to a query with real-time updates.\n *\n * The query will automatically re-run when:\n * - The underlying data changes (pushed from server)\n * - The args change\n *\n * @example\n * ```tsx\n * import { useQuery } from \"convex.do/react\";\n * import { api } from \"../convex/_generated/api\";\n *\n * function MessageList({ channel }: { channel: Id<\"channels\"> }) {\n *   const messages = useQuery(api.messages.list, { channel });\n *\n *   if (messages === undefined) {\n *     return <div>Loading...</div>;\n *   }\n *\n *   return (\n *     <ul>\n *       {messages.map((msg) => (\n *         <li key={msg._id}>{msg.body}</li>\n *       ))}\n *     </ul>\n *   );\n * }\n * ```\n *\n * @example\n * ```tsx\n * // Conditionally skip the query\n * const user = useQuery(\n *   api.users.get,\n *   userId ? { userId } : \"skip\"\n * );\n * ```\n */\nexport function useQuery<T>(\n  query: FunctionReference<'query', unknown, T>,\n  args: unknown | 'skip' | Skip\n): UseQueryResult<T> {\n  const client = useConvex()\n  const [data, setData] = useState<T | undefined>(undefined)\n  const [error, setError] = useState<Error | null>(null)\n\n  // Track args for comparison\n  const argsRef = useRef<string>('')\n  const argsJson = args === 'skip' || args === skip ? '__skip__' : JSON.stringify(args)\n\n  useEffect(() => {\n    // Skip if args indicate skip\n    if (args === 'skip' || args === skip) {\n      setData(undefined)\n      return\n    }\n\n    // Skip if args haven't changed\n    if (argsRef.current === argsJson) {\n      return\n    }\n    argsRef.current = argsJson\n\n    // Subscribe to the query\n    const unsubscribe = client.onUpdate(\n      query,\n      args,\n      (result) => {\n        setData(result)\n        setError(null)\n      },\n      {\n        onError: (err) => {\n          setError(err)\n        },\n      }\n    )\n\n    return () => {\n      unsubscribe()\n    }\n  }, [client, query, argsJson, args])\n\n  // Throw error for error boundary\n  if (error) {\n    throw error\n  }\n\n  return data\n}\n","/**\n * useMutation - React hook for mutations\n */\n\nimport { useCallback, useState } from 'react'\nimport { useConvex } from './ConvexProvider'\nimport type { FunctionReference } from '../types'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * State for mutation execution.\n */\nexport interface MutationState {\n  /** Whether the mutation is currently executing */\n  isLoading: boolean\n  /** Error from the last execution, if any */\n  error: Error | null\n}\n\n/**\n * Return type for useMutation.\n */\nexport type UseMutationReturnType<Args, Returns> = (args: Args) => Promise<Returns>\n\n// ============================================================================\n// Hook\n// ============================================================================\n\n/**\n * Get a function to execute a mutation.\n *\n * @example\n * ```tsx\n * import { useMutation } from \"convex.do/react\";\n * import { api } from \"../convex/_generated/api\";\n *\n * function SendMessage({ channel }: { channel: Id<\"channels\"> }) {\n *   const sendMessage = useMutation(api.messages.send);\n *   const [body, setBody] = useState(\"\");\n *\n *   const handleSubmit = async (e: FormEvent) => {\n *     e.preventDefault();\n *     await sendMessage({ channel, body });\n *     setBody(\"\");\n *   };\n *\n *   return (\n *     <form onSubmit={handleSubmit}>\n *       <input\n *         value={body}\n *         onChange={(e) => setBody(e.target.value)}\n *         placeholder=\"Type a message...\"\n *       />\n *       <button type=\"submit\">Send</button>\n *     </form>\n *   );\n * }\n * ```\n */\nexport function useMutation<Args, Returns>(\n  mutation: FunctionReference<'mutation', Args, Returns>\n): UseMutationReturnType<Args, Returns> {\n  const client = useConvex()\n\n  const mutate = useCallback(\n    async (args: Args): Promise<Returns> => {\n      return client.mutation(mutation, args)\n    },\n    [client, mutation]\n  )\n\n  return mutate\n}\n\n/**\n * Get a function to execute a mutation with loading and error state.\n *\n * @example\n * ```tsx\n * import { useMutationWithState } from \"convex.do/react\";\n *\n * function SendMessage() {\n *   const { mutate, isLoading, error } = useMutationWithState(api.messages.send);\n *\n *   return (\n *     <div>\n *       <button onClick={() => mutate({ body: \"Hello!\" })} disabled={isLoading}>\n *         {isLoading ? \"Sending...\" : \"Send\"}\n *       </button>\n *       {error && <p className=\"error\">{error.message}</p>}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useMutationWithState<Args, Returns>(\n  mutation: FunctionReference<'mutation', Args, Returns>\n): MutationState & { mutate: UseMutationReturnType<Args, Returns> } {\n  const client = useConvex()\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<Error | null>(null)\n\n  const mutate = useCallback(\n    async (args: Args): Promise<Returns> => {\n      setIsLoading(true)\n      setError(null)\n\n      try {\n        const result = await client.mutation(mutation, args)\n        return result\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err))\n        setError(error)\n        throw error\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [client, mutation]\n  )\n\n  return { mutate, isLoading, error }\n}\n","/**\n * useAction - React hook for actions\n */\n\nimport { useCallback, useState } from 'react'\nimport { useConvex } from './ConvexProvider'\nimport type { FunctionReference } from '../types'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * State for action execution.\n */\nexport interface ActionState {\n  /** Whether the action is currently executing */\n  isLoading: boolean\n  /** Error from the last execution, if any */\n  error: Error | null\n}\n\n/**\n * Return type for useAction.\n */\nexport type UseActionReturnType<Args, Returns> = (args: Args) => Promise<Returns>\n\n// ============================================================================\n// Hook\n// ============================================================================\n\n/**\n * Get a function to execute an action.\n *\n * @example\n * ```tsx\n * import { useAction } from \"convex.do/react\";\n * import { api } from \"../convex/_generated/api\";\n *\n * function GenerateImage({ prompt }: { prompt: string }) {\n *   const generate = useAction(api.ai.generateImage);\n *   const [imageUrl, setImageUrl] = useState<string | null>(null);\n *   const [isGenerating, setIsGenerating] = useState(false);\n *\n *   const handleGenerate = async () => {\n *     setIsGenerating(true);\n *     try {\n *       const result = await generate({ prompt });\n *       setImageUrl(result.url);\n *     } finally {\n *       setIsGenerating(false);\n *     }\n *   };\n *\n *   return (\n *     <div>\n *       <button onClick={handleGenerate} disabled={isGenerating}>\n *         {isGenerating ? \"Generating...\" : \"Generate\"}\n *       </button>\n *       {imageUrl && <img src={imageUrl} alt={prompt} />}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useAction<Args, Returns>(\n  action: FunctionReference<'action', Args, Returns>\n): UseActionReturnType<Args, Returns> {\n  const client = useConvex()\n\n  const execute = useCallback(\n    async (args: Args): Promise<Returns> => {\n      return client.action(action, args)\n    },\n    [client, action]\n  )\n\n  return execute\n}\n\n/**\n * Get a function to execute an action with loading and error state.\n *\n * @example\n * ```tsx\n * import { useActionWithState } from \"convex.do/react\";\n *\n * function AIChat() {\n *   const { execute, isLoading, error } = useActionWithState(api.ai.chat);\n *\n *   return (\n *     <div>\n *       <button\n *         onClick={() => execute({ message: \"Hello!\" })}\n *         disabled={isLoading}\n *       >\n *         {isLoading ? \"Thinking...\" : \"Ask AI\"}\n *       </button>\n *       {error && <p className=\"error\">{error.message}</p>}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useActionWithState<Args, Returns>(\n  action: FunctionReference<'action', Args, Returns>\n): ActionState & { execute: UseActionReturnType<Args, Returns> } {\n  const client = useConvex()\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<Error | null>(null)\n\n  const execute = useCallback(\n    async (args: Args): Promise<Returns> => {\n      setIsLoading(true)\n      setError(null)\n\n      try {\n        const result = await client.action(action, args)\n        return result\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err))\n        setError(error)\n        throw error\n      } finally {\n        setIsLoading(false)\n      }\n    },\n    [client, action]\n  )\n\n  return { execute, isLoading, error }\n}\n","/**\n * usePaginatedQuery - React hook for paginated queries\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react'\nimport { useConvex } from './ConvexProvider'\nimport type { FunctionReference, PaginationResult, PaginationOptions } from '../types'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Options for usePaginatedQuery.\n */\nexport interface UsePaginatedQueryOptions {\n  /** Number of items to fetch per page */\n  numItems: number\n}\n\n/**\n * Status of a paginated query.\n */\nexport type PaginatedQueryStatus =\n  | 'LoadingFirstPage'\n  | 'CanLoadMore'\n  | 'LoadingMore'\n  | 'Exhausted'\n\n/**\n * Return type for usePaginatedQuery.\n */\nexport interface UsePaginatedQueryResult<T> {\n  /** All loaded results */\n  results: T[]\n  /** Current status */\n  status: PaginatedQueryStatus\n  /** Whether currently loading */\n  isLoading: boolean\n  /** Function to load more results */\n  loadMore: (numItems: number) => void\n}\n\n// ============================================================================\n// Hook\n// ============================================================================\n\n/**\n * Subscribe to a paginated query with automatic page management.\n *\n * @example\n * ```tsx\n * import { usePaginatedQuery } from \"convex.do/react\";\n * import { api } from \"../convex/_generated/api\";\n *\n * function MessageHistory({ channel }: { channel: Id<\"channels\"> }) {\n *   const { results, status, loadMore } = usePaginatedQuery(\n *     api.messages.listPaginated,\n *     { channel },\n *     { numItems: 20 }\n *   );\n *\n *   return (\n *     <div>\n *       <ul>\n *         {results.map((msg) => (\n *           <li key={msg._id}>{msg.body}</li>\n *         ))}\n *       </ul>\n *\n *       {status === \"CanLoadMore\" && (\n *         <button onClick={() => loadMore(20)}>Load More</button>\n *       )}\n *\n *       {status === \"LoadingMore\" && <div>Loading...</div>}\n *\n *       {status === \"Exhausted\" && <div>No more messages</div>}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function usePaginatedQuery<T>(\n  query: FunctionReference<'query', unknown, PaginationResult<T>>,\n  args: Record<string, unknown>,\n  options: UsePaginatedQueryOptions\n): UsePaginatedQueryResult<T> {\n  const client = useConvex()\n\n  const [results, setResults] = useState<T[]>([])\n  const [status, setStatus] = useState<PaginatedQueryStatus>('LoadingFirstPage')\n  const [cursor, setCursor] = useState<string | null>(null)\n  const [isLoadingMore, setIsLoadingMore] = useState(false)\n\n  // Track args for comparison\n  const argsRef = useRef<string>('')\n  const argsJson = JSON.stringify(args)\n\n  // Reset when args change\n  useEffect(() => {\n    if (argsRef.current !== argsJson) {\n      argsRef.current = argsJson\n      setResults([])\n      setCursor(null)\n      setStatus('LoadingFirstPage')\n    }\n  }, [argsJson])\n\n  // Load first page\n  useEffect(() => {\n    if (status !== 'LoadingFirstPage') return\n\n    const paginationOpts: PaginationOptions = {\n      numItems: options.numItems,\n      cursor: null,\n    }\n\n    const unsubscribe = client.onUpdate(\n      query,\n      { ...args, paginationOpts },\n      (result) => {\n        setResults(result.page)\n        setCursor(result.continueCursor)\n        setStatus(result.isDone ? 'Exhausted' : 'CanLoadMore')\n      }\n    )\n\n    return () => {\n      unsubscribe()\n    }\n  }, [client, query, args, options.numItems, status])\n\n  // Load more function\n  const loadMore = useCallback(\n    async (numItems: number) => {\n      if (status !== 'CanLoadMore' || !cursor) return\n\n      setStatus('LoadingMore')\n      setIsLoadingMore(true)\n\n      try {\n        const paginationOpts: PaginationOptions = {\n          numItems,\n          cursor,\n        }\n\n        const result = await client.query(query, {\n          ...args,\n          paginationOpts,\n        })\n\n        setResults((prev) => [...prev, ...result.page])\n        setCursor(result.continueCursor)\n        setStatus(result.isDone ? 'Exhausted' : 'CanLoadMore')\n      } finally {\n        setIsLoadingMore(false)\n      }\n    },\n    [client, query, args, cursor, status]\n  )\n\n  return {\n    results,\n    status,\n    isLoading: status === 'LoadingFirstPage' || isLoadingMore,\n    loadMore,\n  }\n}\n","/**\n * ConvexProviderWithAuth - Provider with authentication integration\n */\n\nimport { createContext, useContext, useEffect, useState, useMemo, type ReactNode } from 'react'\nimport { ConvexClient, type ClientOptions } from '../client/ConvexClient'\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Authentication state.\n */\nexport interface AuthState {\n  /** Whether authentication is loading */\n  isLoading: boolean\n  /** Whether user is authenticated */\n  isAuthenticated: boolean\n}\n\n/**\n * Authentication client interface.\n * This should be implemented by your auth provider (e.g., Clerk, Auth0).\n */\nexport interface AuthClient {\n  /** Get the current authentication token */\n  getToken(): Promise<string | null>\n  /** Whether the client is currently loading */\n  isLoading: boolean\n  /** Whether the user is authenticated */\n  isAuthenticated: boolean\n  /** Called when auth state changes */\n  onAuthStateChange?: (callback: () => void) => () => void\n}\n\n/**\n * Props for ConvexProviderWithAuth.\n */\nexport interface ConvexProviderWithAuthProps {\n  /** The convex.do deployment URL */\n  url: string\n  /** Client options */\n  options?: ClientOptions\n  /** Authentication client */\n  useAuth: () => AuthClient\n  /** Children to render */\n  children: ReactNode\n}\n\n// ============================================================================\n// Context\n// ============================================================================\n\ninterface ConvexAuthContextValue {\n  client: ConvexClient\n  authState: AuthState\n}\n\nconst ConvexAuthContext = createContext<ConvexAuthContextValue | null>(null)\n\n// ============================================================================\n// Provider\n// ============================================================================\n\n/**\n * Provider component with authentication integration.\n *\n * @example\n * ```tsx\n * import { ConvexProviderWithAuth } from \"convex.do/react\";\n * import { useAuth } from \"@clerk/clerk-react\";\n *\n * function useConvexAuth() {\n *   const { getToken, isLoaded, isSignedIn } = useAuth();\n *   return {\n *     getToken: () => getToken({ template: \"convex\" }),\n *     isLoading: !isLoaded,\n *     isAuthenticated: isSignedIn ?? false,\n *   };\n * }\n *\n * function App() {\n *   return (\n *     <ConvexProviderWithAuth\n *       url=\"https://your-worker.workers.dev\"\n *       useAuth={useConvexAuth}\n *     >\n *       <YourApp />\n *     </ConvexProviderWithAuth>\n *   );\n * }\n * ```\n */\nexport function ConvexProviderWithAuth({\n  url,\n  options,\n  useAuth,\n  children,\n}: ConvexProviderWithAuthProps): ReactNode {\n  const auth = useAuth()\n  const [authState, setAuthState] = useState<AuthState>({\n    isLoading: auth.isLoading,\n    isAuthenticated: auth.isAuthenticated,\n  })\n\n  const client = useMemo(() => {\n    return new ConvexClient(url, options)\n  }, [url, options])\n\n  // Update auth token when authentication changes\n  useEffect(() => {\n    let mounted = true\n\n    const updateAuth = async () => {\n      if (!mounted) return\n\n      setAuthState({\n        isLoading: auth.isLoading,\n        isAuthenticated: auth.isAuthenticated,\n      })\n\n      if (auth.isLoading) return\n\n      if (auth.isAuthenticated) {\n        const token = await auth.getToken()\n        if (token && mounted) {\n          client.setAuth(token)\n        }\n      } else {\n        client.clearAuth()\n      }\n    }\n\n    updateAuth()\n\n    // Subscribe to auth changes if supported\n    const unsubscribe = auth.onAuthStateChange?.(() => {\n      updateAuth()\n    })\n\n    return () => {\n      mounted = false\n      unsubscribe?.()\n    }\n  }, [client, auth])\n\n  const value = useMemo(\n    () => ({ client, authState }),\n    [client, authState]\n  )\n\n  return (\n    <ConvexAuthContext.Provider value={value}>\n      {children}\n    </ConvexAuthContext.Provider>\n  )\n}\n\n// ============================================================================\n// Hooks\n// ============================================================================\n\n/**\n * Hook to access the ConvexClient in an auth-aware context.\n */\nexport function useConvexAuth(): ConvexAuthContextValue {\n  const context = useContext(ConvexAuthContext)\n\n  if (!context) {\n    throw new Error(\n      'useConvexAuth must be used within a ConvexProviderWithAuth. ' +\n      'Make sure to wrap your app with <ConvexProviderWithAuth>.'\n    )\n  }\n\n  return context\n}\n\n/**\n * Hook to get the current authentication state.\n */\nexport function useAuthState(): AuthState {\n  const { authState } = useConvexAuth()\n  return authState\n}\n"]}