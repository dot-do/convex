{"version":3,"sources":["../../src/sync/conflict.ts","../../src/sync/subscription.ts"],"names":["SubscriptionState"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Conflict Resolution for Convex Sync\n *\n * Provides conflict detection and resolution for concurrent updates\n * in the Convex sync system.\n *\n * Bead: convex-936.6 - Conflict Resolution\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Strategy for resolving conflicts\n */\nexport type ConflictStrategy = 'server-wins' | 'client-wins' | 'merge' | 'manual'\n\n/**\n * Type of conflict detected\n */\nexport type ConflictType = 'field-conflict' | 'delete-update' | 'update-delete'\n\n/**\n * Type of change operation\n */\nexport type ChangeType = 'insert' | 'update' | 'delete'\n\n/**\n * Represents a single field conflict\n */\nexport interface FieldConflict {\n  field: string\n  localValue: unknown\n  serverValue: unknown\n}\n\n/**\n * Represents a change to be synced\n */\nexport interface Change {\n  id: string\n  documentId: string\n  table: string\n  type: ChangeType\n  fields: Record<string, unknown>\n  version: number\n  timestamp: number\n  baseFields?: Record<string, unknown>\n}\n\n/**\n * Represents a detected conflict\n */\nexport interface Conflict {\n  type: ConflictType\n  localChange: Change\n  serverChange: Change\n  fieldConflicts: FieldConflict[]\n  localVersion: number\n  serverVersion: number\n  versionDiff: number\n  localTimestamp: number\n  serverTimestamp: number\n  isLocalStale: boolean\n}\n\n/**\n * Result of conflict resolution\n */\nexport interface ResolvedChange {\n  type: ChangeType\n  fields: Record<string, unknown>\n  version: number\n  resolutionStrategy?: ConflictStrategy | 'custom'\n  mergedFields?: string[]\n  baseFields?: Record<string, unknown>\n}\n\n/**\n * Custom conflict handler function\n */\nexport type ConflictHandler = (conflict: Conflict) => ResolvedChange | Promise<ResolvedChange>\n\n/**\n * Custom resolver function\n */\nexport type CustomResolver = (local: Change, server: Change) => {\n  fields: Record<string, unknown>\n  version: number\n  type?: ChangeType\n}\n\n/**\n * Field-level strategy configuration\n */\nexport type FieldStrategy = Record<string, Record<string, ConflictStrategy>>\n\n/**\n * Conflict listener callback\n */\nexport type ConflictListener = (conflict: Conflict) => void\n\n/**\n * Options for ConflictResolver\n */\nexport interface ConflictResolverOptions {\n  defaultStrategy?: ConflictStrategy\n  onConflict?: ConflictHandler\n  versionGenerator?: (serverVersion: number) => number\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Deep equality check for two values\n */\nfunction deepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true\n  if (a === null || b === null) return a === b\n  if (typeof a !== typeof b) return false\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false\n    return a.every((val, idx) => deepEqual(val, b[idx]))\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const aObj = a as Record<string, unknown>\n    const bObj = b as Record<string, unknown>\n    const aKeys = Object.keys(aObj)\n    const bKeys = Object.keys(bObj)\n\n    if (aKeys.length !== bKeys.length) return false\n    return aKeys.every(key => deepEqual(aObj[key], bObj[key]))\n  }\n\n  return false\n}\n\n/**\n * Get all keys from both objects\n */\nfunction getAllKeys(obj1: Record<string, unknown>, obj2: Record<string, unknown>): string[] {\n  const keys = new Set([...Object.keys(obj1), ...Object.keys(obj2)])\n  return Array.from(keys)\n}\n\n// ============================================================================\n// ConflictResolver Class\n// ============================================================================\n\n/**\n * Handles conflict detection and resolution for sync operations\n */\nexport class ConflictResolver {\n  public readonly defaultStrategy: ConflictStrategy\n  public readonly conflictHandler?: ConflictHandler\n  public readonly fieldStrategies: FieldStrategy = {}\n  private readonly versionGenerator: (serverVersion: number) => number\n  private readonly conflictListeners: Set<ConflictListener> = new Set()\n\n  constructor(options: ConflictResolverOptions = {}) {\n    this.defaultStrategy = options.defaultStrategy ?? 'server-wins'\n    this.conflictHandler = options.onConflict\n    this.versionGenerator = options.versionGenerator ?? ((serverVersion: number) => serverVersion + 1)\n  }\n\n  /**\n   * Detect conflicts between local and server changes\n   */\n  detectConflict(localChange: Change, serverChange: Change): Conflict | null {\n    // Different documents or tables - no conflict\n    if (\n      localChange.documentId !== serverChange.documentId ||\n      localChange.table !== serverChange.table\n    ) {\n      return null\n    }\n\n    // Both deletes - no conflict\n    if (localChange.type === 'delete' && serverChange.type === 'delete') {\n      return null\n    }\n\n    // Different documents for insert - no conflict\n    if (\n      localChange.type === 'insert' &&\n      serverChange.type === 'insert' &&\n      localChange.documentId !== serverChange.documentId\n    ) {\n      return null\n    }\n\n    // Determine conflict type\n    let conflictType: ConflictType\n    if (localChange.type === 'delete' && serverChange.type === 'update') {\n      conflictType = 'delete-update'\n    } else if (localChange.type === 'update' && serverChange.type === 'delete') {\n      conflictType = 'update-delete'\n    } else {\n      // Check for field-level conflicts\n      const fieldConflicts = this.detectFieldConflicts(localChange.fields, serverChange.fields)\n\n      if (fieldConflicts.length === 0) {\n        return null\n      }\n\n      conflictType = 'field-conflict'\n    }\n\n    const conflict: Conflict = {\n      type: conflictType,\n      localChange,\n      serverChange,\n      fieldConflicts:\n        conflictType === 'field-conflict'\n          ? this.detectFieldConflicts(localChange.fields, serverChange.fields)\n          : [],\n      localVersion: localChange.version,\n      serverVersion: serverChange.version,\n      versionDiff: serverChange.version - localChange.version,\n      localTimestamp: localChange.timestamp,\n      serverTimestamp: serverChange.timestamp,\n      isLocalStale: serverChange.version - localChange.version > 1,\n    }\n\n    // Notify listeners\n    this.notifyListeners(conflict)\n\n    // Call conflict handler if present\n    if (this.conflictHandler) {\n      this.conflictHandler(conflict)\n    }\n\n    return conflict\n  }\n\n  /**\n   * Detect field-level conflicts between two field objects\n   */\n  private detectFieldConflicts(\n    localFields: Record<string, unknown>,\n    serverFields: Record<string, unknown>\n  ): FieldConflict[] {\n    const conflicts: FieldConflict[] = []\n\n    // Get all keys that exist in both objects\n    const localKeys = new Set(Object.keys(localFields))\n    const serverKeys = new Set(Object.keys(serverFields))\n\n    // Find overlapping keys\n    for (const key of localKeys) {\n      if (serverKeys.has(key)) {\n        const localValue = localFields[key]\n        const serverValue = serverFields[key]\n\n        if (!deepEqual(localValue, serverValue)) {\n          conflicts.push({\n            field: key,\n            localValue,\n            serverValue,\n          })\n        }\n      }\n    }\n\n    return conflicts\n  }\n\n  /**\n   * Resolve a conflict using the specified strategy\n   */\n  resolveConflict(\n    conflict: Conflict,\n    strategy: ConflictStrategy | CustomResolver\n  ): ResolvedChange {\n    // Handle custom resolver function\n    if (typeof strategy === 'function') {\n      const result = strategy(conflict.localChange, conflict.serverChange)\n\n      if (!result || typeof result !== 'object' || !result.fields) {\n        throw new Error('Invalid resolution result: custom resolver must return an object with fields and version')\n      }\n\n      return {\n        type: result.type ?? conflict.serverChange.type,\n        fields: result.fields,\n        version: result.version,\n        resolutionStrategy: 'custom',\n      }\n    }\n\n    // Validate strategy\n    if (!['server-wins', 'client-wins', 'merge', 'manual'].includes(strategy)) {\n      throw new Error(`Invalid conflict strategy: ${strategy}`)\n    }\n\n    // Handle manual strategy\n    if (strategy === 'manual') {\n      if (!this.conflictHandler) {\n        throw new Error('Manual resolution requires a conflict handler to be configured')\n      }\n\n      const result = this.conflictHandler(conflict)\n      if (result instanceof Promise) {\n        throw new Error('For async handlers, use resolveConflictAsync instead')\n      }\n      return {\n        ...result,\n        resolutionStrategy: 'manual',\n      }\n    }\n\n    // Handle delete conflicts\n    if (conflict.type === 'delete-update' || conflict.type === 'update-delete') {\n      return this.resolveDeleteConflict(conflict, strategy)\n    }\n\n    // Handle field conflicts\n    switch (strategy) {\n      case 'server-wins':\n        return this.resolveServerWins(conflict)\n      case 'client-wins':\n        return this.resolveClientWins(conflict)\n      case 'merge':\n        return this.resolveMerge(conflict)\n      default:\n        throw new Error(`Invalid conflict strategy: ${strategy}`)\n    }\n  }\n\n  /**\n   * Resolve a conflict asynchronously (for async handlers)\n   */\n  async resolveConflictAsync(\n    conflict: Conflict,\n    strategy: ConflictStrategy | CustomResolver\n  ): Promise<ResolvedChange> {\n    if (strategy === 'manual' && this.conflictHandler) {\n      const result = await this.conflictHandler(conflict)\n      return {\n        ...result,\n        resolutionStrategy: 'manual',\n      }\n    }\n\n    return this.resolveConflict(conflict, strategy)\n  }\n\n  /**\n   * Resolve using server-wins strategy\n   */\n  private resolveServerWins(conflict: Conflict): ResolvedChange {\n    return {\n      type: conflict.serverChange.type,\n      fields: { ...conflict.serverChange.fields },\n      version: conflict.serverVersion,\n      resolutionStrategy: 'server-wins',\n    }\n  }\n\n  /**\n   * Resolve using client-wins strategy\n   */\n  private resolveClientWins(conflict: Conflict): ResolvedChange {\n    return {\n      type: conflict.localChange.type,\n      fields: { ...conflict.localChange.fields },\n      version: this.versionGenerator(conflict.serverVersion),\n      resolutionStrategy: 'client-wins',\n    }\n  }\n\n  /**\n   * Resolve using merge strategy\n   */\n  private resolveMerge(conflict: Conflict): ResolvedChange {\n    const localFields = conflict.localChange.fields\n    const serverFields = conflict.serverChange.fields\n    const mergedFields: Record<string, unknown> = {}\n    const mergedFieldNames: string[] = []\n\n    // Get all unique keys\n    const allKeys = getAllKeys(localFields, serverFields)\n\n    for (const key of allKeys) {\n      const inLocal = key in localFields\n      const inServer = key in serverFields\n\n      if (inLocal && inServer) {\n        // Both have this field - check for conflict\n        const localValue = localFields[key]\n        const serverValue = serverFields[key]\n\n        if (deepEqual(localValue, serverValue)) {\n          // Same value - no conflict\n          mergedFields[key] = serverValue\n        } else {\n          // Conflict - use field strategy or default\n          const fieldStrategy = this.getFieldStrategy(conflict.localChange.table, key)\n\n          if (fieldStrategy === 'client-wins') {\n            mergedFields[key] = localValue\n          } else {\n            // Default to server-wins for conflicts in merge mode\n            mergedFields[key] = serverValue\n          }\n        }\n      } else if (inLocal) {\n        // Only local has this field\n        mergedFields[key] = localFields[key]\n        mergedFieldNames.push(key)\n      } else {\n        // Only server has this field\n        mergedFields[key] = serverFields[key]\n        mergedFieldNames.push(key)\n      }\n    }\n\n    return {\n      type: conflict.serverChange.type,\n      fields: mergedFields,\n      version: this.versionGenerator(conflict.serverVersion),\n      resolutionStrategy: 'merge',\n      mergedFields: mergedFieldNames,\n    }\n  }\n\n  /**\n   * Resolve delete conflicts\n   */\n  private resolveDeleteConflict(\n    conflict: Conflict,\n    strategy: ConflictStrategy\n  ): ResolvedChange {\n    if (conflict.type === 'delete-update') {\n      // Local wants to delete, server has update\n      if (strategy === 'client-wins') {\n        return {\n          type: 'delete',\n          fields: {},\n          version: this.versionGenerator(conflict.serverVersion),\n          resolutionStrategy: strategy,\n        }\n      } else {\n        // server-wins or merge: keep the update\n        return {\n          type: 'update',\n          fields: { ...conflict.serverChange.fields },\n          version: conflict.serverVersion,\n          resolutionStrategy: strategy,\n        }\n      }\n    } else {\n      // update-delete: Local wants to update, server has delete\n      if (strategy === 'client-wins') {\n        return {\n          type: 'update',\n          fields: { ...conflict.localChange.fields },\n          version: this.versionGenerator(conflict.serverVersion),\n          resolutionStrategy: strategy,\n        }\n      } else {\n        // server-wins or merge: apply the delete\n        return {\n          type: 'delete',\n          fields: {},\n          version: conflict.serverVersion,\n          resolutionStrategy: strategy,\n        }\n      }\n    }\n  }\n\n  /**\n   * Auto-resolve non-conflicting changes\n   */\n  autoResolve(localChange: Change, serverChange: Change): ResolvedChange {\n    // Merge non-conflicting fields\n    const mergedFields: Record<string, unknown> = {\n      ...localChange.fields,\n      ...serverChange.fields,\n    }\n\n    return {\n      type: serverChange.type,\n      fields: mergedFields,\n      version: this.versionGenerator(serverChange.version),\n      resolutionStrategy: 'merge',\n      baseFields: localChange.baseFields ?? serverChange.baseFields,\n    }\n  }\n\n  /**\n   * Set strategy for a specific field in a table\n   */\n  setFieldStrategy(table: string, field: string, strategy: ConflictStrategy): void {\n    if (!this.fieldStrategies[table]) {\n      this.fieldStrategies[table] = {}\n    }\n    this.fieldStrategies[table][field] = strategy\n  }\n\n  /**\n   * Get strategy for a specific field in a table\n   */\n  getFieldStrategy(table: string, field: string): ConflictStrategy {\n    return this.fieldStrategies[table]?.[field] ?? this.defaultStrategy\n  }\n\n  /**\n   * Clear strategy for a specific field\n   */\n  clearFieldStrategy(table: string, field: string): void {\n    if (this.fieldStrategies[table]) {\n      delete this.fieldStrategies[table][field]\n    }\n  }\n\n  /**\n   * Clear all field strategies\n   */\n  clearAllFieldStrategies(): void {\n    for (const table of Object.keys(this.fieldStrategies)) {\n      delete this.fieldStrategies[table]\n    }\n  }\n\n  /**\n   * Add a conflict listener\n   */\n  addConflictListener(listener: ConflictListener): void {\n    this.conflictListeners.add(listener)\n  }\n\n  /**\n   * Remove a conflict listener\n   */\n  removeConflictListener(listener: ConflictListener): void {\n    this.conflictListeners.delete(listener)\n  }\n\n  /**\n   * Notify all listeners of a conflict\n   */\n  private notifyListeners(conflict: Conflict): void {\n    for (const listener of this.conflictListeners) {\n      listener(conflict)\n    }\n  }\n}\n","/**\n * Subscription State Management\n *\n * Provides client-side subscription management for real-time queries\n * in a Convex-compatible way.\n *\n * Features:\n * - Subscribe to queries with callbacks\n * - Track subscription lifecycle (pending, active, error, closed)\n * - Handle multiple subscriptions to same query\n * - Reference counting for deduplicated subscriptions\n * - Callback invocation on data changes\n *\n * @module sync/subscription\n */\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Subscription callback function type.\n */\nexport type SubscriptionCallback<T = unknown> = (data: T) => void | Promise<void>\n\n/**\n * Error callback function type.\n */\nexport type ErrorCallback = (error: Error) => void\n\n/**\n * Subscription states.\n */\nexport enum SubscriptionState {\n  /** Subscription created but no data received yet */\n  Pending = 'pending',\n  /** Subscription is active and receiving updates */\n  Active = 'active',\n  /** Subscription encountered an error */\n  Error = 'error',\n  /** Subscription has been closed */\n  Closed = 'closed',\n}\n\n/**\n * Options for creating a subscription.\n */\nexport interface SubscriptionOptions {\n  /** Skip calling the callback for the initial data */\n  skipInitialCallback?: boolean\n  /** Priority level for the subscription */\n  priority?: 'low' | 'normal' | 'high'\n  /** Error callback */\n  onError?: ErrorCallback\n}\n\n/**\n * Options for the SubscriptionManager.\n */\nexport interface SubscriptionManagerOptions {\n  /** Maximum number of subscriptions allowed */\n  maxSubscriptions?: number\n  /** Enable deduplication of subscriptions with same query and args */\n  deduplicateSubscriptions?: boolean\n  /** Track data history for subscriptions */\n  trackHistory?: boolean\n  /** Callback when a subscription is created */\n  onSubscribe?: (subscription: Subscription) => void\n  /** Callback when a subscription is closed */\n  onUnsubscribe?: (subscription: Subscription) => void\n  /** Callback when a subscription receives data */\n  onUpdate?: (subscription: Subscription, data: unknown) => void\n  /** Callback when a subscription encounters an error */\n  onSubscriptionError?: (subscription: Subscription, error: Error) => void\n}\n\n/**\n * Filter options for getSubscriptions().\n */\nexport interface SubscriptionFilter {\n  /** Filter by query path */\n  query?: string\n  /** Filter by subscription state */\n  state?: SubscriptionState\n}\n\n/**\n * Update options for updateSubscription().\n */\nexport interface UpdateOptions {\n  /** Mark this as the initial data update */\n  isInitial?: boolean\n}\n\n/**\n * JSON representation of a subscription.\n */\nexport interface SubscriptionJSON {\n  id: string\n  query: string\n  args: unknown\n  state: SubscriptionState\n  data: unknown\n  createdAt: number\n  updatedAt: number | undefined\n}\n\n/**\n * JSON representation of the manager state.\n */\nexport interface SubscriptionManagerJSON {\n  subscriptions: SubscriptionJSON[]\n  count: number\n}\n\n// ============================================================================\n// SubscriptionError Class\n// ============================================================================\n\n/**\n * Error class for subscription-related errors.\n */\nexport class SubscriptionError extends Error {\n  /** Error code */\n  code?: string\n  /** Associated subscription ID */\n  subscriptionId?: string\n\n  constructor(message: string, code?: string, subscriptionId?: string) {\n    super(message)\n    this.name = 'SubscriptionError'\n    this.code = code\n    this.subscriptionId = subscriptionId\n\n    // Fix prototype chain for instanceof checks\n    Object.setPrototypeOf(this, SubscriptionError.prototype)\n  }\n}\n\n// ============================================================================\n// Subscription Class\n// ============================================================================\n\n/**\n * Represents a single subscription to a query.\n */\nexport class Subscription<T = unknown> {\n  /** Unique subscription ID */\n  readonly id: string\n  /** Query path */\n  readonly query: string\n  /** Query arguments */\n  readonly args: unknown\n  /** Subscription options */\n  readonly options?: SubscriptionOptions\n  /** Creation timestamp */\n  readonly createdAt: number\n\n  /** Current subscription state */\n  private _state: SubscriptionState = SubscriptionState.Pending\n  /** Current data */\n  private _data: T | undefined\n  /** Current error */\n  private _error: Error | undefined\n  /** Last update timestamp */\n  private _updatedAt: number | undefined\n  /** Data history (if tracking enabled) */\n  private _history: T[] | undefined\n  /** Callback function */\n  private _callback: SubscriptionCallback<T>\n  /** Reference to the manager */\n  private _manager: SubscriptionManager\n  /** Whether initial callback has been skipped */\n  private _initialSkipped: boolean = false\n\n  constructor(\n    id: string,\n    query: string,\n    args: unknown,\n    callback: SubscriptionCallback<T>,\n    manager: SubscriptionManager,\n    options?: SubscriptionOptions,\n    trackHistory?: boolean\n  ) {\n    this.id = id\n    this.query = query\n    this.args = args\n    this._callback = callback\n    this._manager = manager\n    this.options = options\n    this.createdAt = Date.now()\n\n    if (trackHistory) {\n      this._history = []\n    }\n  }\n\n  // Getters for state\n\n  get state(): SubscriptionState {\n    return this._state\n  }\n\n  get data(): T | undefined {\n    return this._data\n  }\n\n  get error(): Error | undefined {\n    return this._error\n  }\n\n  get updatedAt(): number | undefined {\n    return this._updatedAt\n  }\n\n  get history(): T[] | undefined {\n    return this._history\n  }\n\n  get isActive(): boolean {\n    return this._state === SubscriptionState.Active\n  }\n\n  get isPending(): boolean {\n    return this._state === SubscriptionState.Pending\n  }\n\n  get isClosed(): boolean {\n    return this._state === SubscriptionState.Closed\n  }\n\n  get hasError(): boolean {\n    return this._state === SubscriptionState.Error\n  }\n\n  // Internal methods (called by manager)\n\n  /** @internal */\n  _setState(state: SubscriptionState): void {\n    this._state = state\n  }\n\n  /** @internal */\n  _setData(data: T, options?: UpdateOptions): boolean {\n    // Check if we should skip initial callback\n    if (options?.isInitial && this.options?.skipInitialCallback && !this._initialSkipped) {\n      this._initialSkipped = true\n      this._data = data\n      this._updatedAt = Date.now()\n      this._state = SubscriptionState.Active\n      this._error = undefined\n\n      if (this._history) {\n        this._history.push(data)\n      }\n\n      return true\n    }\n\n    this._data = data\n    this._updatedAt = Date.now()\n    this._state = SubscriptionState.Active\n    this._error = undefined\n\n    if (this._history) {\n      this._history.push(data)\n    }\n\n    // Call callback\n    try {\n      this._callback(data)\n    } catch {\n      // Swallow callback errors to prevent breaking the update flow\n    }\n\n    return true\n  }\n\n  /** @internal */\n  _setError(error: Error): void {\n    this._error = error\n    this._state = SubscriptionState.Error\n\n    // Call error callback if provided\n    if (this.options?.onError) {\n      try {\n        this.options.onError(error)\n      } catch {\n        // Swallow error callback errors\n      }\n    }\n  }\n\n  /** @internal */\n  _close(): void {\n    this._state = SubscriptionState.Closed\n  }\n\n  /**\n   * Unsubscribe from this subscription.\n   */\n  unsubscribe(): void {\n    this._manager.unsubscribe(this.id)\n  }\n\n  /**\n   * Convert subscription to JSON representation.\n   */\n  toJSON(): SubscriptionJSON {\n    return {\n      id: this.id,\n      query: this.query,\n      args: this.args,\n      state: this._state,\n      data: this._data,\n      createdAt: this.createdAt,\n      updatedAt: this._updatedAt,\n    }\n  }\n}\n\n// ============================================================================\n// SubscriptionManager Class\n// ============================================================================\n\n/**\n * Generates a unique hash for query + args combination.\n */\nfunction hashQueryArgs(query: string, args: unknown): string {\n  const str = JSON.stringify({ query, args })\n  let hash = 0\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + char\n    hash = hash & hash // Convert to 32bit integer\n  }\n  return `${query}:${hash.toString(36)}`\n}\n\n/**\n * Generates a unique subscription ID.\n */\nfunction generateSubscriptionId(): string {\n  const timestamp = Date.now().toString(36)\n  const random = Math.random().toString(36).substring(2, 10)\n  return `sub_${timestamp}_${random}`\n}\n\n/**\n * Manages subscriptions to real-time queries.\n */\nexport class SubscriptionManager {\n  private _options: SubscriptionManagerOptions\n  private _subscriptions: Map<string, Subscription> = new Map()\n  private _disposed: boolean = false\n\n  // For deduplication\n  private _queryRefCounts: Map<string, number> = new Map()\n  private _querySubscriptions: Map<string, Set<string>> = new Map()\n\n  constructor(options: SubscriptionManagerOptions = {}) {\n    this._options = options\n  }\n\n  /**\n   * Subscribe to a query with a callback.\n   */\n  subscribe<T = unknown>(\n    query: string,\n    args: unknown,\n    callback: SubscriptionCallback<T>,\n    options?: SubscriptionOptions\n  ): Subscription<T> {\n    if (this._disposed) {\n      throw new SubscriptionError(\n        'Cannot subscribe: SubscriptionManager has been disposed',\n        'MANAGER_DISPOSED'\n      )\n    }\n\n    const id = generateSubscriptionId()\n    const subscription = new Subscription<T>(\n      id,\n      query,\n      args,\n      callback,\n      this,\n      options,\n      this._options.trackHistory\n    )\n\n    this._subscriptions.set(id, subscription as Subscription<unknown>)\n\n    // Handle deduplication tracking\n    if (this._options.deduplicateSubscriptions) {\n      const queryHash = hashQueryArgs(query, args)\n\n      const currentCount = this._queryRefCounts.get(queryHash) || 0\n      this._queryRefCounts.set(queryHash, currentCount + 1)\n\n      if (!this._querySubscriptions.has(queryHash)) {\n        this._querySubscriptions.set(queryHash, new Set())\n      }\n      this._querySubscriptions.get(queryHash)!.add(id)\n    }\n\n    // Emit event\n    if (this._options.onSubscribe) {\n      this._options.onSubscribe(subscription as Subscription<unknown>)\n    }\n\n    return subscription\n  }\n\n  /**\n   * Unsubscribe from a subscription by ID.\n   */\n  unsubscribe(subscriptionId: string): boolean {\n    const subscription = this._subscriptions.get(subscriptionId)\n    if (!subscription) {\n      return false\n    }\n\n    // Close the subscription\n    subscription._close()\n\n    // Remove from main map\n    this._subscriptions.delete(subscriptionId)\n\n    // Handle deduplication tracking\n    if (this._options.deduplicateSubscriptions) {\n      const queryHash = hashQueryArgs(subscription.query, subscription.args)\n\n      const currentCount = this._queryRefCounts.get(queryHash) || 0\n      if (currentCount > 1) {\n        this._queryRefCounts.set(queryHash, currentCount - 1)\n      } else {\n        this._queryRefCounts.delete(queryHash)\n      }\n\n      const subs = this._querySubscriptions.get(queryHash)\n      if (subs) {\n        subs.delete(subscriptionId)\n        if (subs.size === 0) {\n          this._querySubscriptions.delete(queryHash)\n        }\n      }\n    }\n\n    // Emit event\n    if (this._options.onUnsubscribe) {\n      this._options.onUnsubscribe(subscription)\n    }\n\n    return true\n  }\n\n  /**\n   * Update subscription data.\n   */\n  updateSubscription(subscriptionId: string, data: unknown, options?: UpdateOptions): boolean {\n    const subscription = this._subscriptions.get(subscriptionId)\n    if (!subscription || subscription.state === SubscriptionState.Closed) {\n      return false\n    }\n\n    subscription._setData(data, options)\n\n    // Emit event\n    if (this._options.onUpdate) {\n      this._options.onUpdate(subscription, data)\n    }\n\n    return true\n  }\n\n  /**\n   * Set subscription error.\n   */\n  setSubscriptionError(subscriptionId: string, error: Error): boolean {\n    const subscription = this._subscriptions.get(subscriptionId)\n    if (!subscription || subscription.state === SubscriptionState.Closed) {\n      return false\n    }\n\n    subscription._setError(error)\n\n    // Emit event\n    if (this._options.onSubscriptionError) {\n      this._options.onSubscriptionError(subscription, error)\n    }\n\n    return true\n  }\n\n  /**\n   * Get all subscriptions, optionally filtered.\n   */\n  getSubscriptions(filter?: SubscriptionFilter): Subscription[] {\n    let subscriptions = Array.from(this._subscriptions.values())\n\n    // Filter out closed subscriptions by default\n    subscriptions = subscriptions.filter(s => s.state !== SubscriptionState.Closed)\n\n    if (filter?.query) {\n      subscriptions = subscriptions.filter(s => s.query === filter.query)\n    }\n\n    if (filter?.state) {\n      subscriptions = subscriptions.filter(s => s.state === filter.state)\n    }\n\n    return subscriptions\n  }\n\n  /**\n   * Get subscription by ID.\n   */\n  getSubscriptionById(subscriptionId: string): Subscription | undefined {\n    return this._subscriptions.get(subscriptionId)\n  }\n\n  /**\n   * Check if a subscription exists.\n   */\n  hasSubscription(subscriptionId: string): boolean {\n    const sub = this._subscriptions.get(subscriptionId)\n    return sub !== undefined && sub.state !== SubscriptionState.Closed\n  }\n\n  /**\n   * Get the count of active subscriptions.\n   */\n  getSubscriptionCount(): number {\n    return this.getSubscriptions().length\n  }\n\n  /**\n   * Unsubscribe all subscriptions.\n   */\n  unsubscribeAll(): void {\n    for (const subscription of this._subscriptions.values()) {\n      subscription._close()\n\n      if (this._options.onUnsubscribe) {\n        this._options.onUnsubscribe(subscription)\n      }\n    }\n\n    this._subscriptions.clear()\n    this._queryRefCounts.clear()\n    this._querySubscriptions.clear()\n  }\n\n  /**\n   * Unsubscribe all subscriptions for a specific query.\n   */\n  unsubscribeByQuery(query: string): number {\n    let removed = 0\n    const toRemove: string[] = []\n\n    for (const [id, subscription] of this._subscriptions) {\n      if (subscription.query === query && subscription.state !== SubscriptionState.Closed) {\n        toRemove.push(id)\n      }\n    }\n\n    for (const id of toRemove) {\n      if (this.unsubscribe(id)) {\n        removed++\n      }\n    }\n\n    return removed\n  }\n\n  /**\n   * Get the reference count for a query (for deduplication).\n   */\n  getQueryRefCount(query: string, args: unknown): number {\n    const queryHash = hashQueryArgs(query, args)\n    return this._queryRefCounts.get(queryHash) || 0\n  }\n\n  /**\n   * Check if a query is still active (has subscriptions).\n   */\n  hasActiveQuery(query: string, args: unknown): boolean {\n    const queryHash = hashQueryArgs(query, args)\n    return (this._queryRefCounts.get(queryHash) || 0) > 0\n  }\n\n  /**\n   * Update all subscriptions for a specific query (for deduplication).\n   */\n  updateByQuery(query: string, args: unknown, data: unknown): number {\n    const queryHash = hashQueryArgs(query, args)\n    const subIds = this._querySubscriptions.get(queryHash)\n\n    if (!subIds) {\n      return 0\n    }\n\n    let updated = 0\n    for (const id of subIds) {\n      if (this.updateSubscription(id, data)) {\n        updated++\n      }\n    }\n\n    return updated\n  }\n\n  /**\n   * Dispose the manager and clean up resources.\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return\n    }\n\n    this.unsubscribeAll()\n    this._disposed = true\n  }\n\n  /**\n   * Convert manager state to JSON.\n   */\n  toJSON(): SubscriptionManagerJSON {\n    const subscriptions = this.getSubscriptions().map(s => s.toJSON())\n    return {\n      subscriptions,\n      count: subscriptions.length,\n    }\n  }\n}\n"]}