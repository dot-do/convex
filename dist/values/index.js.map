{"version":3,"sources":["../../src/values/index.ts"],"names":["v"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Validator system for convex.do\n * 100% compatible with Convex v validators\n */\n\n// ============================================================================\n// Base Validator Interface\n// ============================================================================\n\n/**\n * Base interface for all validators.\n * Provides type inference and validation logic.\n */\nexport interface Validator<T = unknown, IsOptional extends boolean = boolean> {\n  /** The inferred TypeScript type */\n  readonly _type: T\n  /** Whether this validator is optional */\n  readonly isOptional: IsOptional\n  /** Parse and validate a value, throwing on invalid input */\n  parse(value: unknown): T\n  /** Check if a value is valid without throwing */\n  isValid(value: unknown): value is T\n  /** Make this validator optional */\n  optional(): OptionalValidator<T>\n  /** Get a description of this validator for error messages */\n  describe(): string\n}\n\n/**\n * Infer the TypeScript type from a validator.\n */\nexport type Infer<V extends Validator> = V['_type']\n\n// ============================================================================\n// Path context for nested validation errors\n// ============================================================================\n\nclass ValidationContext {\n  private path: (string | number)[] = []\n\n  push(segment: string | number): void {\n    this.path.push(segment)\n  }\n\n  pop(): void {\n    this.path.pop()\n  }\n\n  getPath(): (string | number)[] {\n    return [...this.path]\n  }\n\n  formatPath(): string {\n    return this.path.join('.')\n  }\n}\n\n// Thread-local context for validation\nlet currentContext: ValidationContext | null = null\n\nfunction withContext<T>(fn: () => T): T {\n  const hadContext = currentContext !== null\n  if (!hadContext) {\n    currentContext = new ValidationContext()\n  }\n  try {\n    return fn()\n  } finally {\n    if (!hadContext) {\n      currentContext = null\n    }\n  }\n}\n\nfunction pushPath(segment: string | number): void {\n  currentContext?.push(segment)\n}\n\nfunction popPath(): void {\n  currentContext?.pop()\n}\n\nfunction getPathString(): string {\n  return currentContext?.formatPath() ?? ''\n}\n\n// ============================================================================\n// Base Validator Implementation\n// ============================================================================\n\nabstract class BaseValidator<T, IsOptional extends boolean = false> implements Validator<T, IsOptional> {\n  abstract readonly _type: T\n  readonly isOptional: IsOptional = false as IsOptional\n\n  abstract parse(value: unknown): T\n  abstract describe(): string\n\n  isValid(value: unknown): value is T {\n    try {\n      this.parse(value)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  optional(): OptionalValidator<T> {\n    return new OptionalValidator(this)\n  }\n}\n\n// ============================================================================\n// Primitive Validators\n// ============================================================================\n\n/**\n * Gets a human-readable type name for a value.\n */\nfunction getTypeName(value: unknown): string {\n  if (value === null) return 'null'\n  if (value === undefined) return 'undefined'\n  if (Array.isArray(value)) return 'array'\n  if (value instanceof ArrayBuffer) return 'ArrayBuffer'\n  if (ArrayBuffer.isView(value)) return value.constructor.name\n  if (typeof value === 'number' && Number.isNaN(value)) return 'NaN'\n  if (typeof value === 'object' && value !== null) {\n    // Check for boxed primitives\n    if (value instanceof String) return 'String object'\n    if (value instanceof Number) return 'Number object'\n    if (value instanceof Boolean) return 'Boolean object'\n    return 'object'\n  }\n  return typeof value\n}\n\nclass StringValidator extends BaseValidator<string> {\n  readonly _type!: string\n\n  parse(value: unknown): string {\n    // Reject boxed String objects\n    if (value instanceof String) {\n      throw new Error(`Expected string, got String object`)\n    }\n    if (typeof value !== 'string') {\n      throw new Error(`Expected string, got ${getTypeName(value)}`)\n    }\n    return value\n  }\n\n  describe(): string {\n    return 'string'\n  }\n}\n\nclass NumberValidator extends BaseValidator<number> {\n  readonly _type!: number\n\n  parse(value: unknown): number {\n    // Reject boxed Number objects\n    if (value instanceof Number) {\n      throw new Error(`Expected number, got Number object`)\n    }\n    if (typeof value !== 'number') {\n      throw new Error(`Expected number, got ${getTypeName(value)}`)\n    }\n    // Reject NaN with specific message\n    if (Number.isNaN(value)) {\n      throw new Error(`Expected number, got NaN`)\n    }\n    // Reject Infinity and -Infinity\n    if (!Number.isFinite(value)) {\n      throw new Error(`Expected number, got ${value > 0 ? 'Infinity' : '-Infinity'}`)\n    }\n    return value\n  }\n\n  describe(): string {\n    return 'number'\n  }\n}\n\nclass BooleanValidator extends BaseValidator<boolean> {\n  readonly _type!: boolean\n\n  parse(value: unknown): boolean {\n    // Reject boxed Boolean objects\n    if (value instanceof Boolean) {\n      throw new Error(`Expected boolean, got Boolean object`)\n    }\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected boolean, got ${getTypeName(value)}`)\n    }\n    return value\n  }\n\n  describe(): string {\n    return 'boolean'\n  }\n}\n\nclass NullValidator extends BaseValidator<null> {\n  readonly _type!: null\n\n  parse(value: unknown): null {\n    if (value !== null) {\n      // Provide specific error message for undefined\n      if (value === undefined) {\n        throw new Error(`undefined is not null`)\n      }\n      throw new Error(`Expected null, got ${getTypeName(value)}`)\n    }\n    return value\n  }\n\n  describe(): string {\n    return 'null'\n  }\n}\n\nconst INT64_MAX = BigInt('9223372036854775807')\nconst INT64_MIN = BigInt('-9223372036854775808')\n\nclass Int64Validator extends BaseValidator<bigint> {\n  readonly _type!: bigint\n\n  parse(value: unknown): bigint {\n    let result: bigint\n\n    if (typeof value === 'bigint') {\n      result = value\n    } else if (typeof value === 'number') {\n      // Reject NaN, Infinity, -Infinity\n      if (Number.isNaN(value)) {\n        throw new Error(`Expected int64/bigint, got NaN`)\n      }\n      if (!Number.isFinite(value)) {\n        throw new Error(`Expected int64/bigint, got ${value > 0 ? 'Infinity' : '-Infinity'}`)\n      }\n      // Reject non-integer numbers\n      if (!Number.isInteger(value)) {\n        throw new Error(`Expected int64/bigint, got float (${value})`)\n      }\n      result = BigInt(value)\n    } else if (typeof value === 'string') {\n      // Reject empty strings with specific message\n      if (value === '') {\n        throw new Error(`Cannot convert empty string to int64`)\n      }\n      // Reject float strings\n      if (value.includes('.')) {\n        throw new Error(`Expected int64/bigint, got float string (\"${value}\")`)\n      }\n      try {\n        result = BigInt(value)\n      } catch {\n        throw new Error(`Cannot convert \"${value}\" to int64`)\n      }\n    } else {\n      throw new Error(`Expected int64/bigint, got ${getTypeName(value)}`)\n    }\n\n    // Check int64 bounds\n    if (result > INT64_MAX) {\n      throw new Error(`Value ${result} exceeds maximum int64 value (${INT64_MAX})`)\n    }\n    if (result < INT64_MIN) {\n      throw new Error(`Value ${result} is less than minimum int64 value (${INT64_MIN})`)\n    }\n\n    return result\n  }\n\n  describe(): string {\n    return 'int64'\n  }\n}\n\nclass Float64Validator extends BaseValidator<number> {\n  readonly _type!: number\n\n  parse(value: unknown): number {\n    // Reject boxed Number objects\n    if (value instanceof Number) {\n      throw new Error(`Expected float64/number, got Number object`)\n    }\n    if (typeof value !== 'number') {\n      throw new Error(`Expected float64/number, got ${getTypeName(value)}`)\n    }\n    // Reject NaN with specific message\n    if (Number.isNaN(value)) {\n      throw new Error(`NaN is not a valid float64`)\n    }\n    // Note: float64 accepts Infinity and -Infinity (they are valid IEEE 754 values)\n    return value\n  }\n\n  describe(): string {\n    return 'float64'\n  }\n}\n\nclass BytesValidator extends BaseValidator<ArrayBuffer> {\n  readonly _type!: ArrayBuffer\n\n  parse(value: unknown): ArrayBuffer {\n    if (value instanceof ArrayBuffer) {\n      return value\n    }\n    if (ArrayBuffer.isView(value)) {\n      return value.buffer.slice(value.byteOffset, value.byteOffset + value.byteLength) as ArrayBuffer\n    }\n    throw new Error(`Expected bytes/ArrayBuffer, got ${typeof value}`)\n  }\n\n  describe(): string {\n    return 'bytes'\n  }\n}\n\n// ============================================================================\n// ID Validator\n// ============================================================================\n\n/**\n * Minimum valid length for Convex IDs (32 characters standard)\n */\nconst MIN_ID_LENGTH = 32\n\n/**\n * Maximum valid length for Convex IDs\n */\nconst MAX_ID_LENGTH = 128\n\n/**\n * Pattern for valid Convex ID characters (alphanumeric only for standard format)\n * Allows uppercase, lowercase letters and digits\n */\nconst VALID_ID_PATTERN = /^[A-Za-z0-9]+$/\n\nclass IdValidator<TableName extends string> extends BaseValidator<string & { __tableName: TableName }> {\n  readonly _type!: string & { __tableName: TableName }\n  private tableName: TableName\n\n  constructor(tableName: TableName) {\n    super()\n    if (!tableName || tableName.trim() === '') {\n      throw new Error('Table name cannot be empty')\n    }\n    this.tableName = tableName\n  }\n\n  parse(value: unknown): string & { __tableName: TableName } {\n    // Must be a string\n    if (typeof value !== 'string') {\n      throw new Error(`Expected ID for table \"${this.tableName}\", got ${getTypeName(value)}`)\n    }\n\n    // ID cannot be empty\n    if (value.length === 0) {\n      throw new Error(`ID for table \"${this.tableName}\" cannot be empty`)\n    }\n\n    // ID must meet minimum length (32 characters for Convex IDs)\n    if (value.length < MIN_ID_LENGTH) {\n      throw new Error(`Invalid ID for table \"${this.tableName}\": ID is too short (minimum ${MIN_ID_LENGTH} characters)`)\n    }\n\n    // ID cannot exceed maximum length\n    if (value.length > MAX_ID_LENGTH) {\n      throw new Error(`Invalid ID for table \"${this.tableName}\": ID is too long (maximum ${MAX_ID_LENGTH} characters)`)\n    }\n\n    // ID must only contain valid characters (alphanumeric)\n    if (!VALID_ID_PATTERN.test(value)) {\n      throw new Error(`Invalid ID for table \"${this.tableName}\": ID contains invalid characters`)\n    }\n\n    return value as string & { __tableName: TableName }\n  }\n\n  describe(): string {\n    return `v.id(\"${this.tableName}\")`\n  }\n}\n\n// ============================================================================\n// Complex Validators\n// ============================================================================\n\ntype ObjectShape = Record<string, Validator>\ntype InferObject<T extends ObjectShape> = {\n  [K in keyof T]: Infer<T[K]>\n}\n\ntype ObjectMode = 'strip' | 'strict' | 'passthrough'\n\nclass ObjectValidator<T extends ObjectShape> extends BaseValidator<InferObject<T>> {\n  readonly _type!: InferObject<T>\n  private shape: T\n  private mode: ObjectMode\n\n  constructor(shape: T, mode: ObjectMode = 'strip') {\n    super()\n    this.shape = shape\n    this.mode = mode\n  }\n\n  parse(value: unknown): InferObject<T> {\n    return withContext(() => this.parseInternal(value))\n  }\n\n  private parseInternal(value: unknown): InferObject<T> {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`Expected object, got ${value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value}`)\n    }\n\n    const result: Record<string, unknown> = {}\n    const obj = value as Record<string, unknown>\n    const schemaKeys = new Set(Object.keys(this.shape))\n\n    // Check for extra fields in strict mode\n    if (this.mode === 'strict') {\n      for (const key of Object.keys(obj)) {\n        if (!schemaKeys.has(key)) {\n          throw new Error(`Unexpected field \"${key}\" in object`)\n        }\n      }\n    }\n\n    // Validate schema fields\n    for (const [key, validator] of Object.entries(this.shape)) {\n      const fieldValue = obj[key]\n      if (fieldValue === undefined && !validator.isOptional) {\n        throw new Error(`Missing required field \"${key}\"`)\n      }\n      if (fieldValue !== undefined) {\n        pushPath(key)\n        try {\n          result[key] = validator.parse(fieldValue)\n        } catch (e) {\n          const path = getPathString()\n          const innerMsg = (e as Error).message\n          throw new Error(path ? `Validation error at ${path}: ${innerMsg}` : innerMsg)\n        } finally {\n          popPath()\n        }\n      }\n    }\n\n    // In passthrough mode, include extra fields\n    if (this.mode === 'passthrough') {\n      for (const key of Object.keys(obj)) {\n        if (!schemaKeys.has(key)) {\n          result[key] = obj[key]\n        }\n      }\n    }\n\n    return result as InferObject<T>\n  }\n\n  describe(): string {\n    const fields = Object.entries(this.shape)\n      .map(([key, v]) => `${key}: ${v.describe()}`)\n      .join(', ')\n    return `{ ${fields} }`\n  }\n\n  /**\n   * Returns a new validator that throws on extra fields.\n   */\n  strict(): ObjectValidator<T> {\n    return new ObjectValidator(this.shape, 'strict')\n  }\n\n  /**\n   * Returns a new validator that passes through extra fields.\n   */\n  passthrough(): ObjectValidator<T> {\n    return new ObjectValidator(this.shape, 'passthrough')\n  }\n\n  /**\n   * Returns a new validator with additional fields.\n   */\n  extend<U extends ObjectShape>(additionalShape: U): ObjectValidator<T & U> {\n    return new ObjectValidator({ ...this.shape, ...additionalShape } as T & U, this.mode)\n  }\n\n  /**\n   * Returns a new validator with only the specified fields.\n   */\n  pick<K extends keyof T>(keys: K[]): ObjectValidator<Pick<T, K>> {\n    const newShape: Partial<T> = {}\n    for (const key of keys) {\n      if (key in this.shape) {\n        newShape[key] = this.shape[key]\n      }\n    }\n    return new ObjectValidator(newShape as Pick<T, K>, this.mode)\n  }\n\n  /**\n   * Returns a new validator without the specified fields.\n   */\n  omit<K extends keyof T>(keys: K[]): ObjectValidator<Omit<T, K>> {\n    const keysToOmit = new Set(keys as (string | number | symbol)[])\n    const newShape: Partial<T> = {}\n    for (const [key, validator] of Object.entries(this.shape)) {\n      if (!keysToOmit.has(key)) {\n        (newShape as Record<string, unknown>)[key] = validator\n      }\n    }\n    return new ObjectValidator(newShape as Omit<T, K>, this.mode)\n  }\n}\n\ninterface ArrayConstraints {\n  minLength?: number\n  maxLength?: number\n  exactLength?: number\n}\n\nclass ArrayValidator<T extends Validator> extends BaseValidator<Infer<T>[]> {\n  readonly _type!: Infer<T>[]\n  private element: T\n  private constraints: ArrayConstraints\n\n  constructor(element: T, constraints: ArrayConstraints = {}) {\n    super()\n    this.element = element\n    this.constraints = constraints\n  }\n\n  parse(value: unknown): Infer<T>[] {\n    if (!Array.isArray(value)) {\n      throw new Error(`Expected array, got ${value === null ? 'null' : typeof value}`)\n    }\n\n    // Check length constraints\n    if (this.constraints.minLength !== undefined && value.length < this.constraints.minLength) {\n      throw new Error(`Array must have at least ${this.constraints.minLength} element(s), got ${value.length}`)\n    }\n    if (this.constraints.maxLength !== undefined && value.length > this.constraints.maxLength) {\n      throw new Error(`Array must have at most ${this.constraints.maxLength} element(s), got ${value.length}`)\n    }\n    if (this.constraints.exactLength !== undefined && value.length !== this.constraints.exactLength) {\n      throw new Error(`Array must have exactly ${this.constraints.exactLength} element(s), got ${value.length}`)\n    }\n\n    return value.map((item, index) => {\n      pushPath(index)\n      try {\n        return this.element.parse(item)\n      } catch (e) {\n        const path = getPathString()\n        const innerMsg = (e as Error).message\n        throw new Error(path ? `Invalid element at index ${index}: ${innerMsg}` : `Invalid array element at index ${index}: ${innerMsg}`)\n      } finally {\n        popPath()\n      }\n    })\n  }\n\n  describe(): string {\n    return `${this.element.describe()}[]`\n  }\n\n  /**\n   * Returns a new validator that requires at least one element.\n   */\n  nonempty(): ArrayValidator<T> {\n    return new ArrayValidator(this.element, { ...this.constraints, minLength: 1 })\n  }\n\n  /**\n   * Returns a new validator with a minimum length constraint.\n   */\n  min(minLength: number): ArrayValidator<T> {\n    return new ArrayValidator(this.element, { ...this.constraints, minLength })\n  }\n\n  /**\n   * Returns a new validator with a maximum length constraint.\n   */\n  max(maxLength: number): ArrayValidator<T> {\n    return new ArrayValidator(this.element, { ...this.constraints, maxLength })\n  }\n\n  /**\n   * Returns a new validator with an exact length constraint.\n   */\n  length(exactLength: number): ArrayValidator<T> {\n    return new ArrayValidator(this.element, { ...this.constraints, exactLength })\n  }\n}\n\ntype InferUnion<T extends Validator[]> = T[number] extends Validator<infer U> ? U : never\n\nclass UnionValidator<T extends Validator[]> extends BaseValidator<InferUnion<T>> {\n  readonly _type!: InferUnion<T>\n  private validators: T\n\n  constructor(validators: T) {\n    super()\n    this.validators = validators\n  }\n\n  parse(value: unknown): InferUnion<T> {\n    const errors: string[] = []\n\n    for (const validator of this.validators) {\n      try {\n        return validator.parse(value) as InferUnion<T>\n      } catch (e) {\n        errors.push((e as Error).message)\n      }\n    }\n\n    throw new Error(`Value doesn't match any variant: ${errors.join('; ')}`)\n  }\n\n  describe(): string {\n    return this.validators.map(v => v.describe()).join(' | ')\n  }\n}\n\nclass OptionalValidator<T> extends BaseValidator<T | undefined, true> {\n  readonly _type!: T | undefined\n  override readonly isOptional: true = true\n  private inner: Validator<T>\n\n  constructor(inner: Validator<T>) {\n    super()\n    this.inner = inner\n  }\n\n  parse(value: unknown): T | undefined {\n    if (value === undefined) {\n      return undefined\n    }\n    return this.inner.parse(value)\n  }\n\n  describe(): string {\n    return `${this.inner.describe()} | undefined`\n  }\n\n  override optional(): OptionalValidator<T | undefined> {\n    return this as unknown as OptionalValidator<T | undefined>\n  }\n\n  /**\n   * Returns a new validator that provides a default value when undefined.\n   */\n  default(defaultValue: T): DefaultValidator<T> {\n    return new DefaultValidator(this.inner, defaultValue)\n  }\n}\n\nclass DefaultValidator<T> extends BaseValidator<T, true> {\n  readonly _type!: T\n  override readonly isOptional: true = true\n  private inner: Validator<T>\n  private defaultValue: T\n\n  constructor(inner: Validator<T>, defaultValue: T) {\n    super()\n    this.inner = inner\n    this.defaultValue = defaultValue\n  }\n\n  parse(value: unknown): T {\n    if (value === undefined) {\n      return this.defaultValue\n    }\n    return this.inner.parse(value)\n  }\n\n  describe(): string {\n    return `${this.inner.describe()} (default: ${JSON.stringify(this.defaultValue)})`\n  }\n}\n\nclass LiteralValidator<T extends string | number | boolean> extends BaseValidator<T> {\n  readonly _type!: T\n  private literal: T\n\n  constructor(literal: T) {\n    super()\n    this.literal = literal\n  }\n\n  parse(value: unknown): T {\n    if (value !== this.literal) {\n      throw new Error(`Expected literal ${JSON.stringify(this.literal)}, got ${JSON.stringify(value)}`)\n    }\n    return value as T\n  }\n\n  describe(): string {\n    return JSON.stringify(this.literal)\n  }\n}\n\nclass RecordValidator<K extends Validator<string>, V extends Validator> extends BaseValidator<Record<Infer<K>, Infer<V>>> {\n  readonly _type!: Record<Infer<K>, Infer<V>>\n  private keys: K\n  private values: V\n\n  constructor(keys: K, values: V) {\n    super()\n    this.keys = keys\n    this.values = values\n  }\n\n  parse(value: unknown): Record<Infer<K>, Infer<V>> {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`Expected record/object, got ${value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value}`)\n    }\n\n    const result: Record<string, unknown> = {}\n    const obj = value as Record<string, unknown>\n\n    for (const [key, val] of Object.entries(obj)) {\n      try {\n        this.keys.parse(key)\n      } catch (e) {\n        throw new Error(`Invalid key \"${key}\": ${(e as Error).message}`)\n      }\n      try {\n        result[key] = this.values.parse(val)\n      } catch (e) {\n        throw new Error(`Invalid value for key \"${key}\": ${(e as Error).message}`)\n      }\n    }\n\n    return result as Record<Infer<K>, Infer<V>>\n  }\n\n  describe(): string {\n    return `Record<${this.keys.describe()}, ${this.values.describe()}>`\n  }\n}\n\nclass AnyValidator extends BaseValidator<unknown> {\n  readonly _type!: unknown\n\n  parse(value: unknown): unknown {\n    return value\n  }\n\n  describe(): string {\n    return 'any'\n  }\n}\n\nclass UnknownValidator extends BaseValidator<unknown> {\n  readonly _type!: unknown\n\n  parse(value: unknown): unknown {\n    return value\n  }\n\n  describe(): string {\n    return 'unknown'\n  }\n}\n\nclass NullableValidator<T> extends BaseValidator<T | null> {\n  readonly _type!: T | null\n  private inner: Validator<T>\n\n  constructor(inner: Validator<T>) {\n    super()\n    this.inner = inner\n  }\n\n  parse(value: unknown): T | null {\n    if (value === null) {\n      return null\n    }\n    return this.inner.parse(value)\n  }\n\n  describe(): string {\n    return `${this.inner.describe()} | null`\n  }\n}\n\nclass NullishValidator<T> extends BaseValidator<T | null | undefined, true> {\n  readonly _type!: T | null | undefined\n  override readonly isOptional: true = true\n  private inner: Validator<T>\n\n  constructor(inner: Validator<T>) {\n    super()\n    this.inner = inner\n  }\n\n  parse(value: unknown): T | null | undefined {\n    if (value === null) {\n      return null\n    }\n    if (value === undefined) {\n      return undefined\n    }\n    return this.inner.parse(value)\n  }\n\n  describe(): string {\n    return `${this.inner.describe()} | null | undefined`\n  }\n}\n\nclass DiscriminatedUnionValidator<T extends Validator[]> extends BaseValidator<InferUnion<T>> {\n  readonly _type!: InferUnion<T>\n  private discriminator: string\n  private validators: T\n\n  constructor(discriminator: string, validators: T) {\n    super()\n    this.discriminator = discriminator\n    this.validators = validators\n  }\n\n  parse(value: unknown): InferUnion<T> {\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n      throw new Error(`Expected object with discriminator \"${this.discriminator}\", got ${value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value}`)\n    }\n\n    // Try each validator\n    const errors: string[] = []\n    for (const validator of this.validators) {\n      try {\n        return validator.parse(value) as InferUnion<T>\n      } catch (e) {\n        errors.push((e as Error).message)\n      }\n    }\n\n    throw new Error(`Value doesn't match any variant for discriminator \"${this.discriminator}\": ${errors.join('; ')}`)\n  }\n\n  describe(): string {\n    return this.validators.map(v => v.describe()).join(' | ')\n  }\n}\n\n// ============================================================================\n// Validator Factory (v namespace)\n// ============================================================================\n\n/**\n * The v namespace provides factory functions for creating validators.\n * This is 100% compatible with Convex's v validators.\n */\nexport const v = {\n  // Primitives\n  string: () => new StringValidator(),\n  number: () => new NumberValidator(),\n  boolean: () => new BooleanValidator(),\n  null: () => new NullValidator(),\n  int64: () => new Int64Validator(),\n  float64: () => new Float64Validator(),\n  bytes: () => new BytesValidator(),\n\n  // ID type\n  id: <T extends string>(tableName: T) => new IdValidator(tableName),\n\n  // Complex types\n  object: <T extends ObjectShape>(shape: T) => new ObjectValidator(shape),\n  array: <T extends Validator>(element: T) => new ArrayValidator(element),\n  union: <T extends Validator[]>(...validators: T) => new UnionValidator(validators),\n  optional: <T extends Validator>(validator: T) => new OptionalValidator(validator as Validator<Infer<T>>),\n  literal: <T extends string | number | boolean>(value: T) => new LiteralValidator(value),\n  record: <K extends Validator<string>, V extends Validator>(keys: K | V, values?: V) => {\n    // Support both v.record(keyValidator, valueValidator) and v.record(valueValidator) syntaxes\n    if (values === undefined) {\n      // Shorthand: v.record(valueValidator) - keys are implicitly strings\n      return new RecordValidator(new StringValidator(), keys as V)\n    }\n    return new RecordValidator(keys as K, values)\n  },\n  any: () => new AnyValidator(),\n  unknown: () => new UnknownValidator(),\n  nullable: <T extends Validator>(validator: T) => new NullableValidator(validator as Validator<Infer<T>>),\n  nullish: <T extends Validator>(validator: T) => new NullishValidator(validator as Validator<Infer<T>>),\n  discriminatedUnion: <T extends Validator[]>(discriminator: string, validators: T) => new DiscriminatedUnionValidator(discriminator, validators),\n} as const\n\n// ============================================================================\n// Type utilities\n// ============================================================================\n\n/**\n * Args validator type for function definitions.\n */\nexport type ArgsValidator = Validator<Record<string, unknown>> | Record<string, Validator>\n\n/**\n * Infer args type from an args validator.\n */\nexport type InferArgs<T extends ArgsValidator> = T extends Validator<infer U>\n  ? U\n  : T extends Record<string, Validator>\n  ? { [K in keyof T]: Infer<T[K]> }\n  : never\n\n"]}